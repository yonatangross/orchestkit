{
  "skill": "langgraph",
  "version": "2.0.0",
  "testCases": [
    {
      "id": "state-accumulating",
      "rule": "state-typeddict",
      "query": "Design state that accumulates findings from multiple agents",
      "expectedBehavior": [
        "Uses TypedDict for state schema",
        "Uses Annotated[list, add] for accumulating fields",
        "Imports operator.add for reducer",
        "Nodes return partial updates, not full state"
      ]
    },
    {
      "id": "state-context-schema",
      "rule": "state-typeddict",
      "query": "Add configuration that persists across all nodes like temperature",
      "expectedBehavior": [
        "Creates context_schema dataclass",
        "Passes to StateGraph constructor",
        "Accesses via get_context() in nodes",
        "Keeps config separate from workflow state"
      ]
    },
    {
      "id": "state-pydantic",
      "rule": "state-pydantic",
      "query": "Use Pydantic for validated state with defaults",
      "expectedBehavior": [
        "Uses BaseModel instead of TypedDict",
        "Adds Field() with defaults and descriptions",
        "Enables validation on state updates",
        "Handles validation errors gracefully"
      ]
    },
    {
      "id": "routing-conditional",
      "rule": "routing-conditional",
      "query": "Add conditional routing based on whether content needs review",
      "expectedBehavior": [
        "Uses add_conditional_edges with routing function",
        "Returns string matching edge names",
        "Includes all possible routes in edge map",
        "Has fallback or END condition"
      ]
    },
    {
      "id": "routing-retry",
      "rule": "routing-retry-loops",
      "query": "Implement a retry loop that attempts up to 3 times then fails",
      "expectedBehavior": [
        "Tracks retry_count in state",
        "Routes back to retry node when count < 3",
        "Routes to failure node when count >= 3",
        "Increments counter on each retry"
      ]
    },
    {
      "id": "routing-semantic",
      "rule": "routing-semantic",
      "query": "Create a semantic router that classifies user intent and routes accordingly",
      "expectedBehavior": [
        "Uses LLM with structured output for classification",
        "Returns valid route names",
        "Handles unknown/other category",
        "Uses Literal type for route validation"
      ]
    },
    {
      "id": "parallel-fanout",
      "rule": "parallel-fanout-fanin",
      "query": "Process a list of items in parallel with separate worker nodes",
      "expectedBehavior": [
        "Uses Send() to dispatch to workers",
        "Returns list of Send objects from router",
        "Each Send includes state subset",
        "Workers run in parallel"
      ]
    },
    {
      "id": "parallel-fanin",
      "rule": "parallel-fanout-fanin",
      "query": "Collect results from parallel workers into a single list",
      "expectedBehavior": [
        "Uses Annotated[list, add] reducer",
        "Workers return partial updates",
        "Results accumulate automatically",
        "Single node receives all results"
      ]
    },
    {
      "id": "parallel-mapreduce",
      "rule": "parallel-map-reduce",
      "query": "Implement map-reduce: parallel processing then reduce to single output",
      "expectedBehavior": [
        "Map phase uses Send() for parallelization",
        "Reduce node has edges from all workers",
        "Reduce aggregates accumulated results",
        "Single final output produced"
      ]
    },
    {
      "id": "supervisor-basic",
      "rule": "supervisor-basic",
      "query": "Create a supervisor that coordinates two workers: analyzer and validator",
      "expectedBehavior": [
        "Uses StateGraph with supervisor node",
        "Creates worker nodes for analyzer and validator",
        "Workers have edges back to supervisor",
        "Uses add_edge(START, 'supervisor') not set_entry_point()",
        "Includes END condition in routing"
      ]
    },
    {
      "id": "supervisor-command",
      "rule": "supervisor-basic",
      "query": "Build a supervisor that updates state and routes in the same step",
      "expectedBehavior": [
        "Imports Command from langgraph.types",
        "Supervisor returns Command with update and goto",
        "Uses Literal type annotation for type safety",
        "No conditional_edges needed when using Command"
      ]
    },
    {
      "id": "supervisor-roundrobin",
      "rule": "supervisor-round-robin",
      "query": "Implement a supervisor that visits all agents exactly once before finishing",
      "expectedBehavior": [
        "Tracks completed agents in state",
        "Checks available vs completed agents",
        "Routes to quality_gate or END when all done",
        "Prevents infinite loops"
      ]
    },
    {
      "id": "tools-binding",
      "rule": "tools-bind",
      "query": "Bind tools to an LLM and create a ToolNode for execution",
      "expectedBehavior": [
        "Uses @tool decorator for tool functions",
        "Calls llm.bind_tools(tools) for binding",
        "Creates ToolNode(tools) for execution",
        "Adds agent node and tool node to graph"
      ]
    },
    {
      "id": "tools-approval",
      "rule": "tools-interrupts",
      "query": "Add human approval before executing a delete tool",
      "expectedBehavior": [
        "Uses interrupt() inside tool function",
        "Shows action details in interrupt payload",
        "Checks approval response before executing",
        "Returns cancelled message if rejected"
      ]
    },
    {
      "id": "tools-dynamic",
      "rule": "tools-dynamic",
      "query": "Select different tools based on user permissions",
      "expectedBehavior": [
        "Reads user permissions from state",
        "Filters available tools based on permissions",
        "Binds only allowed tools to LLM",
        "Handles case where no tools available"
      ]
    },
    {
      "id": "checkpoints-postgres",
      "rule": "checkpoints-setup",
      "query": "Add PostgreSQL checkpointing to persist workflow state",
      "expectedBehavior": [
        "Uses PostgresSaver.from_conn_string()",
        "Passes checkpointer to compile()",
        "Sets thread_id in config for resumption",
        "Uses async connection for async workflows"
      ]
    },
    {
      "id": "checkpoints-resume",
      "rule": "checkpoints-recovery",
      "query": "Resume a workflow that was interrupted",
      "expectedBehavior": [
        "Uses same thread_id as original run",
        "Calls invoke/ainvoke with None as input",
        "Workflow continues from last checkpoint",
        "Handles case where no checkpoint exists"
      ]
    },
    {
      "id": "checkpoints-debug",
      "rule": "checkpoints-recovery",
      "query": "List all checkpoints for debugging a failed workflow",
      "expectedBehavior": [
        "Uses get_state_history() method",
        "Iterates through StateSnapshot objects",
        "Accesses values, next, and config from snapshots",
        "Can identify which node failed"
      ]
    },
    {
      "id": "human-approval",
      "rule": "human-in-loop-interrupt",
      "query": "Add human approval before executing a dangerous operation",
      "expectedBehavior": [
        "Uses interrupt() function from langgraph.types",
        "Passes approval request data to interrupt()",
        "Resumes with Command(resume=response)",
        "Handles approval and rejection cases"
      ]
    },
    {
      "id": "human-edit",
      "rule": "human-in-loop-approval",
      "query": "Let human edit AI-generated content before proceeding",
      "expectedBehavior": [
        "Shows generated content in interrupt payload",
        "Human can modify or approve",
        "Resume uses human-edited version",
        "Original preserved if human approves as-is"
      ]
    },
    {
      "id": "human-feedback-loop",
      "rule": "human-in-loop-feedback",
      "query": "Implement review loop until human approves quality",
      "expectedBehavior": [
        "Tracks review_count in state",
        "interrupt() on each review cycle",
        "Routes back to generation if rejected",
        "Proceeds to next step when approved"
      ]
    },
    {
      "id": "streaming-progress",
      "rule": "streaming-custom-events",
      "query": "Stream progress updates showing percentage complete",
      "expectedBehavior": [
        "Uses get_stream_writer() in node",
        "Writes custom event with progress data",
        "Client receives via stream_mode='custom'",
        "Events have type and payload"
      ]
    },
    {
      "id": "streaming-tokens",
      "rule": "streaming-tokens",
      "query": "Stream LLM tokens to the client in real-time",
      "expectedBehavior": [
        "Uses stream_mode='messages'",
        "LLM node uses streaming API",
        "Tokens appear as they're generated",
        "Final message assembled from chunks"
      ]
    },
    {
      "id": "streaming-multi",
      "rule": "streaming-modes",
      "query": "Get both state updates and custom events in single stream",
      "expectedBehavior": [
        "Passes list to stream_mode=['updates', 'custom']",
        "Filters events by mode in client",
        "Updates show state changes",
        "Custom shows progress events"
      ]
    },
    {
      "id": "subgraphs-invoke",
      "rule": "subgraphs-invoke",
      "query": "Call a subgraph with different state schema from parent",
      "expectedBehavior": [
        "Compiles subgraph separately",
        "Parent node transforms state before invoke",
        "Subgraph uses its own state schema",
        "Parent transforms subgraph output back"
      ]
    },
    {
      "id": "subgraphs-add-node",
      "rule": "subgraphs-add-as-node",
      "query": "Embed a subgraph that shares state with parent",
      "expectedBehavior": [
        "Subgraph uses same state schema as parent",
        "add_node accepts compiled subgraph directly",
        "No state transformation needed",
        "Subgraph reads/writes parent state"
      ]
    },
    {
      "id": "subgraphs-checkpoint",
      "rule": "subgraphs-state-mapping",
      "query": "Set up checkpointing that works across subgraphs",
      "expectedBehavior": [
        "Only parent graph has checkpointer",
        "Uses checkpointer=False for subgraphs",
        "Subgraph state included in parent checkpoints",
        "Resume restores subgraph state"
      ]
    },
    {
      "id": "functional-basic",
      "rule": "functional-entrypoint",
      "query": "Create a simple workflow using the Functional API",
      "expectedBehavior": [
        "Imports entrypoint and task from langgraph.func",
        "Decorates worker functions with @task",
        "Decorates main function with @entrypoint",
        "Calls task().result() to get values"
      ]
    },
    {
      "id": "functional-parallel",
      "rule": "functional-task",
      "query": "Run multiple tasks in parallel using Functional API",
      "expectedBehavior": [
        "Calls multiple @task functions without .result()",
        "Tasks return futures that run in parallel",
        "Calls .result() on all futures to wait",
        "Results collected after parallel execution"
      ]
    },
    {
      "id": "functional-injectable",
      "rule": "functional-task",
      "query": "Access previous state and store in a @task function",
      "expectedBehavior": [
        "Uses InjectedState type annotation",
        "Accesses previous checkpoint data",
        "Uses InjectedStore for persistence",
        "Parameters injected automatically by runtime"
      ]
    }
  ]
}
