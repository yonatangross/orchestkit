{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/analytics-buffer.ts", "../src/lib/paths.ts", "../src/lib/session-id-generator.ts", "../src/lib/git.ts", "../src/lifecycle/analytics-consent-check.ts", "../src/lifecycle/pattern-sync-pull.ts", "../src/lifecycle/pattern-sync-push.ts", "../src/lifecycle/pr-status-enricher.ts", "../src/lifecycle/session-cleanup.ts", "../src/lib/agent-teams.ts", "../src/lib/analytics.ts", "../src/lib/metrics.ts", "../src/lifecycle/session-context-loader.ts", "../src/lifecycle/session-env-setup.ts", "../src/lib/session-tracker.ts", "../src/lib/user-identity.ts", "../src/lifecycle/session-tracking.ts", "../src/lifecycle/session-metrics-summary.ts", "../src/lifecycle/dependency-version-check.ts", "../src/lib/memory-metrics.ts", "../src/lifecycle/memory-metrics-collector.ts", "../src/lifecycle/stale-team-cleanup.ts", "../src/lifecycle/type-error-indexer.ts", "../src/lifecycle/unified-dispatcher.ts", "../src/lifecycle/pre-compact-saver.ts", "../src/lifecycle/prefill-guard.ts", "../src/lifecycle/mcp-health-check.ts", "../src/lib/event-logger.ts", "../src/teammate-idle/progress-reporter.ts", "../src/teammate-idle/team-synthesis-trigger.ts", "../src/teammate-idle/team-quality-gate.ts", "../src/teammate-idle/unified-dispatcher.ts", "../src/task-completed/completion-tracker.ts", "../src/worktree/worktree-lifecycle-logger.ts", "../src/config-change/settings-reload.ts", "../src/entries/lifecycle.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PostToolUseFailure'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification'\n  | 'PreCompact'\n  | 'TeammateIdle'\n  | 'TaskCompleted'\n  | 'WorktreeCreate'\n  | 'WorktreeRemove'\n  | 'ConfigChange';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** Whether a stop hook is currently active (prevents re-entry) */\n  stop_hook_active?: boolean;\n  /** Permission mode (CC 2.1.25: dontAsk mode makes quality gates warn-only) */\n  permissionMode?: 'default' | 'acceptEdits' | 'dontAsk';\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // TeammateIdle specific fields (CC 2.1.33)\n  /** Teammate agent ID */\n  teammate_id?: string;\n  /** Teammate agent type */\n  teammate_type?: string;\n  /** How long the teammate has been idle (ms) */\n  idle_duration_ms?: number;\n\n  // TaskCompleted specific fields (CC 2.1.33)\n  /** Completed task ID */\n  task_id?: string;\n  /** Task subject */\n  task_subject?: string;\n  /** Task result status */\n  task_status?: string;\n  /** Token count consumed by the task (CC 2.1.30) */\n  token_count?: number;\n  /** Number of tool invocations in the task (CC 2.1.30) */\n  tool_uses?: number;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n\n  // Stop/SubagentStop specific fields (CC 2.1.47)\n  /** The final assistant message text (Stop and SubagentStop, CC 2.1.47+) */\n  last_assistant_message?: string;\n\n  // Workspace/statusline fields (CC 2.1.47)\n  /** Directories added via /add-dir, from statusline workspace section (CC 2.1.47+) */\n  added_dirs?: string[];\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PostToolUseFailure' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n  /** Modified tool input (CC 2.1.25: canonical way to modify tool inputs) */\n  updatedInput?: Record<string, unknown>;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\nimport {\n  getLogDir as getLogDirFromPaths,\n  getProjectDir as getProjectDirFromPaths,\n  getPluginRoot as getPluginRootFromPaths,\n} from './paths.js';\nimport { getOrGenerateSessionId } from './session-id-generator.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// Re-export from paths.ts for cross-platform compatibility\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getLogDir(): string {\n  return getLogDirFromPaths();\n}\n\n/**\n * Get the project directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getProjectDir(): string {\n  return getProjectDirFromPaths();\n}\n\n/**\n * Get the plugin root directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getPluginRoot(): string {\n  return getPluginRootFromPaths();\n}\n\n/**\n * Get the environment file path (CC 2.1.25: CLAUDE_ENV_FILE support)\n * Falls back to .instance_env for backward compatibility\n */\nexport function getEnvFile(): string {\n  if (process.env.CLAUDE_ENV_FILE) {\n    return process.env.CLAUDE_ENV_FILE;\n  }\n  // Fallback to legacy .instance_env\n  const pluginRoot = getPluginRoot();\n  return `${pluginRoot}/.claude/.instance_env`;\n}\n\n/**\n * Get the session ID\n *\n * Resolution order:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime - preferred)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate smart session ID: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n *\n * Example smart ID: \"orchestkit-main-0130-1745-a3f2\"\n *\n * The old fallback format \"fallback-{pid}-{timestamp}\" was confusing and unhelpful.\n * Smart IDs are human-readable, showing project, branch, and time context.\n */\nexport function getSessionId(): string {\n  return getOrGenerateSessionId();\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Normalize line endings from CRLF to LF for cross-platform compatibility.\n * Windows uses \\r\\n (CRLF) while Unix uses \\n (LF).\n * This is critical for parsing YAML frontmatter where we match '---' exactly.\n */\nexport function normalizeLineEndings(content: string): string {\n  return content.replace(/\\r\\n/g, '\\n');\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with user notification + Claude context (CC 2.1.9+)\n * Issue #278: Dual-channel output for three-tier UX\n *\n * @param userMessage - Brief message shown to user via systemMessage (optional)\n * @param claudeContext - Full context for Claude via additionalContext (optional)\n * @returns HookResult with appropriate channels set\n *\n * Usage:\n * - Both set: User sees notification, Claude gets context\n * - Only claudeContext: Silent injection (Claude-only)\n * - Only userMessage: User notification without context\n */\nexport function outputWithNotification(\n  userMessage: string | undefined,\n  claudeContext: string | undefined\n): HookResult {\n  const result: HookResult = {\n    continue: true,\n    suppressOutput: true,\n  };\n\n  if (userMessage) {\n    result.systemMessage = userMessage;\n  }\n\n  if (claudeContext) {\n    result.hookSpecificOutput = {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: claudeContext,\n    };\n  }\n\n  return result;\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message via JSON stdout \u2014 visible to both user and Claude (CC 2.1.7+).\n * Use this when Claude needs to see and act on the warning (e.g., cost advice, quality gates).\n * For user-only warnings where Claude should NOT see the message, use outputStderrWarning.\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output warning via stderr + exit(2) \u2014 visible to user only, Claude does NOT see it (CC 2.1.39).\n * Use this for informational warnings that should not influence Claude's behavior\n * (e.g., deprecation notices, non-actionable advisories).\n *\n * IMPORTANT: This function calls process.exit(2) and never returns.\n * Do NOT use inside unified dispatchers \u2014 it will crash the dispatcher process.\n * Only use in standalone hook entry points.\n */\nexport function outputStderrWarning(message: string): never {\n  process.stderr.write(`\\u26a0 ${message}\\n`);\n  process.exit(2);\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with updatedInput - modifies tool input before execution (CC 2.1.25)\n * Canonical way to modify tool inputs from PreToolUse hooks\n */\nexport function outputWithUpdatedInput(updatedInput: Record<string, unknown>): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      updatedInput,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    bufferWrite(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    bufferWrite(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction (shared by all sync dispatchers)\n// -----------------------------------------------------------------------------\n\n/**\n * Extract additionalContext from a hook result.\n * Handles both the correct hookSpecificOutput.additionalContext format\n * and the legacy bare systemMessage format.\n *\n * Issue #682: Deduplicated from 5 dispatchers into shared utility.\n */\nexport function extractContext(result: HookResult): string | null {\n  // Standard format: hookSpecificOutput.additionalContext\n  if (result.hookSpecificOutput?.additionalContext) {\n    return result.hookSpecificOutput.additionalContext as string;\n  }\n\n  // Legacy format: bare systemMessage (antipattern-detector bug)\n  if (result.systemMessage && typeof result.systemMessage === 'string') {\n    return result.systemMessage;\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker?.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// ReDoS-Safe String Matching\n// -----------------------------------------------------------------------------\n\n/**\n * Check if any single line contains all specified substrings (ReDoS-safe O(n)).\n * Use instead of polynomial regexes like /A.*B.*C/.test(content).\n */\nexport function lineContainsAll(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => terms.every(t => line.includes(t)));\n}\n\n/**\n * Check if any single line contains all specified substrings (case-insensitive, ReDoS-safe O(n)).\n */\nexport function lineContainsAllCI(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => {\n    const lower = line.toLowerCase();\n    return terms.every(t => lower.includes(t.toLowerCase()));\n  });\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Analytics Write Buffer \u2014 Batches appendFileSync calls and flushes on exit\n *\n * Reduces per-hook I/O overhead by buffering analytics/metrics/log writes\n * and flushing them in a single batch per file path. Registered process\n * handlers ensure data is written before the process terminates.\n *\n * Issue #688: Buffer analytics writes and flush on process exit\n */\n\nimport { appendFileSync, mkdirSync } from 'node:fs';\nimport { dirname } from 'node:path';\n\ninterface BufferEntry {\n  filePath: string;\n  content: string;\n}\n\nconst buffer: BufferEntry[] = [];\nlet flushing = false;\nlet handlersRegistered = false;\n\n/**\n * Queue an analytics/log write for batched flushing.\n * Call this instead of appendFileSync for non-essential writes.\n */\nexport function bufferWrite(filePath: string, content: string): void {\n  buffer.push({ filePath, content });\n  ensureHandlers();\n}\n\n/**\n * Flush all buffered writes to disk immediately.\n * Groups entries by file path to minimize syscalls.\n */\nexport function flush(): void {\n  if (flushing || buffer.length === 0) return;\n  flushing = true;\n\n  // Group by filePath to write each file once\n  const grouped = new Map<string, string[]>();\n  for (const entry of buffer) {\n    const arr = grouped.get(entry.filePath);\n    if (arr) {\n      arr.push(entry.content);\n    } else {\n      grouped.set(entry.filePath, [entry.content]);\n    }\n  }\n\n  for (const [path, contents] of grouped) {\n    try {\n      mkdirSync(dirname(path), { recursive: true });\n      appendFileSync(path, contents.join(''));\n    } catch {\n      // Ignore flush errors \u2014 never block process exit\n    }\n  }\n\n  buffer.length = 0;\n  flushing = false;\n}\n\n/** Number of entries currently buffered (for testing) */\nexport function pendingCount(): number {\n  return buffer.length;\n}\n\n/** Clear buffer without writing (for testing) */\nexport function _resetForTesting(): void {\n  buffer.length = 0;\n  flushing = false;\n}\n\nfunction ensureHandlers(): void {\n  if (handlersRegistered) return;\n  handlersRegistered = true;\n\n  process.on('exit', flush);\n  process.on('SIGTERM', () => { flush(); process.exit(0); });\n  process.on('SIGINT', () => { flush(); process.exit(0); });\n}\n", "/**\n * Cross-platform path utilities for TypeScript hooks\n *\n * Provides consistent path handling across Windows, macOS, and Linux.\n * All path construction uses path.join() for correct separators.\n * All temp directories use os.tmpdir() for platform awareness.\n */\n\nimport os from 'node:os';\nimport path from 'node:path';\n\n/**\n * Get the user's home directory (cross-platform)\n * Prefers explicit env vars, falls back to os.homedir()\n */\nexport function getHomeDir(): string {\n  return process.env.HOME || process.env.USERPROFILE || os.homedir();\n}\n\n/**\n * Get the system temp directory (cross-platform)\n * Returns /tmp on Unix, C:\\Users\\X\\AppData\\Local\\Temp on Windows\n */\nexport function getTempDir(): string {\n  return os.tmpdir();\n}\n\n/**\n * Get the project directory from environment\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory from environment\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the log directory path (cross-platform)\n * Uses path.join() for correct separators on all platforms\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return path.join(getHomeDir(), '.claude', 'logs', 'ork');\n  }\n  return path.join(getProjectDir(), '.claude', 'logs');\n}\n\n/**\n * Get the memory directory path (cross-platform)\n */\nexport function getMemoryDir(): string {\n  return path.join(getProjectDir(), '.claude', 'memory');\n}\n\n/**\n * Get the coordination directory path (cross-platform)\n */\nexport function getCoordinationDir(): string {\n  return path.join(getProjectDir(), '.claude', 'coordination');\n}\n\n/**\n * Get the session metrics file path (cross-platform)\n * Uses CLAUDE_METRICS_FILE env var if set (for test isolation), otherwise temp dir.\n */\nexport function getMetricsFile(): string {\n  return process.env.CLAUDE_METRICS_FILE || path.join(getTempDir(), 'claude-session-metrics.json');\n}\n\n/**\n * Get the session error metrics file path (cross-platform)\n */\nexport function getSessionErrorsFile(): string {\n  return process.env.CLAUDE_SESSION_ERRORS_FILE || path.join(getTempDir(), 'claude-session-errors.json');\n}\n\n/**\n * Get the session temp directory for a given session ID (cross-platform)\n */\nexport function getSessionTempDir(sessionId: string): string {\n  return path.join(getTempDir(), `claude-session-${sessionId}`);\n}\n\n/**\n * Get the active todos file path (cross-platform)\n */\nexport function getActiveTodosFile(): string {\n  return path.join(getTempDir(), 'claude-active-todos.json');\n}\n\n/**\n * Get the context tracking state file path for a session (cross-platform)\n */\nexport function getContextTrackingFile(sessionId: string): string {\n  return path.join(getTempDir(), `claude-context-tracking-${sessionId}.json`);\n}\n\n/**\n * Get the read count temp file path (cross-platform)\n */\nexport function getReadCountFile(): string {\n  return path.join(getTempDir(), 'claude-read-count');\n}\n\n/**\n * Normalize a path for consistent comparison\n * Converts backslashes to forward slashes and removes trailing slashes\n */\nexport function normalizePath(p: string): string {\n  return path.normalize(p).replace(/\\\\/g, '/').replace(/\\/$/, '');\n}\n\n/**\n * Check if a path is absolute\n */\nexport function isAbsolutePath(p: string): boolean {\n  return path.isAbsolute(p);\n}\n\n/**\n * Join path segments (cross-platform)\n * Re-export for convenience\n */\nexport const joinPath = path.join;\n\n/**\n * Get path separator for current platform\n */\nexport const pathSeparator = path.sep;\n", "/**\n * Smart Session ID Generator\n * Generates human-readable session IDs when CLAUDE_SESSION_ID is not available.\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * Benefits:\n * - Human-readable at a glance\n * - Contains project context\n * - Contains branch info\n * - Chronologically sortable (date-time)\n * - Short unique suffix prevents collisions\n * - Valid file path characters only\n */\n\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, basename } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Maximum length for project name component */\nconst MAX_PROJECT_LENGTH = 20;\n\n/** Maximum length for branch name component */\nconst MAX_BRANCH_LENGTH = 15;\n\n/** Characters allowed in session ID (safe for file paths) */\nconst SAFE_CHARS = /[^a-z0-9-]/g;\n\n// =============================================================================\n// SESSION ID GENERATION\n// =============================================================================\n\n/**\n * Get project name from directory path\n * Sanitizes to lowercase alphanumeric with dashes\n */\nexport function getProjectName(projectDir?: string): string {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const name = basename(dir);\n  return sanitizeName(name, MAX_PROJECT_LENGTH);\n}\n\n/**\n * Get git branch name (cached for performance)\n * Returns 'nobranch' if git is not available or not in a repo\n */\nexport function getGitBranchForSession(projectDir?: string): string {\n  // Check cache first\n  if (process.env.ORCHESTKIT_SESSION_BRANCH) {\n    return process.env.ORCHESTKIT_SESSION_BRANCH;\n  }\n\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n\n    const sanitized = sanitizeName(branch || 'detached', MAX_BRANCH_LENGTH);\n    process.env.ORCHESTKIT_SESSION_BRANCH = sanitized;\n    return sanitized;\n  } catch {\n    return 'nobranch';\n  }\n}\n\n/**\n * Format current date as MMDD\n */\nexport function formatDateComponent(date?: Date): string {\n  const d = date || new Date();\n  const month = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  return `${month}${day}`;\n}\n\n/**\n * Format current time as HHMM (24-hour)\n */\nexport function formatTimeComponent(date?: Date): string {\n  const d = date || new Date();\n  const hours = String(d.getHours()).padStart(2, '0');\n  const minutes = String(d.getMinutes()).padStart(2, '0');\n  return `${hours}${minutes}`;\n}\n\n/**\n * Generate short hash for uniqueness (4 hex chars)\n * Uses PID + timestamp + random for entropy\n */\nexport function generateShortHash(): string {\n  const entropy = `${process.pid}-${Date.now()}-${Math.random()}`;\n  return createHash('sha256')\n    .update(entropy)\n    .digest('hex')\n    .slice(0, 4);\n}\n\n/**\n * Sanitize a name for use in session ID\n * - Lowercase\n * - Replace non-alphanumeric with dashes\n * - Collapse multiple dashes\n * - Trim dashes from ends\n * - Truncate to max length\n */\nexport function sanitizeName(name: string, maxLength: number): string {\n  return name\n    .toLowerCase()\n    .replace(SAFE_CHARS, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '')\n    .slice(0, maxLength);\n}\n\n/**\n * Generate a smart session ID\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * @param projectDir - Optional project directory (defaults to env or cwd)\n * @param date - Optional date for testing (defaults to now)\n */\nexport function generateSmartSessionId(projectDir?: string, date?: Date): string {\n  const project = getProjectName(projectDir);\n  const branch = getGitBranchForSession(projectDir);\n  const dateStr = formatDateComponent(date);\n  const timeStr = formatTimeComponent(date);\n  const hash = generateShortHash();\n\n  return `${project}-${branch}-${dateStr}-${timeStr}-${hash}`;\n}\n\n// =============================================================================\n// SESSION ID CACHING\n// =============================================================================\n\n/**\n * Get cached session ID from .instance directory\n * Returns undefined if not cached\n */\nexport function getCachedSessionId(projectDir?: string): string | undefined {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const cachePath = join(dir, '.instance', 'session-id.json');\n\n  if (!existsSync(cachePath)) {\n    return undefined;\n  }\n\n  try {\n    const data = JSON.parse(readFileSync(cachePath, 'utf8'));\n    // Validate the cached ID hasn't expired (24 hours)\n    if (data.session_id && data.created_at) {\n      const age = Date.now() - new Date(data.created_at).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n      if (age < maxAge) {\n        return data.session_id;\n      }\n    }\n  } catch {\n    // Ignore read/parse errors\n  }\n\n  return undefined;\n}\n\n/**\n * Cache session ID to .instance directory\n */\nexport function cacheSessionId(sessionId: string, projectDir?: string): void {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const instanceDir = join(dir, '.instance');\n  const cachePath = join(instanceDir, 'session-id.json');\n\n  try {\n    if (!existsSync(instanceDir)) {\n      mkdirSync(instanceDir, { recursive: true });\n    }\n\n    writeFileSync(cachePath, JSON.stringify({\n      session_id: sessionId,\n      created_at: new Date().toISOString(),\n    }, null, 2));\n  } catch {\n    // Ignore write errors - caching is optional\n  }\n}\n\n/**\n * Get or generate session ID with caching\n *\n * Priority:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate new smart session ID (and cache it)\n */\nexport function getOrGenerateSessionId(projectDir?: string): string {\n  // 1. Try CLAUDE_SESSION_ID first (preferred)\n  if (process.env.CLAUDE_SESSION_ID) {\n    return process.env.CLAUDE_SESSION_ID;\n  }\n\n  // 2. Try cached session ID\n  const cached = getCachedSessionId(projectDir);\n  if (cached) {\n    return cached;\n  }\n\n  // 3. Generate new smart session ID\n  const newId = generateSmartSessionId(projectDir);\n  cacheSessionId(newId, projectDir);\n  return newId;\n}\n", "/**\n * Git utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh git functions\n */\n\nimport { execSync } from 'node:child_process';\nimport { getProjectDir } from './common.js';\n\n/**\n * Get the current git branch\n */\nexport function getCurrentBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Check if on a protected branch (dev, main, master)\n */\nexport function isProtectedBranch(branch?: string): boolean {\n  const currentBranch = branch || getCurrentBranch();\n  return ['dev', 'main', 'master'].includes(currentBranch);\n}\n\n/**\n * Get the repository root directory\n */\nexport function getRepoRoot(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return dir;\n  }\n}\n\n/**\n * Check if path is inside a git repository\n */\nexport function isGitRepo(projectDir?: string): boolean {\n  const dir = projectDir || getProjectDir();\n  try {\n    execSync('git rev-parse --git-dir', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get git status (short format)\n */\nexport function getGitStatus(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git status --short', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Check if there are uncommitted changes\n */\nexport function hasUncommittedChanges(projectDir?: string): boolean {\n  return getGitStatus(projectDir).length > 0;\n}\n\n/**\n * Get the default branch (main or master)\n */\nexport function getDefaultBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    // Check if 'main' exists\n    execSync('git rev-parse --verify main', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return 'main';\n  } catch {\n    try {\n      // Check if 'master' exists\n      execSync('git rev-parse --verify master', {\n        cwd: dir,\n        encoding: 'utf8',\n        timeout: 5000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n      return 'master';\n    } catch {\n      return 'main'; // Default to main\n    }\n  }\n}\n\n/**\n * Extract issue number from branch name\n * Supports patterns like: issue/123-description, feature/123, fix-123\n */\nexport function extractIssueNumber(branch: string): number | null {\n  // Match common patterns\n  const patterns = [\n    /issue\\/(\\d+)/i,\n    /feature\\/(\\d+)/i,\n    /fix\\/(\\d+)/i,\n    /bug\\/(\\d+)/i,\n    /feat\\/(\\d+)/i,\n    /^(\\d+)-/,\n    /-(\\d+)$/,\n    /#(\\d+)/,\n  ];\n\n  for (const pattern of patterns) {\n    const match = branch.match(pattern);\n    if (match) {\n      return parseInt(match[1], 10);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get list of staged files (ready to be committed)\n * Returns array of file paths\n */\nexport function getStagedFiles(projectDir?: string): string[] {\n  const dir = projectDir || getProjectDir();\n  try {\n    const output = execSync('git diff --cached --name-only', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    return output ? output.split('\\n').filter((f) => f.trim()) : [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Analyze staged files for atomicity\n * Returns an object describing the change characteristics\n */\nexport function analyzeStagedChanges(projectDir?: string): {\n  files: string[];\n  directories: Set<string>;\n  extensions: Set<string>;\n  hasTests: boolean;\n  hasConfig: boolean;\n  hasDocs: boolean;\n  hasSource: boolean;\n} {\n  const files = getStagedFiles(projectDir);\n  const directories = new Set<string>();\n  const extensions = new Set<string>();\n  let hasTests = false;\n  let hasConfig = false;\n  let hasDocs = false;\n  let hasSource = false;\n\n  for (const file of files) {\n    // Extract top-level directory\n    const parts = file.split('/');\n    if (parts.length > 1) {\n      directories.add(parts[0]);\n      // Also track second-level for deeper analysis\n      if (parts.length > 2) {\n        directories.add(`${parts[0]}/${parts[1]}`);\n      }\n    }\n\n    // Extension\n    const ext = file.split('.').pop() || '';\n    extensions.add(ext);\n\n    // Classify file type\n    if (/\\.(test|spec)\\.\\w+$/.test(file) || /^tests?\\//.test(file) || /__tests__\\//.test(file)) {\n      hasTests = true;\n    } else if (/\\.(md|mdx|txt|rst)$/.test(file) || /^docs?\\//.test(file) || file === 'README.md') {\n      hasDocs = true;\n    } else if (\n      /\\.(json|ya?ml|toml|ini|cfg|env)$/.test(file) ||\n      /config/i.test(file) ||\n      file === 'package.json' ||\n      file === 'tsconfig.json'\n    ) {\n      hasConfig = true;\n    } else {\n      hasSource = true;\n    }\n  }\n\n  return { files, directories, extensions, hasTests, hasConfig, hasDocs, hasSource };\n}\n\n/**\n * Validate branch name format\n * Returns error message if invalid, null if valid\n */\nexport function validateBranchName(branch: string): string | null {\n  // Skip validation for protected branches\n  if (isProtectedBranch(branch)) {\n    return null;\n  }\n\n  // Valid prefixes\n  const validPrefixes = [\n    'issue/',\n    'feature/',\n    'fix/',\n    'bug/',\n    'feat/',\n    'chore/',\n    'docs/',\n    'refactor/',\n    'test/',\n    'ci/',\n    'perf/',\n    'style/',\n    'release/',\n    'hotfix/',\n  ];\n\n  const hasValidPrefix = validPrefixes.some((prefix) => branch.startsWith(prefix));\n  if (!hasValidPrefix) {\n    return `Branch name should start with a valid prefix: ${validPrefixes.join(', ')}`;\n  }\n\n  // Check for issue number in issue/ branches\n  if (branch.startsWith('issue/') && !extractIssueNumber(branch)) {\n    return 'issue/ branches should include an issue number (e.g., issue/123-description)';\n  }\n\n  return null;\n}\n", "/**\n * Analytics Consent Check - Check if user needs to be prompted for analytics consent\n * Part of OrchestKit Claude Plugin (#59)\n *\n * This hook runs on session start to check if user has been asked about analytics.\n * It outputs a gentle reminder or first-time prompt if appropriate.\n *\n * CC 2.1.7 Compliant: uses hookSpecificOutput.additionalContext for context injection\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\n\ninterface ConsentLog {\n  events: Array<{\n    action: string;\n    timestamp: string;\n  }>;\n}\n\ninterface ConsentStatus {\n  consented: boolean;\n  asked: boolean;\n}\n\n/**\n * Read consent status from consent manager config\n */\nfunction getConsentStatus(projectDir: string): ConsentStatus {\n  const consentFile = `${projectDir}/.claude/feedback/consent-status.json`;\n\n  if (!existsSync(consentFile)) {\n    return { consented: false, asked: false };\n  }\n\n  try {\n    const status = JSON.parse(readFileSync(consentFile, 'utf-8'));\n    return {\n      consented: status.consented === true,\n      asked: status.asked === true,\n    };\n  } catch {\n    return { consented: false, asked: false };\n  }\n}\n\n/**\n * Get the last consent event from the log\n */\nfunction getLastConsentEvent(projectDir: string): { action: string; timestamp: string } | null {\n  const consentLog = `${projectDir}/.claude/feedback/consent-log.json`;\n\n  if (!existsSync(consentLog)) {\n    return null;\n  }\n\n  try {\n    const log: ConsentLog = JSON.parse(readFileSync(consentLog, 'utf-8'));\n    if (log.events && log.events.length > 0) {\n      return log.events[log.events.length - 1];\n    }\n  } catch {\n    // Ignore parse errors\n  }\n\n  return null;\n}\n\n/**\n * Check if 30 days have passed since the last decline\n */\nfunction shouldShowReminder(lastTimestamp: string): boolean {\n  try {\n    const lastDate = new Date(lastTimestamp);\n    const now = new Date();\n    const daysSince = Math.floor((now.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24));\n    return daysSince >= 30;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Analytics consent check hook\n */\nexport function analyticsConsentCheck(input: HookInput): HookResult {\n  const projectDir = input.project_dir || getProjectDir();\n  const status = getConsentStatus(projectDir);\n\n  // Already consented - nothing to do\n  if (status.consented) {\n    logHook('analytics-consent-check', 'User has consented to analytics');\n    return outputSilentSuccess();\n  }\n\n  // Already asked and declined - check if we should show reminder\n  if (status.asked) {\n    const lastEvent = getLastConsentEvent(projectDir);\n\n    if (lastEvent && (lastEvent.action === 'declined' || lastEvent.action === 'revoked')) {\n      if (shouldShowReminder(lastEvent.timestamp)) {\n        // Show gentle reminder (not blocking)\n        logHook('analytics-consent-check', 'Showing 30-day reminder');\n        return {\n          continue: true,\n          systemMessage:\n            'Reminder: Anonymous analytics help improve OrchestKit. Enable with /ork:feedback opt-in',\n        };\n      }\n    }\n\n    // Don't show anything if recently asked\n    logHook('analytics-consent-check', 'User recently declined, not prompting');\n    return outputSilentSuccess();\n  }\n\n  // First time - show a brief notice (not the full prompt, to avoid blocking)\n  logHook('analytics-consent-check', 'First time user, showing brief notice');\n  return {\n    continue: true,\n    systemMessage:\n      'OrchestKit collects local usage metrics. Share anonymously with /ork:feedback opt-in',\n  };\n}\n", "/**\n * Pattern Sync Pull - SessionStart Hook\n * CC 2.1.7 Compliant: silent on success with suppressOutput\n * Pulls global patterns into project on session start\n *\n * Part of Cross-Project Patterns (#48)\n * Optimized with timeout and file size checks to prevent startup hangs\n */\n\nimport { existsSync, readFileSync, writeFileSync, statSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\nimport { getHomeDir } from '../lib/paths.js';\n\ninterface PatternFile {\n  version?: string;\n  patterns?: unknown[];\n  sync_enabled?: boolean;\n}\n\nconst MAX_FILE_SIZE_BYTES = 1 * 1024 * 1024; // 1MB\n\n/**\n * Check if slow hooks should be skipped\n */\nfunction shouldSkipSlowHooks(): boolean {\n  return process.env.ORCHESTKIT_SKIP_SLOW_HOOKS === '1';\n}\n\n/**\n * Check if sync is enabled\n */\nfunction isSyncEnabled(projectDir: string): boolean {\n  const configFile = `${projectDir}/.claude/feedback/sync-config.json`;\n\n  if (!existsSync(configFile)) {\n    return true; // Default to enabled\n  }\n\n  try {\n    const config = JSON.parse(readFileSync(configFile, 'utf-8'));\n    return config.sync_enabled !== false;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Check if file size is within limits\n */\nfunction checkFileSize(filePath: string): boolean {\n  if (!existsSync(filePath)) {\n    return true; // File doesn't exist, that's fine\n  }\n\n  try {\n    const stats = statSync(filePath);\n    if (stats.size > MAX_FILE_SIZE_BYTES) {\n      logHook('pattern-sync-pull', `WARN: Skipping - file too large: ${filePath} (${stats.size} bytes)`);\n      return false;\n    }\n    return true;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Pull global patterns into project\n */\nfunction pullGlobalPatterns(projectDir: string): void {\n  const home = getHomeDir();\n  const globalPatternsFile = `${home}/.claude/global-patterns.json`;\n  const projectPatternsFile = `${projectDir}/.claude/feedback/learned-patterns.json`;\n\n  if (!existsSync(globalPatternsFile)) {\n    logHook('pattern-sync-pull', 'No global patterns file found');\n    return;\n  }\n\n  try {\n    const globalPatterns: PatternFile = JSON.parse(readFileSync(globalPatternsFile, 'utf-8'));\n    const globalList = globalPatterns.patterns || [];\n\n    if (globalList.length === 0) {\n      logHook('pattern-sync-pull', 'No global patterns to pull');\n      return;\n    }\n\n    // Load existing project patterns\n    let projectPatterns: PatternFile = { version: '1.0', patterns: [] };\n    if (existsSync(projectPatternsFile)) {\n      try {\n        projectPatterns = JSON.parse(readFileSync(projectPatternsFile, 'utf-8'));\n      } catch {\n        // Use default if parse fails\n      }\n    }\n\n    const projectList = projectPatterns.patterns || [];\n\n    // Merge patterns (avoid duplicates by text)\n    const existingTexts = new Set((projectList as Array<{ text?: string }>).map((p) => p.text));\n    const newPatterns = (globalList as Array<{ text?: string }>).filter((p) => !existingTexts.has(p.text));\n\n    if (newPatterns.length === 0) {\n      logHook('pattern-sync-pull', 'All global patterns already in project');\n      return;\n    }\n\n    // Add new patterns\n    const mergedPatterns = [...projectList, ...newPatterns];\n    projectPatterns.patterns = mergedPatterns;\n\n    // Ensure directory exists\n    mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n\n    // Write updated patterns\n    writeFileSync(projectPatternsFile, JSON.stringify(projectPatterns, null, 2));\n    logHook('pattern-sync-pull', `Pulled ${newPatterns.length} new patterns from global`);\n  } catch (err) {\n    logHook('pattern-sync-pull', `Failed to pull global patterns: ${err}`);\n  }\n}\n\n/**\n * Pattern sync pull hook\n */\nexport function patternSyncPull(input: HookInput): HookResult {\n  // Bypass if slow hooks are disabled\n  if (shouldSkipSlowHooks()) {\n    logHook('pattern-sync-pull', 'Skipping pattern sync (ORCHESTKIT_SKIP_SLOW_HOOKS=1)');\n    return outputSilentSuccess();\n  }\n\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Check if sync is enabled\n  if (!isSyncEnabled(projectDir)) {\n    logHook('pattern-sync-pull', 'Global sync disabled, skipping pull');\n    return outputSilentSuccess();\n  }\n\n  // Check file sizes (use getHomeDir for cross-platform compatibility)\n  const globalPatternsFile = `${getHomeDir()}/.claude/global-patterns.json`;\n  const projectPatternsFile = `${projectDir}/.claude/feedback/learned-patterns.json`;\n\n  if (!checkFileSize(globalPatternsFile) || !checkFileSize(projectPatternsFile)) {\n    logHook('pattern-sync-pull', 'Skipping pattern sync due to large files');\n    return outputSilentSuccess();\n  }\n\n  // Pull global patterns\n  logHook('pattern-sync-pull', 'Pulling global patterns...');\n  pullGlobalPatterns(projectDir);\n  logHook('pattern-sync-pull', 'Global patterns pulled successfully');\n\n  return outputSilentSuccess();\n}\n", "/**\n * Pattern Sync Push - SessionEnd Hook\n * CC 2.1.7 Compliant: silent on success with suppressOutput\n * Pushes project patterns to global on session end\n *\n * Part of Cross-Project Patterns (#48)\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\nimport { getHomeDir } from '../lib/paths.js';\n\ninterface PatternFile {\n  version?: string;\n  patterns?: unknown[];\n  sync_enabled?: boolean;\n  updated?: string;\n}\n\n/**\n * Check if sync is enabled\n */\nfunction isSyncEnabled(projectDir: string): boolean {\n  const configFile = `${projectDir}/.claude/feedback/sync-config.json`;\n\n  if (!existsSync(configFile)) {\n    return true; // Default to enabled\n  }\n\n  try {\n    const config = JSON.parse(readFileSync(configFile, 'utf-8'));\n    return config.sync_enabled !== false;\n  } catch {\n    return true;\n  }\n}\n\n/**\n * Push project patterns to global\n */\nfunction pushProjectPatterns(projectDir: string): void {\n  const projectPatternsFile = `${projectDir}/.claude/feedback/learned-patterns.json`;\n  const home = getHomeDir();\n  const globalPatternsFile = `${home}/.claude/global-patterns.json`;\n\n  if (!existsSync(projectPatternsFile)) {\n    logHook('pattern-sync-push', 'No project patterns file found');\n    return;\n  }\n\n  try {\n    const projectPatterns: PatternFile = JSON.parse(readFileSync(projectPatternsFile, 'utf-8'));\n    const projectList = projectPatterns.patterns || [];\n\n    if (projectList.length === 0) {\n      logHook('pattern-sync-push', 'No project patterns to push');\n      return;\n    }\n\n    // Load existing global patterns\n    let globalPatterns: PatternFile = { version: '1.0', patterns: [], updated: '' };\n    if (existsSync(globalPatternsFile)) {\n      try {\n        globalPatterns = JSON.parse(readFileSync(globalPatternsFile, 'utf-8'));\n      } catch {\n        // Use default if parse fails\n      }\n    }\n\n    const globalList = globalPatterns.patterns || [];\n\n    // Merge patterns (avoid duplicates by text)\n    const existingTexts = new Set((globalList as Array<{ text?: string }>).map((p) => p.text));\n    const newPatterns = (projectList as Array<{ text?: string }>).filter((p) => !existingTexts.has(p.text));\n\n    if (newPatterns.length === 0) {\n      logHook('pattern-sync-push', 'All project patterns already in global');\n      return;\n    }\n\n    // Add new patterns\n    const mergedPatterns = [...globalList, ...newPatterns];\n    globalPatterns.patterns = mergedPatterns;\n    globalPatterns.updated = new Date().toISOString();\n\n    // Ensure directory exists\n    mkdirSync(`${home}/.claude`, { recursive: true });\n\n    // Write updated patterns\n    writeFileSync(globalPatternsFile, JSON.stringify(globalPatterns, null, 2));\n    logHook('pattern-sync-push', `Pushed ${newPatterns.length} new patterns to global`);\n  } catch (err) {\n    logHook('pattern-sync-push', `Failed to push project patterns: ${err}`);\n  }\n}\n\n/**\n * Pattern sync push hook\n */\nexport function patternSyncPush(input: HookInput): HookResult {\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Check if sync is enabled\n  if (!isSyncEnabled(projectDir)) {\n    logHook('pattern-sync-push', 'Global sync disabled, skipping push');\n    return outputSilentSuccess();\n  }\n\n  // Push project patterns to global\n  logHook('pattern-sync-push', 'Pushing project patterns to global...');\n  pushProjectPatterns(projectDir);\n\n  return outputSilentSuccess();\n}\n", "/**\n * PR Status Enricher - SessionStart Hook\n * CC 2.1.20: Detects open PRs on current branch and sets env vars\n *\n * Runs at session start to provide PR context. Sets:\n * - ORCHESTKIT_PR_URL\n * - ORCHESTKIT_PR_STATE\n */\n\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, getCachedBranch, outputSilentSuccess } from '../lib/common.js';\n\n// Branches to skip PR detection\nconst SKIP_BRANCHES = new Set(['main', 'master', 'dev', 'develop']);\n\n/**\n * PR status enricher hook\n */\nexport function prStatusEnricher(input: HookInput): HookResult {\n  logHook('pr-status-enricher', 'Checking for open PR on current branch');\n\n  const projectDir = input.project_dir || getProjectDir();\n\n  // Get current branch\n  let branch: string;\n  try {\n    branch = getCachedBranch(projectDir);\n  } catch {\n    logHook('pr-status-enricher', 'Could not determine branch, skipping');\n    return outputSilentSuccess();\n  }\n\n  if (!branch || SKIP_BRANCHES.has(branch)) {\n    logHook('pr-status-enricher', `Branch \"${branch}\" skipped for PR detection`);\n    return outputSilentSuccess();\n  }\n\n  // Check for open PR using gh CLI\n  try {\n    const prJson = execSync(\n      'gh pr view --json state,reviewDecision,url,title,isDraft',\n      { cwd: projectDir, timeout: 10000, encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n    ).trim();\n\n    const pr = JSON.parse(prJson);\n    if (!pr.url) {\n      logHook('pr-status-enricher', 'No PR found for current branch');\n      return outputSilentSuccess();\n    }\n\n    // Set env vars for downstream hooks\n    process.env.ORCHESTKIT_PR_URL = pr.url;\n    process.env.ORCHESTKIT_PR_STATE = pr.state;\n\n    // Get unresolved comment count\n    let unresolvedCount = 0;\n    try {\n      const threadsJson = execSync(\n        'gh pr view --json reviewThreads',\n        { cwd: projectDir, timeout: 10000, encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }\n      ).trim();\n      const threads = JSON.parse(threadsJson);\n      unresolvedCount = (threads.reviewThreads || []).filter(\n        (t: { isResolved: boolean }) => !t.isResolved\n      ).length;\n    } catch {\n      // Non-critical, ignore\n    }\n\n    const draftLabel = pr.isDraft ? ' (DRAFT)' : '';\n    const reviewLabel = pr.reviewDecision ? ` | Review: ${pr.reviewDecision}` : '';\n    const unresolvedLabel = unresolvedCount > 0 ? ` | ${unresolvedCount} unresolved` : '';\n\n    logHook('pr-status-enricher', `PR: ${pr.title}${draftLabel} [${pr.state}${reviewLabel}${unresolvedLabel}]`);\n    logHook('pr-status-enricher', `URL: ${pr.url}`);\n  } catch {\n    logHook('pr-status-enricher', 'No PR found or gh CLI unavailable');\n  }\n\n  // Note: SessionStart hooks don't support hookSpecificOutput.additionalContext (line 90 of session-context-loader.ts)\n  return outputSilentSuccess();\n}\n", "/**\n * Session Cleanup - Cleans up temporary files at session end\n * Also sanitizes sessions-index.json firstPrompt entries to strip\n * XML command tags, task notifications, and terminal artifacts\n * Hook: SessionEnd\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, unlinkSync, copyFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { homedir } from 'node:os';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\nimport { cleanupTeam } from '../lib/agent-teams.js';\nimport { appendAnalytics, hashProject, getTeamContext } from '../lib/analytics.js';\nimport { getMetricsFile } from '../lib/paths.js';\nimport { getTotalTools } from '../lib/metrics.js';\n\ninterface SessionEntry {\n  sessionId: string;\n  firstPrompt?: string;\n  summary?: string;\n  [key: string]: unknown;\n}\n\ninterface SessionsIndex {\n  version: number;\n  entries: SessionEntry[];\n}\n\n/**\n * Archive session metrics if significant\n */\nfunction archiveMetrics(metricsFile: string, archiveDir: string): void {\n  if (!existsSync(metricsFile)) {\n    return;\n  }\n\n  const totalTools = getTotalTools();\n\n  // Only archive if there were more than 5 tool calls\n  if (totalTools <= 5) {\n    logHook('session-cleanup', `Session had only ${totalTools} tool calls, not archiving`);\n    return;\n  }\n\n  try {\n    mkdirSync(archiveDir, { recursive: true });\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const archiveName = `session-${timestamp}.json`;\n    const archivePath = `${archiveDir}/${archiveName}`;\n\n    copyFileSync(metricsFile, archivePath);\n    logHook('session-cleanup', `Archived session metrics to ${archiveName}`);\n  } catch (err) {\n    logHook('session-cleanup', `Failed to archive metrics: ${err}`);\n  }\n}\n\n/**\n * Clean up old session archives (keep last 20)\n */\nfunction cleanupOldArchives(archiveDir: string, keepCount: number = 20): void {\n  if (!existsSync(archiveDir)) {\n    return;\n  }\n\n  try {\n    const files = readdirSync(archiveDir)\n      .filter((f) => f.startsWith('session-') && f.endsWith('.json'))\n      .sort()\n      .reverse(); // Most recent first\n\n    if (files.length <= keepCount) {\n      return;\n    }\n\n    const toDelete = files.slice(keepCount);\n    for (const file of toDelete) {\n      try {\n        unlinkSync(`${archiveDir}/${file}`);\n        logHook('session-cleanup', `Deleted old archive: ${file}`);\n      } catch {\n        // Ignore deletion errors\n      }\n    }\n  } catch (err) {\n    logHook('session-cleanup', `Failed to cleanup old archives: ${err}`);\n  }\n}\n\n/**\n * Clean up old rotated log files (keep last 5)\n */\nfunction cleanupRotatedLogs(logDir: string): void {\n  if (!existsSync(logDir)) {\n    return;\n  }\n\n  const patterns = ['hooks.log.old*', 'audit.log.old*'];\n\n  for (const pattern of patterns) {\n    try {\n      const prefix = pattern.replace(/\\*/g, '');\n      const files = readdirSync(logDir)\n        .filter((f) => f.startsWith(prefix))\n        .sort()\n        .reverse(); // Most recent first\n\n      if (files.length <= 5) {\n        continue;\n      }\n\n      const toDelete = files.slice(5);\n      for (const file of toDelete) {\n        try {\n          unlinkSync(`${logDir}/${file}`);\n        } catch {\n          // Ignore deletion errors\n        }\n      }\n    } catch {\n      // Ignore scan errors\n    }\n  }\n}\n\n/**\n * Sanitize a firstPrompt string by stripping XML tags and terminal artifacts.\n *\n * Handles:\n * - <command-name>/ork:foo</command-name> \u2192 /ork:foo\n * - <command-message>ork:foo</command-message> \u2192 (dropped, redundant)\n * - <command-args>user text here</command-args> \u2192 user text here\n * - <task-notification>...<summary>text</summary>...</task-notification> \u2192 text\n * - Terminal block characters (\u2590\u259B\u2588\u2588\u2588\u259C\u258C etc.) \u2192 stripped\n * - CC banner + path prompt prefixes \u2192 stripped\n * - [Request interrupted by user...] \u2192 preserved as-is\n */\nexport function sanitizeFirstPrompt(raw: string): string {\n  if (!raw || typeof raw !== 'string' || raw === 'No prompt') return (raw as string) || '';\n\n  let cleaned = raw;\n\n  // 1. Handle <task-notification> \u2014 extract <summary> content if present\n  if (cleaned.includes('<task-notification>')) {\n    const taskSummaryMatch = cleaned.match(/<summary>(.*?)<\\/summary>/s);\n    if (taskSummaryMatch) {\n      return taskSummaryMatch[1].trim();\n    }\n    // Truncated task notification without summary \u2014 use session summary instead\n    // Return empty to signal \"use summary field instead\"\n    return '(background task)';\n  }\n\n  // 2. Extract command args (the actual user input)\n  const argsMatch = cleaned.match(/<command-args>(.*?)(?:<\\/command-args>|$)/s);\n  // 3. Extract command name\n  const nameMatch = cleaned.match(/<command-name>(.*?)<\\/command-name>/);\n\n  if (nameMatch || argsMatch) {\n    const parts: string[] = [];\n    if (nameMatch) parts.push(nameMatch[1].trim());\n    if (argsMatch) {\n      const args = argsMatch[1].trim();\n      if (args) parts.push(args);\n    }\n    if (parts.length > 0) return parts.join(' ');\n  }\n\n  // 4. Strip any remaining XML-style tags\n  cleaned = cleaned.replace(/<[^>]+>/g, ' ');\n\n  // 5. Strip terminal block/box drawing characters (U+2500-U+259F)\n  cleaned = cleaned.replace(/[\\u2500-\\u259f]/g, '');\n\n  // 6. Strip everything before the prompt character \u276F (U+276F) \u2014 this catches\n  //    CC banners, path prefixes, and other terminal rendering artifacts\n  const promptIdx = cleaned.indexOf('\\u276f');\n  if (promptIdx !== -1) {\n    cleaned = cleaned.slice(promptIdx + 1);\n  } else {\n    // No \u276F found \u2014 still strip CC banner text\n    cleaned = cleaned.replace(/Claude Code v[\\d.]+/g, '');\n    cleaned = cleaned.replace(/Opus [\\d.]+\\s*[\u00B7.]\\s*Claude Max/g, '');\n  }\n\n  // 7. Strip compaction notices and tool result prefixes\n  cleaned = cleaned.replace(/[\u273B\u23FA\u23BF]\\s*/g, '');\n  cleaned = cleaned.replace(/Conversation compacted[^)]*\\)/g, '');\n  cleaned = cleaned.replace(/Referenced file [^\\s]+/g, '');\n\n  // 8. Strip trailing tool invocations (e.g., \"Bash(gh pr view...\")\n  cleaned = cleaned.replace(/\\s+(Bash|Read|Write|Edit|Glob|Grep|Task|Skill)\\(.*$/s, '');\n\n  // 9. Strip remaining path prefixes (~/coding/projects/foo)\n  cleaned = cleaned.replace(/~\\/[\\w/._-]+/g, '');\n\n  // 10. Strip ellipsis artifacts from truncation\n  cleaned = cleaned.replace(/[\u2026]+/g, '');\n\n  // 11. Collapse whitespace\n  cleaned = cleaned.replace(/\\s+/g, ' ').trim();\n\n  // Return cleaned text, or empty string to signal fallback needed\n  return cleaned;\n}\n\n/**\n * Sanitize sessions-index.json firstPrompt entries.\n * Resolves the CC project path from the project directory.\n */\nfunction sanitizeSessionsIndex(projectDir: string): void {\n  // CC stores sessions at ~/.claude/projects/<encoded-path>/sessions-index.json\n  const home = homedir();\n  const ccProjectsDir = join(home, '.claude', 'projects');\n\n  if (!existsSync(ccProjectsDir)) return;\n\n  // Encode project path the way CC does: replace / with -\n  const encodedPath = projectDir.replace(/\\//g, '-');\n  const indexFile = join(ccProjectsDir, encodedPath, 'sessions-index.json');\n\n  if (!existsSync(indexFile)) {\n    logHook('session-cleanup', 'No sessions-index.json found');\n    return;\n  }\n\n  try {\n    const data: SessionsIndex = JSON.parse(readFileSync(indexFile, 'utf-8'));\n    let changed = 0;\n\n    for (const entry of data.entries) {\n      if (!entry.firstPrompt || entry.firstPrompt === 'No prompt') continue;\n\n      let cleaned = sanitizeFirstPrompt(entry.firstPrompt);\n\n      // Use summary as fallback when sanitization strips everything or leaves fragments\n      if (!cleaned || cleaned.length < 10) {\n        cleaned = entry.summary || entry.firstPrompt;\n      }\n\n      if (cleaned !== entry.firstPrompt) {\n        entry.firstPrompt = cleaned;\n        changed++;\n      }\n    }\n\n    if (changed > 0) {\n      writeFileSync(indexFile, JSON.stringify(data, null, 4));\n      logHook('session-cleanup', `Sanitized ${changed} session firstPrompt entries`);\n    }\n  } catch (err) {\n    logHook('session-cleanup', `Failed to sanitize sessions index: ${err}`, 'warn');\n  }\n}\n\n/**\n * Session cleanup hook\n */\nexport function sessionCleanup(input: HookInput): HookResult {\n  logHook('session-cleanup', 'Session cleanup starting');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const metricsFile = getMetricsFile(); // cross-platform path via lib/paths.ts\n  const archiveDir = `${projectDir}/.claude/logs/sessions`;\n  const logDir = `${projectDir}/.claude/logs`;\n\n  // Sanitize session names in the resume screen\n  sanitizeSessionsIndex(projectDir);\n\n  // Archive metrics if significant\n  archiveMetrics(metricsFile, archiveDir);\n\n  // Clean up old session archives (keep last 20)\n  cleanupOldArchives(archiveDir, 20);\n\n  // Clean up old rotated log files (keep last 5)\n  cleanupRotatedLogs(logDir);\n\n  // Clean up team directories if this session was a team lead\n  const teamName = process.env.CLAUDE_CODE_TEAM_NAME;\n  if (teamName) {\n    const cleaned = cleanupTeam(teamName);\n    logHook('session-cleanup', cleaned\n      ? `Cleaned team \"${teamName}\" directories`\n      : `Warning: partial cleanup for team \"${teamName}\"`);\n  }\n\n  // Cross-project session summary (Issue #459, #707, #727)\n  const totalTools = getTotalTools();\n  if (totalTools > 0) {\n    const lastMsgLen = input.last_assistant_message?.length ?? null;\n    appendAnalytics('session-summary.jsonl', {\n      ts: new Date().toISOString(),\n      pid: hashProject(projectDir),\n      total_tools: totalTools,\n      added_dirs_count: (input.added_dirs ?? []).length,\n      ...(lastMsgLen !== null && { last_msg_len: lastMsgLen }),\n      ...getTeamContext(),\n    });\n  }\n\n  logHook('session-cleanup', 'Session cleanup complete');\n\n  return outputSilentSuccess();\n}\n", "/**\n * Agent Teams Detection & Configuration Utility\n * Issue #362: Deprecate coordination hooks redundant with CC Agent Teams\n *\n * CC Agent Teams (CC 2.1.33+) provides native multi-instance coordination:\n * - Teammate lifecycle management\n * - 5-minute runtime heartbeat\n * - Idle notifications\n * - Cleanup on session end\n *\n * When Agent Teams is active, OrchestKit's custom coordination hooks\n * should yield to CC's native implementation to avoid duplication.\n */\n\nimport { existsSync, readFileSync, readdirSync, statSync, rmSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Check if CC Agent Teams is active.\n *\n * Detection signals:\n * - CLAUDE_CODE_TEAM_NAME: Set when running as part of an Agent Teams team\n * - CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS: Feature flag for Agent Teams\n */\nexport function isAgentTeamsActive(): boolean {\n  return !!(\n    process.env.CLAUDE_CODE_TEAM_NAME ||\n    process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS === '1'\n  );\n}\n\n/** Check if current session is a teammate in a team */\nexport function isTeammate(): boolean {\n  return !!process.env.CLAUDE_CODE_TEAM_NAME;\n}\n\n/** Get current team name */\nexport function getTeamName(): string | null {\n  return process.env.CLAUDE_CODE_TEAM_NAME || null;\n}\n\nexport interface TeamMember {\n  name: string;\n  agentType: string;\n}\n\n/**\n * Read team config to get member list.\n * Reads from ~/.claude/teams/{team-name}/config.json\n */\nexport function getTeamMembers(): TeamMember[] {\n  const teamName = getTeamName();\n  if (!teamName) return [];\n\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n\n  const configPath = join(homeDir, '.claude', 'teams', teamName, 'config.json');\n  if (!existsSync(configPath)) return [];\n\n  try {\n    const config = JSON.parse(readFileSync(configPath, 'utf-8'));\n    const members = config.members;\n    if (!Array.isArray(members)) return [];\n\n    return members.map((m: { name?: string; agentType?: string }) => ({\n      name: m.name || 'unknown',\n      agentType: m.agentType || 'unknown',\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/** Count current team members */\nexport function getTeamSize(): number {\n  return getTeamMembers().length;\n}\n\n/** List all team directories */\nexport function listAllTeams(): string[] {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n  const teamsDir = join(homeDir, '.claude', 'teams');\n  if (!existsSync(teamsDir)) return [];\n  try {\n    return readdirSync(teamsDir).filter(name => {\n      try { return statSync(join(teamsDir, name)).isDirectory(); } catch { return false; }\n    });\n  } catch { return []; }\n}\n\n/** Check if team is stale (no config, or dir older than maxAgeHours) */\nexport function isStaleTeam(teamName: string, maxAgeHours: number = 4): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  const teamPath = join(homeDir, '.claude', 'teams', teamName);\n  if (!existsSync(teamPath)) return false;\n  const configPath = join(teamPath, 'config.json');\n  if (!existsSync(configPath)) return true;  // no config = orphaned\n  try {\n    const ageMs = Date.now() - statSync(teamPath).mtimeMs;\n    return ageMs > maxAgeHours * 3600_000;\n  } catch { return true; }\n}\n\n/** Remove team + task directories */\nexport function cleanupTeam(teamName: string): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  let ok = true;\n  for (const sub of ['teams', 'tasks']) {\n    const dir = join(homeDir, '.claude', sub, teamName);\n    if (existsSync(dir)) {\n      try { rmSync(dir, { recursive: true, force: true }); } catch { ok = false; }\n    }\n  }\n  return ok;\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-09\n\n/**\n * Cross-Project Analytics \u2014 User-Scoped JSONL\n *\n * Writes local-only analytics to ~/.claude/analytics/.\n * Privacy-by-design: no PII, no prompts, no code, no raw paths.\n * Project paths are hashed (12-char SHA256) for irreversible anonymity.\n *\n * Issue #459: Local Cross-Project Analytics System\n */\n\nimport { mkdirSync, statSync, renameSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { createHash } from 'node:crypto';\nimport { getHomeDir, joinPath } from './paths.js';\n\nfunction getAnalyticsDir(): string {\n  return joinPath(getHomeDir(), '.claude', 'analytics');\n}\n\n/** Hash project path for privacy \u2014 irreversible, 12-char hex */\nexport function hashProject(projectDir: string): string {\n  return createHash('sha256').update(projectDir).digest('hex').slice(0, 12);\n}\n\n/** Extract team context from env vars. Returns undefined when not in a team. */\nexport function getTeamContext(): { team: string } | undefined {\n  const team = process.env.CLAUDE_CODE_TEAM_NAME;\n  return team ? { team } : undefined;\n}\n\n/** Rotate file if it exceeds maxBytes (default 10MB). Renames to <name>.<YYYY-MM>.jsonl */\nexport function rotateIfNeeded(filePath: string, maxBytes = 10_485_760): void {\n  try {\n    const stats = statSync(filePath);\n    if (stats.size > maxBytes) {\n      const month = new Date().toISOString().slice(0, 7); // YYYY-MM\n      const rotated = filePath.replace(/\\.jsonl$/, `.${month}.jsonl`);\n      renameSync(filePath, rotated);\n    }\n  } catch {\n    // File doesn't exist or rename failed \u2014 both fine\n  }\n}\n\n/** Returns true when running inside a test runner (vitest / jest). */\nexport function isTestEnv(): boolean {\n  return !!(process.env.VITEST || process.env.JEST_WORKER_ID);\n}\n\n/** Append a JSONL entry to ~/.claude/analytics/<file>. Fire-and-forget. */\nexport function appendAnalytics(file: string, entry: Record<string, unknown>): void {\n  if (isTestEnv()) return;\n  try {\n    const dir = getAnalyticsDir();\n    mkdirSync(dir, { recursive: true });\n    const filePath = joinPath(dir, file);\n    rotateIfNeeded(filePath);\n    bufferWrite(filePath, `${JSON.stringify(entry)}\\n`);\n  } catch {\n    // Never block hooks\n  }\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Shared session metrics utilities.\n * Provides getTotalTools() used by session-cleanup and memory-capture.\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { getMetricsFile } from './paths.js';\n\ninterface SessionMetrics {\n  tools?: Record<string, number>;\n  [key: string]: unknown;\n}\n\n/**\n * Get total tool invocations from the session metrics file.\n * Returns 0 if the file does not exist or cannot be parsed.\n */\nexport function getTotalTools(): number {\n  const metricsFile = getMetricsFile();\n  if (!existsSync(metricsFile)) {\n    return 0;\n  }\n\n  try {\n    const metrics: SessionMetrics = JSON.parse(readFileSync(metricsFile, 'utf-8'));\n    const tools = metrics.tools || {};\n    return Object.values(tools).reduce((sum, count) => sum + count, 0);\n  } catch {\n    return 0;\n  }\n}\n", "/**\n * Session Context Loader - Loads session context at session start\n * Hook: SessionStart\n * CC 2.1.7 Compliant - Context Protocol 2.0\n * Supports agent_type for context-aware initialization\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\n\n/**\n * Validate JSON file\n */\nfunction isValidJsonFile(filePath: string): boolean {\n  if (!existsSync(filePath)) {\n    return false;\n  }\n\n  try {\n    JSON.parse(readFileSync(filePath, 'utf-8'));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Session context loader hook\n */\nexport function sessionContextLoader(input: HookInput): HookResult {\n  logHook('session-context-loader', 'Session starting - loading context (Protocol 2.0)');\n\n  const projectDir = input.project_dir || getProjectDir();\n  let contextLoaded = 0;\n\n  // Extract agent_type from environment (set by startup-dispatcher)\n  const agentType = process.env.AGENT_TYPE || '';\n\n  // Context Protocol 2.0 paths\n  const sessionState = `${projectDir}/.claude/context/session/state.json`;\n  const identityFile = `${projectDir}/.claude/context/identity.json`;\n  const knowledgeIndex = `${projectDir}/.claude/context/knowledge/index.json`;\n\n  // Load session state\n  if (isValidJsonFile(sessionState)) {\n    logHook('session-context-loader', 'Session state loaded');\n    contextLoaded++;\n  }\n\n  // Load identity\n  if (isValidJsonFile(identityFile)) {\n    logHook('session-context-loader', 'Identity loaded');\n    contextLoaded++;\n  }\n\n  // Check knowledge index\n  if (isValidJsonFile(knowledgeIndex)) {\n    logHook('session-context-loader', 'Knowledge index available');\n    contextLoaded++;\n  }\n\n  // Load current status docs if they exist\n  const statusFile = `${projectDir}/docs/CURRENT_STATUS.md`;\n  if (existsSync(statusFile)) {\n    logHook('session-context-loader', 'Current status document exists');\n  }\n\n  // Agent-type aware context loading (CC 2.1.6 feature)\n  if (agentType) {\n    logHook('session-context-loader', `Agent-type aware initialization: ${agentType}`);\n\n    // Check if there's agent-specific configuration\n    const agentConfig = `${projectDir}/.claude/agents/${agentType}.md`;\n    if (existsSync(agentConfig)) {\n      logHook('session-context-loader', `Agent configuration found: ${agentConfig}`);\n      contextLoaded++;\n    }\n  }\n\n  // CC 2.1.47: Scan added directories for context files\n  if (input.added_dirs && input.added_dirs.length > 0) {\n    for (const dir of input.added_dirs) {\n      const addedDirState = `${dir}/.claude/context/session/state.json`;\n      if (isValidJsonFile(addedDirState)) {\n        logHook('session-context-loader', `Additional context from added dir: ${dir}`);\n        contextLoaded++;\n      }\n    }\n  }\n\n  // CC 2.1.20: Load compaction manifest from previous session\n  const compactionManifest = `${projectDir}/.claude/context/session/compaction-manifest.json`;\n  if (isValidJsonFile(compactionManifest)) {\n    try {\n      const manifest = JSON.parse(readFileSync(compactionManifest, 'utf-8'));\n      logHook('session-context-loader', `Compaction manifest loaded: session=${manifest.sessionId}, decisions=${(manifest.keyDecisions || []).length}, files=${(manifest.filesTouched || []).length}`);\n      process.env.ORCHESTKIT_LAST_SESSION = manifest.sessionId || '';\n      process.env.ORCHESTKIT_LAST_DECISIONS = JSON.stringify(manifest.keyDecisions || []);\n      contextLoaded++;\n    } catch (error) {\n      logHook('session-context-loader', `Error loading compaction manifest: ${error}`);\n    }\n  }\n\n  // Log summary\n  if (contextLoaded > 0) {\n    if (agentType) {\n      logHook('session-context-loader', `Session context loaded (Protocol 2.0) - Agent: ${agentType}`);\n    } else {\n      logHook('session-context-loader', 'Session context loaded (Protocol 2.0)');\n    }\n  }\n\n  // Note: SessionStart hooks don't support hookSpecificOutput.additionalContext\n  return outputSilentSuccess();\n}\n", "/**\n * Session Environment Setup - Initializes session environment\n * Hook: SessionStart\n * CC 2.1.6 Compliant - Supports agent_type field\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, getSessionId, outputSilentSuccess } from '../lib/common.js';\nimport { getMetricsFile } from '../lib/paths.js';\n\ninterface SessionState {\n  agent_type?: string;\n  session_id?: string;\n  last_activity?: string;\n  [key: string]: unknown;\n}\n\ninterface SessionMetrics {\n  session_id: string;\n  started_at: string;\n  agent_type: string;\n  tools: Record<string, number>;\n  errors: number;\n  warnings: number;\n}\n\n/**\n * Get current git branch\n */\nfunction getCurrentBranch(projectDir: string): string {\n  try {\n    return execSync('git branch --show-current', {\n      cwd: projectDir,\n      encoding: 'utf-8',\n      timeout: 500,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Session environment setup hook\n */\nexport function sessionEnvSetup(input: HookInput): HookResult {\n  logHook('session-env-setup', 'Setting up session environment');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionId = input.session_id || getSessionId();\n  const metricsFile = getMetricsFile();\n\n  // Create logs directory if needed\n  try {\n    mkdirSync(`${projectDir}/.claude/logs`, { recursive: true });\n  } catch {\n    // Ignore mkdir errors\n  }\n\n  // Extract agent_type from environment or hook input\n  let agentType = process.env.AGENT_TYPE || '';\n  if (!agentType && input.agent_type) {\n    agentType = input.agent_type;\n  }\n\n  // Initialize session metrics\n  const metrics: SessionMetrics = {\n    session_id: sessionId,\n    started_at: new Date().toISOString(),\n    agent_type: agentType,\n    tools: {},\n    errors: 0,\n    warnings: 0,\n  };\n\n  try {\n    writeFileSync(metricsFile, JSON.stringify(metrics, null, 2));\n    logHook('session-env-setup', 'Initialized session metrics');\n  } catch (err) {\n    logHook('session-env-setup', `Failed to initialize metrics: ${err}`);\n  }\n\n  // Update session state with agent_type (CC 2.1.6 feature)\n  const sessionState = `${projectDir}/.claude/context/session/state.json`;\n  if (existsSync(sessionState) && agentType) {\n    try {\n      const state: SessionState = JSON.parse(readFileSync(sessionState, 'utf-8'));\n      state.agent_type = agentType;\n      state.session_id = sessionId;\n      state.last_activity = new Date().toISOString();\n      writeFileSync(sessionState, JSON.stringify(state, null, 2));\n      logHook('session-env-setup', `Updated session state with agent_type: ${agentType}`);\n    } catch (err) {\n      logHook('session-env-setup', `Failed to update session state: ${err}`);\n    }\n  }\n\n  // Check git status with timeout\n  const branch = getCurrentBranch(projectDir);\n  if (branch) {\n    logHook('session-env-setup', `Git branch: ${branch}`);\n  }\n\n  // Log agent type if present\n  if (agentType) {\n    logHook('session-env-setup', `Agent type: ${agentType}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Session Event Tracker\n * Logs all session events (skills, agents, hooks, decisions) with user identity.\n *\n * Events are stored per-session in JSONL format for later aggregation.\n * This enables learning user patterns across sessions.\n *\n * Storage: .claude/memory/sessions/{session_id}/events.jsonl\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport { getIdentityContext, type IdentityContext } from './user-identity.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Event types that can be tracked\n */\nexport type SessionEventType =\n  | 'skill_invoked'\n  | 'agent_spawned'\n  | 'hook_triggered'\n  | 'decision_made'\n  | 'preference_stated'\n  | 'problem_reported'\n  | 'solution_found'\n  | 'tool_used'\n  | 'session_start'\n  | 'session_end'\n  | 'communication_style_detected';\n\n/**\n * A single session event\n */\nexport interface SessionEvent {\n  /** Unique event ID */\n  event_id: string;\n  /** Event type */\n  event_type: SessionEventType;\n  /** Identity context (user, session, machine) */\n  identity: IdentityContext;\n  /** Event-specific payload */\n  payload: {\n    /** Name of skill/agent/hook/tool */\n    name: string;\n    /** Input data (optional, may be truncated for privacy) */\n    input?: Record<string, unknown>;\n    /** Output/result (optional, may be truncated) */\n    output?: Record<string, unknown>;\n    /** Duration in milliseconds */\n    duration_ms?: number;\n    /** Whether the event succeeded */\n    success: boolean;\n    /** Additional context */\n    context?: string;\n    /** Confidence score (for decisions) */\n    confidence?: number;\n  };\n}\n\n/**\n * Session summary (aggregated at session end)\n */\nexport interface SessionSummary {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  start_time?: string;\n  end_time?: string;\n  duration_ms?: number;\n  event_counts: Record<SessionEventType, number>;\n  skills_used: string[];\n  agents_spawned: string[];\n  hooks_triggered: string[];\n  decisions_made: number;\n  problems_reported: number;\n  solutions_found: number;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/** Session ID validation regex - alphanumeric, dashes, underscores only (SEC-002) */\nconst SESSION_ID_PATTERN = /^[a-zA-Z0-9_-]{1,128}$/;\n\n/**\n * Validate session ID to prevent path traversal attacks.\n * Defense-in-depth: trusted sources, but we validate at boundary anyway.\n */\nfunction isValidSessionId(sessionId: string): boolean {\n  return SESSION_ID_PATTERN.test(sessionId);\n}\n\n/**\n * Get session storage directory\n * @param sessionId - Optional session ID (defaults to env var)\n * @param projectDir - Optional project directory (defaults to env var)\n */\nfunction getSessionDir(sessionId?: string, projectDir?: string): string {\n  const sid = sessionId || getSessionId();\n  const pDir = projectDir || getProjectDir();\n  // Validate session ID to prevent path traversal (SEC-002)\n  if (!isValidSessionId(sid)) {\n    throw new Error(`Invalid session ID format`);\n  }\n  return `${pDir}/.claude/memory/sessions/${sid}`;\n}\n\n/**\n * Get events file path for a session\n */\nfunction getEventsPath(sessionId?: string, projectDir?: string): string {\n  return `${getSessionDir(sessionId, projectDir)}/events.jsonl`;\n}\n\n/**\n * Ensure session directory exists\n */\nfunction ensureSessionDir(sessionId?: string, projectDir?: string): void {\n  const dir = getSessionDir(sessionId, projectDir);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n// =============================================================================\n// EVENT GENERATION (Persistent Counter - Issue #245)\n// =============================================================================\n\n/** In-memory event counter */\nlet eventCounter = 0;\n\n/** Counter persistence state */\nlet counterLoaded = false;\nlet counterDirty = false;\nlet lastPersistTime = 0;\n\n/** Batch persist interval (ms) - write at most every 5 seconds */\nconst PERSIST_INTERVAL = 5000;\n\n/**\n * Get counter file path for current session\n */\nfunction getCounterPath(sessionId?: string, projectDir?: string): string {\n  const dir = getSessionDir(sessionId, projectDir);\n  return `${dir}/counter.json`;\n}\n\n/**\n * Load persisted counter value\n * Called once at first event generation\n */\nfunction loadPersistedCounter(sessionId?: string, projectDir?: string): void {\n  if (counterLoaded) return;\n  counterLoaded = true;\n\n  try {\n    const counterPath = getCounterPath(sessionId, projectDir);\n    if (existsSync(counterPath)) {\n      const data = JSON.parse(readFileSync(counterPath, 'utf8'));\n      if (typeof data.counter === 'number' && data.counter > 0) {\n        eventCounter = data.counter;\n        logHook('session-tracker', `Loaded event counter: ${eventCounter}`, 'debug');\n      }\n    }\n  } catch {\n    // Ignore load errors - start fresh\n  }\n}\n\n/**\n * Persist counter to disk (batched)\n * Only writes if counter changed and interval elapsed\n */\nfunction persistCounter(sessionId?: string, projectDir?: string): void {\n  if (!counterDirty) return;\n\n  const now = Date.now();\n  if (now - lastPersistTime < PERSIST_INTERVAL) return;\n\n  try {\n    ensureSessionDir(sessionId, projectDir);\n    const counterPath = getCounterPath(sessionId, projectDir);\n    writeFileSync(counterPath, JSON.stringify({\n      counter: eventCounter,\n      updated_at: new Date().toISOString(),\n    }));\n    counterDirty = false;\n    lastPersistTime = now;\n  } catch {\n    // Ignore persist errors - non-critical\n  }\n}\n\n/**\n * Generate unique event ID with persistent counter\n *\n * Format: evt-{timestamp}-{counter}\n * Counter persists across process restarts to prevent ID collisions.\n */\nfunction generateEventId(): string {\n  // Load persisted counter on first call\n  loadPersistedCounter();\n\n  eventCounter++;\n  counterDirty = true;\n\n  // Attempt batched persist\n  persistCounter();\n\n  return `evt-${Date.now()}-${eventCounter}`;\n}\n\n/**\n * Force persist counter (call at session end)\n * Exported for use by stop hooks\n */\nexport function flushEventCounter(): void {\n  if (counterDirty) {\n    try {\n      ensureSessionDir();\n      const counterPath = getCounterPath();\n      writeFileSync(counterPath, JSON.stringify({\n        counter: eventCounter,\n        updated_at: new Date().toISOString(),\n      }));\n      counterDirty = false;\n      logHook('session-tracker', `Flushed event counter: ${eventCounter}`, 'debug');\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Reset counter state (for testing only)\n */\nexport function resetEventCounter(): void {\n  eventCounter = 0;\n  counterLoaded = false;\n  counterDirty = false;\n  lastPersistTime = 0;\n}\n\n// =============================================================================\n// EVENT TRACKING\n// =============================================================================\n\n/**\n * Track a session event\n *\n * @param eventType - Type of event\n * @param name - Name of skill/agent/hook/tool\n * @param options - Additional event options\n */\nexport function trackEvent(\n  eventType: SessionEventType,\n  name: string,\n  options: {\n    input?: Record<string, unknown>;\n    output?: Record<string, unknown>;\n    duration_ms?: number;\n    success?: boolean;\n    context?: string;\n    confidence?: number;\n  } = {}\n): void {\n  try {\n    const event: SessionEvent = {\n      event_id: generateEventId(),\n      event_type: eventType,\n      identity: getIdentityContext(),\n      payload: {\n        name,\n        input: sanitizeForStorage(options.input),\n        output: sanitizeForStorage(options.output),\n        duration_ms: options.duration_ms,\n        success: options.success ?? true,\n        context: options.context ? truncate(options.context, 500) : undefined,\n        confidence: options.confidence,\n      },\n    };\n\n    ensureSessionDir();\n    const eventsPath = getEventsPath();\n    bufferWrite(eventsPath, `${JSON.stringify(event)}\\n`);\n\n    logHook('session-tracker', `Tracked ${eventType}: ${name}`, 'debug');\n  } catch (error) {\n    logHook('session-tracker', `Failed to track event: ${error}`, 'warn');\n  }\n}\n\n/**\n * Track skill invocation\n */\nexport function trackSkillInvoked(\n  skillName: string,\n  args?: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('skill_invoked', skillName, {\n    input: args ? { args } : undefined,\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track agent spawn\n */\nexport function trackAgentSpawned(\n  agentType: string,\n  prompt?: string,\n  success: boolean = true\n): void {\n  trackEvent('agent_spawned', agentType, {\n    input: prompt ? { prompt: truncate(prompt, 200) } : undefined,\n    success,\n  });\n}\n\n/**\n * Track hook triggered\n */\nexport function trackHookTriggered(\n  hookName: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('hook_triggered', hookName, {\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track decision made\n */\nexport function trackDecisionMade(\n  decision: string,\n  rationale?: string,\n  confidence?: number\n): void {\n  trackEvent('decision_made', 'decision', {\n    context: decision,\n    input: rationale ? { rationale } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track preference stated\n */\nexport function trackPreferenceStated(\n  preference: string,\n  confidence?: number\n): void {\n  trackEvent('preference_stated', 'preference', {\n    context: preference,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track problem reported\n */\nexport function trackProblemReported(problem: string): void {\n  trackEvent('problem_reported', 'problem', {\n    context: problem,\n    success: true,\n  });\n}\n\n/**\n * Track solution found\n */\nexport function trackSolutionFound(\n  solution: string,\n  problemId?: string,\n  confidence?: number\n): void {\n  trackEvent('solution_found', 'solution', {\n    context: solution,\n    input: problemId ? { problem_id: problemId } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track tool usage\n *\n * @param toolName - Name of the tool (e.g., 'Grep', 'Read')\n * @param success - Whether the tool call succeeded\n * @param durationMs - Duration of the tool call in milliseconds\n * @param category - Tool category (e.g., 'search', 'file_read') for preference tracking\n */\nexport function trackToolUsed(\n  toolName: string,\n  success: boolean = true,\n  durationMs?: number,\n  category?: string\n): void {\n  trackEvent('tool_used', toolName, {\n    success,\n    duration_ms: durationMs,\n    input: category ? { category } : undefined,\n  });\n}\n\n/**\n * Session context captured at session start\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport interface SessionContext {\n  /** Project directory path */\n  project_dir?: string;\n  /** Current git branch */\n  git_branch?: string;\n  /** Time of day category */\n  time_of_day?: 'morning' | 'afternoon' | 'evening' | 'night';\n  /** CC 2.1.47: Number of /add-dir directories active */\n  added_dirs_count?: number;\n  /** Timestamp */\n  started_at: string;\n}\n\n/**\n * Get time of day category from hour\n */\nfunction getTimeOfDay(hour: number): 'morning' | 'afternoon' | 'evening' | 'night' {\n  if (hour >= 5 && hour < 12) return 'morning';\n  if (hour >= 12 && hour < 17) return 'afternoon';\n  if (hour >= 17 && hour < 21) return 'evening';\n  return 'night';\n}\n\n/**\n * Track session start with context\n * Issue #245 Phase 5: Session Lifecycle Tracking\n *\n * @param context - Optional session context (project, branch, time)\n */\nexport function trackSessionStart(context?: Partial<SessionContext>): void {\n  const now = new Date();\n  const sessionContext: SessionContext = {\n    project_dir: context?.project_dir,\n    git_branch: context?.git_branch,\n    time_of_day: context?.time_of_day || getTimeOfDay(now.getHours()),\n    started_at: now.toISOString(),\n  };\n\n  trackEvent('session_start', 'session', {\n    success: true,\n    input: sessionContext as unknown as Record<string, unknown>,\n  });\n}\n\n/**\n * Track session end with timestamp\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport function trackSessionEnd(): void {\n  trackEvent('session_end', 'session', {\n    success: true,\n    input: { ended_at: new Date().toISOString() },\n  });\n}\n\n/**\n * Track user communication style\n */\nexport function trackCommunicationStyle(\n  style: {\n    verbosity: 'terse' | 'moderate' | 'detailed';\n    interaction_type: 'question' | 'command' | 'discussion';\n    technical_level: 'beginner' | 'intermediate' | 'expert';\n  }\n): void {\n  trackEvent('communication_style_detected', 'communication', {\n    input: style as unknown as Record<string, unknown>,\n    success: true,\n  });\n}\n\n\n// =============================================================================\n// SESSION SUMMARY\n// =============================================================================\n\n/**\n * Load all events for a session\n */\nexport function loadSessionEvents(sessionId?: string): SessionEvent[] {\n  const eventsPath = getEventsPath(sessionId);\n\n  if (!existsSync(eventsPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(eventsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    return lines.map(line => JSON.parse(line));\n  } catch (error) {\n    logHook('session-tracker', `Failed to load session events: ${error}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Generate session summary from events\n */\nexport function generateSessionSummary(sessionId?: string): SessionSummary {\n  const events = loadSessionEvents(sessionId);\n  const identity = getIdentityContext();\n\n  const eventCounts: Record<SessionEventType, number> = {\n    skill_invoked: 0,\n    agent_spawned: 0,\n    hook_triggered: 0,\n    decision_made: 0,\n    preference_stated: 0,\n    problem_reported: 0,\n    solution_found: 0,\n    tool_used: 0,\n    session_start: 0,\n    session_end: 0,\n    communication_style_detected: 0,\n  };\n\n  const skillsUsed = new Set<string>();\n  const agentsSpawned = new Set<string>();\n  const hooksTriggered = new Set<string>();\n\n  let startTime: string | undefined;\n  let endTime: string | undefined;\n\n  for (const event of events) {\n    eventCounts[event.event_type]++;\n\n    switch (event.event_type) {\n      case 'skill_invoked':\n        skillsUsed.add(event.payload.name);\n        break;\n      case 'agent_spawned':\n        agentsSpawned.add(event.payload.name);\n        break;\n      case 'hook_triggered':\n        hooksTriggered.add(event.payload.name);\n        break;\n      case 'session_start':\n        startTime = event.identity.timestamp;\n        break;\n      case 'session_end':\n        endTime = event.identity.timestamp;\n        break;\n    }\n  }\n\n  const durationMs =\n    startTime && endTime\n      ? new Date(endTime).getTime() - new Date(startTime).getTime()\n      : undefined;\n\n  return {\n    session_id: sessionId || identity.session_id,\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    start_time: startTime,\n    end_time: endTime,\n    duration_ms: durationMs,\n    event_counts: eventCounts,\n    skills_used: [...skillsUsed],\n    agents_spawned: [...agentsSpawned],\n    hooks_triggered: [...hooksTriggered],\n    decisions_made: eventCounts.decision_made,\n    problems_reported: eventCounts.problem_reported,\n    solutions_found: eventCounts.solution_found,\n  };\n}\n\n// =============================================================================\n// CROSS-SESSION QUERIES\n// =============================================================================\n// GAP-008/009 FIX: Removed listSessionIds() and getRecentUserSessions()\n// These functions were exported but never called by production code.\n// Cross-session queries should be handled by profile-injector if needed.\n// =============================================================================\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Truncate string to max length\n */\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return `${str.slice(0, maxLen - 3)}...`;\n}\n\n/**\n * Sanitize object for storage (remove sensitive data, truncate)\n */\nfunction sanitizeForStorage(\n  obj: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!obj) return undefined;\n\n  const sanitized: Record<string, unknown> = {};\n  const sensitiveKeys = ['password', 'secret', 'token', 'key', 'credential', 'auth'];\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip sensitive keys\n    if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {\n      sanitized[key] = '[REDACTED]';\n      continue;\n    }\n\n    // Truncate long strings\n    if (typeof value === 'string' && value.length > 500) {\n      sanitized[key] = truncate(value, 500);\n      continue;\n    }\n\n    // Recursively sanitize objects\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      sanitized[key] = sanitizeForStorage(value as Record<string, unknown>);\n      continue;\n    }\n\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n}\n", "/**\n * User Identity System\n * Resolves and manages user identity across sessions for multi-user decision capture.\n *\n * Identity Resolution Order:\n * 1. Explicit config (.claude/.user_identity.json)\n * 2. Git config (user.email, user.name)\n * 3. Environment variables (USER, USERNAME)\n * 4. Anonymous (machine-based hash)\n *\n * Privacy: User controls what gets shared via privacy settings.\n * Storage: User profiles stored locally in .claude/memory/users/\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { basename } from 'node:path';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport * as os from 'node:os';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * User identity source - where the identity was resolved from\n */\nexport type IdentitySource = 'config' | 'git' | 'env' | 'anonymous';\n\n/**\n * Resolved user identity\n */\nexport interface UserIdentity {\n  /** Unique user identifier (email, username, or anonymous hash) */\n  user_id: string;\n  /** Human-readable display name */\n  display_name: string;\n  /** Optional team/org identifier */\n  team_id?: string;\n  /** Machine identifier (hostname) */\n  machine_id: string;\n  /** How the identity was resolved */\n  source: IdentitySource;\n  /** Anonymous hash for global sharing (privacy-preserving) */\n  anonymous_id: string;\n  /** Email if available */\n  email?: string;\n}\n\n/**\n * User privacy settings - controls what gets shared\n */\nexport interface PrivacySettings {\n  /** Share patterns with team (same project) */\n  share_with_team: boolean;\n  /** Share patterns globally (anonymized) */\n  share_globally: boolean;\n  /** Share decisions */\n  share_decisions: boolean;\n  /** Share preferences */\n  share_preferences: boolean;\n  /** Share skill usage statistics */\n  share_skill_usage: boolean;\n  /** Share prompt content (usually false for privacy) */\n  share_prompts: boolean;\n  /** Anonymize user_id when sharing globally */\n  anonymize_globally: boolean;\n}\n\n/**\n * User identity configuration file format\n */\nexport interface UserIdentityConfig {\n  /** Explicit user ID */\n  user_id?: string;\n  /** Display name */\n  display_name?: string;\n  /** Team identifier */\n  team_id?: string;\n  /** Privacy settings */\n  privacy?: Partial<PrivacySettings>;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst IDENTITY_CONFIG_FILE = '.claude/.user_identity.json';\nconst SALT = 'orchestkit-user-identity-v1';\n\n/** Default privacy settings (conservative) */\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  share_with_team: true,\n  share_globally: false, // Opt-in\n  share_decisions: true,\n  share_preferences: true,\n  share_skill_usage: false, // Might reveal workflow\n  share_prompts: false, // Privacy sensitive\n  anonymize_globally: true,\n};\n\n// =============================================================================\n// CACHING\n// =============================================================================\n\nlet cachedIdentity: UserIdentity | null = null;\nlet cachedPrivacy: PrivacySettings | null = null;\n\n/**\n * Clear cached identity (for testing)\n */\nexport function clearIdentityCache(): void {\n  cachedIdentity = null;\n  cachedPrivacy = null;\n}\n\n// =============================================================================\n// IDENTITY RESOLUTION\n// =============================================================================\n\n/**\n * Generate anonymous hash from input\n */\nfunction generateAnonymousId(input: string): string {\n  // Use 32 hex chars (128 bits) for proper collision resistance\n  return createHash('sha256')\n    .update(input + SALT)\n    .digest('hex')\n    .slice(0, 32);\n}\n\n/**\n * Get machine identifier\n */\nfunction getMachineId(): string {\n  try {\n    return os.hostname();\n  } catch {\n    return 'unknown-machine';\n  }\n}\n\n/**\n * Try to read explicit user config\n */\nfunction readUserConfig(projectDir: string): UserIdentityConfig | null {\n  const configPath = `${projectDir}/${IDENTITY_CONFIG_FILE}`;\n\n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    logHook('user-identity', `Failed to read user config: ${error}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Try to get identity from git config\n */\nfunction getGitIdentity(projectDir: string): { email?: string; name?: string } {\n  const result: { email?: string; name?: string } = {};\n\n  try {\n    result.email = execSync('git config user.email', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git email not configured\n  }\n\n  try {\n    result.name = execSync('git config user.name', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git name not configured\n  }\n\n  return result;\n}\n\n/**\n * Get identity from environment variables\n */\nfunction getEnvIdentity(): { username?: string } {\n  const username = process.env.USER || process.env.USERNAME || process.env.LOGNAME;\n  return { username };\n}\n\n/**\n * Resolve user identity using fallback chain\n *\n * Resolution order:\n * 1. Explicit config file\n * 2. Git config\n * 3. Environment username\n * 4. Anonymous (machine-based)\n */\nexport function resolveUserIdentity(projectDir?: string): UserIdentity {\n  // Return cached if available\n  if (cachedIdentity) {\n    return cachedIdentity;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const machineId = getMachineId();\n\n  // 1. Try explicit config\n  const config = readUserConfig(dir);\n  if (config?.user_id) {\n    cachedIdentity = {\n      user_id: config.user_id,\n      display_name: config.display_name || config.user_id,\n      team_id: config.team_id,\n      machine_id: machineId,\n      source: 'config',\n      anonymous_id: generateAnonymousId(config.user_id),\n      email: config.user_id.includes('@') ? config.user_id : undefined,\n    };\n    logHook('user-identity', `Resolved from config: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 2. Try git config\n  const git = getGitIdentity(dir);\n  if (git.email) {\n    cachedIdentity = {\n      user_id: git.email,\n      display_name: git.name || git.email.split('@')[0],\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'git',\n      anonymous_id: generateAnonymousId(git.email),\n      email: git.email,\n    };\n    logHook('user-identity', `Resolved from git: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 3. Try environment\n  const env = getEnvIdentity();\n  if (env.username) {\n    const userId = `${env.username}@${machineId}`;\n    cachedIdentity = {\n      user_id: userId,\n      display_name: env.username,\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'env',\n      anonymous_id: generateAnonymousId(userId),\n    };\n    logHook('user-identity', `Resolved from env: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 4. Anonymous fallback\n  const anonId = generateAnonymousId(machineId + process.pid);\n  cachedIdentity = {\n    user_id: `anon-${anonId.slice(0, 8)}`,\n    display_name: 'Anonymous',\n    team_id: config?.team_id,\n    machine_id: machineId,\n    source: 'anonymous',\n    anonymous_id: anonId,\n  };\n  logHook('user-identity', `Resolved as anonymous: ${cachedIdentity.anonymous_id}`, 'debug');\n  return cachedIdentity;\n}\n\n// =============================================================================\n// PRIVACY SETTINGS\n// =============================================================================\n\n/**\n * Get user's privacy settings\n */\nexport function getPrivacySettings(projectDir?: string): PrivacySettings {\n  if (cachedPrivacy) {\n    return cachedPrivacy;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const config = readUserConfig(dir);\n\n  cachedPrivacy = {\n    ...DEFAULT_PRIVACY,\n    ...config?.privacy,\n  };\n\n  return cachedPrivacy;\n}\n\n/**\n * Check if user allows sharing a specific type of data\n */\nexport function canShare(\n  dataType: 'decisions' | 'preferences' | 'skill_usage' | 'prompts',\n  scope: 'team' | 'global'\n): boolean {\n  const privacy = getPrivacySettings();\n\n  // Check scope permission first\n  if (scope === 'team' && !privacy.share_with_team) return false;\n  if (scope === 'global' && !privacy.share_globally) return false;\n\n  // Check data type permission\n  switch (dataType) {\n    case 'decisions':\n      return privacy.share_decisions;\n    case 'preferences':\n      return privacy.share_preferences;\n    case 'skill_usage':\n      return privacy.share_skill_usage;\n    case 'prompts':\n      return privacy.share_prompts;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get user ID for sharing (applies anonymization if needed)\n */\nexport function getUserIdForScope(scope: 'local' | 'team' | 'global'): string {\n  const identity = resolveUserIdentity();\n  const privacy = getPrivacySettings();\n\n  if (scope === 'global' && privacy.anonymize_globally) {\n    return identity.anonymous_id;\n  }\n\n  return identity.user_id;\n}\n\n// =============================================================================\n// IDENTITY PERSISTENCE\n// =============================================================================\n\n/**\n * Save user identity config (creates or updates)\n */\nexport function saveUserIdentityConfig(\n  config: UserIdentityConfig,\n  projectDir?: string\n): boolean {\n  const dir = projectDir || getProjectDir();\n  const configPath = `${dir}/${IDENTITY_CONFIG_FILE}`;\n  const configDir = `${dir}/.claude`;\n\n  try {\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n    // Clear cache to pick up new config\n    clearIdentityCache();\n\n    logHook('user-identity', `Saved identity config to ${configPath}`, 'info');\n    return true;\n  } catch (error) {\n    logHook('user-identity', `Failed to save identity config: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// CONTEXT HELPERS\n// =============================================================================\n\n/**\n * Get full identity context for session events\n */\nexport interface IdentityContext {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  machine_id: string;\n  identity_source: IdentitySource;\n  timestamp: string;\n}\n\n/**\n * Get identity context for tagging events\n */\nexport function getIdentityContext(): IdentityContext {\n  const identity = resolveUserIdentity();\n\n  return {\n    session_id: getSessionId(),\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    machine_id: identity.machine_id,\n    identity_source: identity.source,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Get project-scoped user ID for memory storage\n * Format: {project}-{scope} (e.g., \"my-app-decisions\")\n */\nexport function getProjectUserId(scope: string): string {\n  const projectDir = getProjectDir();\n  // Use path.basename for cross-platform compatibility (Windows uses \\ not /)\n  const projectName = basename(projectDir) || 'unknown';\n  const sanitized = projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  return `${sanitized}-${scope}`;\n}\n\n/**\n * Get user-scoped ID for memory storage\n * Format: {user_id}-{scope} (e.g., \"alice@company.com-preferences\")\n */\nexport function getUserScopedId(scope: string): string {\n  const identity = resolveUserIdentity();\n  const sanitizedUserId = identity.user_id.toLowerCase().replace(/[^a-z0-9@.-]/g, '-');\n  return `${sanitizedUserId}-${scope}`;\n}\n\n/**\n * Get global scope ID (for cross-project best practices)\n */\nexport function getGlobalScopeId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n", "/**\n * Session Tracking Hook\n * Issue #245: Multi-User Intelligent Decision Capture System\n * Phase 5: Session Lifecycle Tracking\n *\n * Tracks session start event with context (project, branch, time).\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { trackSessionStart } from '../lib/session-tracker.js';\nimport { execSync } from 'node:child_process';\n\n/**\n * Get current git branch name\n */\nfunction getGitBranch(projectDir: string): string | undefined {\n  try {\n    const branch = execSync('git rev-parse --abbrev-ref HEAD', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    return branch || undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Track session start event with context\n */\nexport function sessionTracking(input: HookInput): HookResult {\n  try {\n    const projectDir = input.project_dir || getProjectDir();\n    const gitBranch = getGitBranch(projectDir);\n\n    trackSessionStart({\n      project_dir: projectDir,\n      git_branch: gitBranch,\n      added_dirs_count: (input.added_dirs ?? []).length,\n    });\n\n    logHook('session-tracking', `Tracked session start: branch=${gitBranch || 'unknown'}`, 'debug');\n    return outputSilentSuccess();\n  } catch (error) {\n    logHook('session-tracking', `Error: ${error}`, 'warn');\n    return outputSilentSuccess();\n  }\n}\n", "/**\n * Session Metrics Summary - Shows summary at session end\n * Hook: SessionEnd\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, outputSilentSuccess } from '../lib/common.js';\nimport { getMetricsFile } from '../lib/paths.js';\n\ninterface SessionMetrics {\n  tools?: Record<string, number>;\n  errors?: number;\n}\n\n/**\n * Session metrics summary hook\n */\nexport function sessionMetricsSummary(_input: HookInput): HookResult {\n  logHook('session-metrics-summary', 'Session ending - generating summary');\n\n  const metricsFile = getMetricsFile();\n\n  if (!existsSync(metricsFile)) {\n    logHook('session-metrics-summary', 'No metrics file found');\n    return outputSilentSuccess();\n  }\n\n  try {\n    const metrics: SessionMetrics = JSON.parse(readFileSync(metricsFile, 'utf-8'));\n    const tools = metrics.tools || {};\n    const errors = metrics.errors || 0;\n\n    // Calculate total tool calls\n    const totalTools = Object.values(tools).reduce((sum, count) => sum + count, 0);\n\n    // Get top 3 tools\n    const topTools = Object.entries(tools)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3)\n      .map(([tool, count]) => `${tool}: ${count}`)\n      .join(', ');\n\n    logHook('session-metrics-summary', `Session stats: ${totalTools} tool calls, ${errors} errors`);\n\n    if (totalTools > 0) {\n      // Note: We return silently since SessionEnd hooks typically don't need system messages\n      // The logging is sufficient for audit purposes\n      logHook('session-metrics-summary', `Top tools: ${topTools}`);\n    }\n  } catch (err) {\n    logHook('session-metrics-summary', `Failed to read metrics: ${err}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Dependency Version Check - Check for outdated dependencies at session start\n * Hook: SessionStart (#136)\n * CC 2.1.7 Compliant\n * Optimized with timeout, caching, and fast-exit to prevent startup hangs\n *\n * Parses:\n * - package.json (Node.js)\n * - requirements.txt, pyproject.toml (Python)\n * - go.mod (Go)\n *\n * Warns about:\n * - Known security vulnerabilities (CVE database)\n * - Severely outdated packages\n * - Deprecated packages\n *\n * Uses additionalContext to inject warnings into session context\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess, outputWithContext } from '../lib/common.js';\n\ninterface KnownVuln {\n  package: string;\n  pattern: string;\n  severity: string;\n  cve: string;\n  description: string;\n}\n\ninterface DependencyCache {\n  warnings: string;\n  timestamp: number;\n}\n\ninterface PackageJson {\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n}\n\n// Known vulnerabilities database (static for offline operation)\nconst KNOWN_VULNS: KnownVuln[] = [\n  { package: 'lodash', pattern: '<4.17.21', severity: 'high', cve: 'CVE-2021-23337', description: 'Prototype pollution' },\n  { package: 'minimist', pattern: '<1.2.6', severity: 'critical', cve: 'CVE-2021-44906', description: 'Prototype pollution' },\n  { package: 'node-fetch', pattern: '<2.6.7', severity: 'high', cve: 'CVE-2022-0235', description: 'Information exposure' },\n  { package: 'axios', pattern: '<0.21.2', severity: 'high', cve: 'CVE-2021-3749', description: 'ReDoS vulnerability' },\n  { package: 'jsonwebtoken', pattern: '<9.0.0', severity: 'critical', cve: 'CVE-2022-23529', description: 'Insecure token verification' },\n  { package: 'express', pattern: '<4.17.3', severity: 'medium', cve: 'CVE-2022-24999', description: 'Open redirect' },\n  { package: 'tar', pattern: '<6.1.11', severity: 'critical', cve: 'CVE-2021-37701', description: 'Arbitrary file overwrite' },\n  { package: 'path-parse', pattern: '<1.0.7', severity: 'medium', cve: 'CVE-2021-23343', description: 'ReDoS vulnerability' },\n  { package: 'django', pattern: '<3.2.14', severity: 'high', cve: 'CVE-2022-34265', description: 'SQL injection' },\n  { package: 'flask', pattern: '<2.0.2', severity: 'medium', cve: 'CVE-2021-28091', description: 'Path traversal' },\n  { package: 'requests', pattern: '<2.28.0', severity: 'medium', cve: 'CVE-2023-32681', description: 'Information disclosure' },\n  { package: 'urllib3', pattern: '<1.26.5', severity: 'high', cve: 'CVE-2021-33503', description: 'ReDoS vulnerability' },\n  { package: 'pillow', pattern: '<9.0.0', severity: 'high', cve: 'CVE-2022-22817', description: 'Buffer overflow' },\n  { package: 'pyyaml', pattern: '<5.4', severity: 'critical', cve: 'CVE-2020-14343', description: 'Arbitrary code execution' },\n  { package: 'jinja2', pattern: '<3.0.3', severity: 'medium', cve: 'CVE-2020-28493', description: 'XSS vulnerability' },\n  { package: 'sqlalchemy', pattern: '<1.4.46', severity: 'medium', cve: 'CVE-2023-30533', description: 'SQL injection' },\n];\n\nconst CACHE_TTL_HOURS = 24;\n\n/**\n * Check if slow hooks should be skipped\n */\nfunction shouldSkipSlowHooks(): boolean {\n  return process.env.ORCHESTKIT_SKIP_SLOW_HOOKS === '1';\n}\n\n/**\n * Compare semantic versions (simplified)\n */\nfunction versionLessThan(current: string, target: string): boolean {\n  const currentParts = current.split('.').map((p) => parseInt(p, 10) || 0);\n  const targetParts = target.split('.').map((p) => parseInt(p, 10) || 0);\n\n  for (let i = 0; i < Math.max(currentParts.length, targetParts.length); i++) {\n    const c = currentParts[i] || 0;\n    const t = targetParts[i] || 0;\n    if (c < t) return true;\n    if (c > t) return false;\n  }\n  return false;\n}\n\n/**\n * Check if version matches vulnerability pattern\n */\nfunction versionMatchesVuln(currentVersion: string, vulnPattern: string): boolean {\n  const operator = vulnPattern.charAt(0);\n  const vulnVersion = vulnPattern.substring(1);\n\n  if (operator === '<') {\n    return versionLessThan(currentVersion, vulnVersion);\n  } else if (operator === '=') {\n    return currentVersion === vulnVersion;\n  }\n\n  return false;\n}\n\n/**\n * Clean version string (remove ^, ~, etc.)\n */\nfunction cleanVersion(version: string): string {\n  return version\n    .replace(/^[^~>=<]/, '')\n    .replace(/,.*$/, '')\n    .trim();\n}\n\n/**\n * Check a package against known vulnerabilities\n */\nfunction checkPackageVulnerability(packageName: string, version: string): KnownVuln | null {\n  const cleanedVersion = cleanVersion(version);\n  const pkgLower = packageName.toLowerCase();\n\n  for (const vuln of KNOWN_VULNS) {\n    if (pkgLower === vuln.package) {\n      if (versionMatchesVuln(cleanedVersion, vuln.pattern)) {\n        return vuln;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Check if cache is valid\n */\nfunction getCachedWarnings(cacheFile: string): string | null {\n  if (!existsSync(cacheFile)) {\n    return null;\n  }\n\n  try {\n    const cache: DependencyCache = JSON.parse(readFileSync(cacheFile, 'utf-8'));\n    const cacheAge = (Date.now() - cache.timestamp) / (1000 * 60 * 60);\n\n    if (cacheAge < CACHE_TTL_HOURS) {\n      return cache.warnings;\n    }\n  } catch {\n    // Cache invalid\n  }\n\n  return null;\n}\n\n/**\n * Save warnings to cache\n */\nfunction saveCache(cacheFile: string, warnings: string): void {\n  try {\n    mkdirSync(cacheFile.replace(/\\/[^/]+$/, ''), { recursive: true });\n\n    const cache: DependencyCache = {\n      warnings,\n      timestamp: Date.now(),\n    };\n\n    writeFileSync(cacheFile, JSON.stringify(cache, null, 2));\n  } catch {\n    // Ignore cache write errors\n  }\n}\n\n/**\n * Parse package.json for vulnerabilities\n */\nfunction parsePackageJson(filePath: string): { criticalCount: number; highCount: number; warnings: string } {\n  let criticalCount = 0;\n  let highCount = 0;\n  let warnings = '';\n\n  if (!existsSync(filePath)) {\n    return { criticalCount, highCount, warnings };\n  }\n\n  try {\n    const pkg: PackageJson = JSON.parse(readFileSync(filePath, 'utf-8'));\n    const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };\n\n    for (const [packageName, version] of Object.entries(allDeps)) {\n      const vuln = checkPackageVulnerability(packageName, version);\n      if (vuln) {\n        if (vuln.severity === 'critical') criticalCount++;\n        if (vuln.severity === 'high') highCount++;\n        warnings += `\\n- ${packageName}@${version}: ${vuln.description} (${vuln.cve}, ${vuln.severity}) - upgrade to ${vuln.pattern}`;\n      }\n    }\n  } catch {\n    // Ignore parse errors\n  }\n\n  return { criticalCount, highCount, warnings };\n}\n\n/**\n * Parse requirements.txt for vulnerabilities\n */\nfunction parseRequirementsTxt(filePath: string): { criticalCount: number; highCount: number; warnings: string } {\n  let criticalCount = 0;\n  let highCount = 0;\n  let warnings = '';\n\n  if (!existsSync(filePath)) {\n    return { criticalCount, highCount, warnings };\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    const lines = content.split('\\n');\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed || trimmed.startsWith('#')) continue;\n\n      // Parse package==version or package>=version\n      const match = trimmed.match(/^([a-zA-Z0-9_-]+)(?:==|>=|~=|!=|<|>)\\s*([0-9.]+)/);\n      if (!match) continue;\n\n      const [, packageName, version] = match;\n      const vuln = checkPackageVulnerability(packageName, version);\n      if (vuln) {\n        if (vuln.severity === 'critical') criticalCount++;\n        if (vuln.severity === 'high') highCount++;\n        warnings += `\\n- ${packageName}==${version}: ${vuln.description} (${vuln.cve}, ${vuln.severity}) - upgrade to ${vuln.pattern}`;\n      }\n    }\n  } catch {\n    // Ignore parse errors\n  }\n\n  return { criticalCount, highCount, warnings };\n}\n\n/**\n * Dependency version check hook\n */\nexport function dependencyVersionCheck(input: HookInput): HookResult {\n  // Bypass if slow hooks are disabled\n  if (shouldSkipSlowHooks()) {\n    logHook('dependency-version-check', 'Skipping dependency check (ORCHESTKIT_SKIP_SLOW_HOOKS=1)');\n    return outputSilentSuccess();\n  }\n\n  logHook('dependency-version-check', 'Starting dependency version check');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const cacheFile = `${projectDir}/.claude/feedback/dependency-check-cache.json`;\n\n  // Fast exit: Check if any package files exist\n  const hasPackageJson = existsSync(`${projectDir}/package.json`);\n  const hasRequirementsTxt = existsSync(`${projectDir}/requirements.txt`);\n  const hasPyprojectToml = existsSync(`${projectDir}/pyproject.toml`);\n  const hasGoMod = existsSync(`${projectDir}/go.mod`);\n\n  if (!hasPackageJson && !hasRequirementsTxt && !hasPyprojectToml && !hasGoMod) {\n    logHook('dependency-version-check', 'No package files found, skipping check');\n    saveCache(cacheFile, 'none');\n    return outputSilentSuccess();\n  }\n\n  // Check cache first\n  const cached = getCachedWarnings(cacheFile);\n  if (cached !== null) {\n    logHook('dependency-version-check', 'Using cached dependency warnings');\n    if (cached !== 'none') {\n      return outputWithContext(`DEPENDENCY SECURITY CHECK (cached): ${cached}`);\n    }\n    return outputSilentSuccess();\n  }\n\n  let totalCritical = 0;\n  let totalHigh = 0;\n  let allWarnings = '';\n\n  // Check package.json\n  if (hasPackageJson) {\n    const result = parsePackageJson(`${projectDir}/package.json`);\n    totalCritical += result.criticalCount;\n    totalHigh += result.highCount;\n    if (result.warnings) {\n      allWarnings += `\\n\\nNode.js (package.json):${result.warnings}`;\n    }\n  }\n\n  // Check requirements.txt\n  if (hasRequirementsTxt) {\n    const result = parseRequirementsTxt(`${projectDir}/requirements.txt`);\n    totalCritical += result.criticalCount;\n    totalHigh += result.highCount;\n    if (result.warnings) {\n      allWarnings += `\\n\\nPython (requirements.txt):${result.warnings}`;\n    }\n  }\n\n  // Generate output\n  if (allWarnings) {\n    const summary = `Found ${totalCritical} critical and ${totalHigh} high severity vulnerabilities`;\n    const fullWarning = `DEPENDENCY SECURITY CHECK: ${summary}${allWarnings}\\n\\nRun 'npm audit' or 'pip-audit' for full details.`;\n\n    saveCache(cacheFile, fullWarning);\n    logHook('dependency-version-check', summary);\n\n    // Only show warning if there are critical or high severity issues\n    if (totalCritical > 0 || totalHigh > 0) {\n      return outputWithContext(fullWarning);\n    }\n  } else {\n    saveCache(cacheFile, 'none');\n    logHook('dependency-version-check', 'No known vulnerabilities found');\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Memory Usage Metrics - Collect and persist memory system metrics\n *\n * Collects metrics from graph memory tier and CC Native MEMORY.md.\n */\n\nimport { existsSync, readFileSync, mkdirSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { join, dirname } from 'node:path';\nimport { getProjectDir, logHook } from './common.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface CategoryCount {\n  [category: string]: number;\n}\n\nexport interface TypeCount {\n  [type: string]: number;\n}\n\nexport interface MemoryMetrics {\n  timestamp: string;\n  decisions: {\n    total: number;\n    byCategory: CategoryCount;\n    byType: TypeCount;\n  };\n  queues: {\n    graphQueueDepth: number;\n  };\n  completedFlows: number;\n  sessionCount: number;\n}\n\n// =============================================================================\n// METRIC COLLECTION\n// =============================================================================\n\n/**\n * Count lines in a JSONL file\n */\nfunction countJsonlLines(filePath: string): number {\n  if (!existsSync(filePath)) return 0;\n  try {\n    const content = readFileSync(filePath, 'utf8');\n    return content.trim().split('\\n').filter(line => line.trim()).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Parse JSONL file and count by field values\n */\nfunction _countByField(filePath: string, field: string): Record<string, number> {\n  const counts: Record<string, number> = {};\n\n  if (!existsSync(filePath)) return counts;\n\n  try {\n    const content = readFileSync(filePath, 'utf8');\n    const lines = content.trim().split('\\n').filter(line => line.trim());\n\n    for (const line of lines) {\n      try {\n        const record = JSON.parse(line);\n        // Support nested fields like \"metadata.category\"\n        const value = field.includes('.')\n          ? field.split('.').reduce((obj, key) => obj?.[key], record)\n          : record[field];\n        if (value && typeof value === 'string') {\n          counts[value] = (counts[value] || 0) + 1;\n        }\n      } catch {\n        // Skip corrupt lines\n      }\n    }\n  } catch {\n    // File read error\n  }\n\n  return counts;\n}\n\n/**\n * Count sessions from analytics log\n */\nfunction countSessions(analyticsPath: string): number {\n  if (!existsSync(analyticsPath)) return 0;\n\n  try {\n    const content = readFileSync(analyticsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(line => line.trim());\n    let count = 0;\n\n    for (const line of lines) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.event === 'session_start') count++;\n      } catch {\n        // Skip corrupt lines\n      }\n    }\n\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Collect comprehensive memory metrics\n */\nexport function collectMemoryMetrics(projectDir?: string): MemoryMetrics {\n  const dir = projectDir || getProjectDir();\n  const memoryDir = join(dir, '.claude', 'memory');\n  const logsDir = join(dir, '.claude', 'logs');\n\n  const graphQueuePath = join(memoryDir, 'graph-queue.jsonl');\n  const completedFlowsPath = join(memoryDir, 'completed-flows.jsonl');\n  const analyticsPath = join(logsDir, 'analytics.jsonl');\n\n  return {\n    timestamp: new Date().toISOString(),\n    decisions: {\n      total: 0,\n      byCategory: {},\n      byType: {},\n    },\n    queues: {\n      graphQueueDepth: countJsonlLines(graphQueuePath),\n    },\n    completedFlows: countJsonlLines(completedFlowsPath),\n    sessionCount: countSessions(analyticsPath),\n  };\n}\n\n/**\n * Append a timestamped metric snapshot to the metrics log\n */\nexport function appendMetricSnapshot(projectDir?: string, metrics?: MemoryMetrics): void {\n  const dir = projectDir || getProjectDir();\n  const metricsPath = join(dir, '.claude', 'logs', 'memory-metrics.jsonl');\n\n  const snapshot = metrics || collectMemoryMetrics(dir);\n\n  try {\n    const metricsDir = dirname(metricsPath);\n    if (!existsSync(metricsDir)) {\n      mkdirSync(metricsDir, { recursive: true });\n    }\n    bufferWrite(metricsPath, `${JSON.stringify(snapshot)}\\n`);\n    logHook('memory-metrics', `Metrics snapshot appended: ${snapshot.decisions.total} decisions`, 'debug');\n  } catch (error) {\n    logHook('memory-metrics', `Failed to write metrics: ${error}`, 'warn');\n  }\n}\n", "/**\n * Memory Metrics Collector - Collect memory usage metrics at session start\n *\n * Runs in the SessionStart dispatcher to snapshot memory system state.\n * Works for all users with local memory files.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { getProjectDir, logHook, outputSilentSuccess } from '../lib/common.js';\nimport { collectMemoryMetrics, appendMetricSnapshot } from '../lib/memory-metrics.js';\n\n/**\n * Collect and persist memory metrics\n */\nexport function memoryMetricsCollector(input: HookInput): HookResult {\n  logHook('memory-metrics-collector', 'Collecting memory metrics');\n\n  try {\n    const projectDir = input.project_dir || getProjectDir();\n    const metrics = collectMemoryMetrics(projectDir);\n    appendMetricSnapshot(projectDir, metrics);\n  } catch (error) {\n    logHook('memory-metrics-collector', `Failed to collect metrics: ${error}`, 'warn');\n  }\n\n  return outputSilentSuccess();\n}\n\nexport default memoryMetricsCollector;\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-09\n\n/**\n * Stale Team Cleanup \u2014 SessionStart Hook\n * Issue #447: Remove orphaned team directories from crashed/interrupted sessions\n */\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, outputSilentSuccess } from '../lib/common.js';\nimport { listAllTeams, isStaleTeam, cleanupTeam } from '../lib/agent-teams.js';\n\nconst MAX_AGE_HOURS = 4;\n\nexport function staleTeamCleanup(_input: HookInput): HookResult {\n  const teams = listAllTeams();\n  if (teams.length === 0) return outputSilentSuccess();\n\n  let cleaned = 0;\n  for (const name of teams) {\n    if (isStaleTeam(name, MAX_AGE_HOURS)) {\n      if (cleanupTeam(name)) cleaned++;\n      else logHook('stale-team-cleanup', `Failed to clean team \"${name}\"`);\n    }\n  }\n\n  if (cleaned > 0) {\n    logHook('stale-team-cleanup', `Cleaned ${cleaned} stale team(s)`);\n  }\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-14\n\n/**\n * Type Error Cache Population Hook\n * Issue #304: [P0-B] Type error cache population\n *\n * Runs `tsc --noEmit` on SessionStart and caches results so agents\n * know about existing type errors before making edits.\n * Prevents 30-40% of failed edit attempts by surfacing existing errors.\n *\n * Runs inside the unified-dispatcher (async, fire-and-forget).\n */\n\nimport { execSync } from 'node:child_process';\nimport { writeFileSync, mkdirSync, existsSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\n\ninterface TypeErrorEntry {\n  file: string;\n  line: number;\n  column: number;\n  code: string;\n  message: string;\n}\n\ninterface TypeErrorCache {\n  timestamp: number;\n  errorCount: number;\n  errors: TypeErrorEntry[];\n  summary: string;\n}\n\nconst TSC_TIMEOUT_MS = 15_000;\n\n/**\n * Parse tsc output into structured error entries.\n * Format: \"src/file.ts(10,5): error TS2345: ...\"\n */\nfunction parseTscOutput(output: string): TypeErrorEntry[] {\n  const errors: TypeErrorEntry[] = [];\n  const errorRegex = /^(.+?)\\((\\d+),(\\d+)\\):\\s+error\\s+(TS\\d+):\\s+(.+)$/gm;\n\n  for (const match of output.matchAll(errorRegex)) {\n    errors.push({\n      file: match[1],\n      line: parseInt(match[2], 10),\n      column: parseInt(match[3], 10),\n      code: match[4],\n      message: match[5],\n    });\n  }\n\n  return errors;\n}\n\n/**\n * Get the cache file path for the current session.\n */\nfunction getCacheFilePath(sessionId: string): string {\n  const cacheDir = join(getProjectDir(), '.claude', 'cache');\n  if (!existsSync(cacheDir)) {\n    mkdirSync(cacheDir, { recursive: true });\n  }\n  return join(cacheDir, `type-errors-${sessionId}.json`);\n}\n\n/**\n * Detect if the project uses TypeScript by checking for tsconfig.json.\n */\nfunction hasTypeScript(projectDir: string): boolean {\n  return existsSync(join(projectDir, 'tsconfig.json'));\n}\n\n/**\n * Type error indexer \u2014 runs tsc --noEmit and caches results.\n */\nexport function typeErrorIndexer(input: HookInput): HookResult {\n  const projectDir = input.project_dir || getProjectDir();\n\n  if (!hasTypeScript(projectDir)) {\n    logHook('type-error-indexer', 'No tsconfig.json found, skipping');\n    return outputSilentSuccess();\n  }\n\n  const sessionId = input.session_id || 'unknown';\n\n  try {\n    // Run tsc --noEmit with timeout\n    execSync('npx tsc --noEmit 2>&1', {\n      cwd: projectDir,\n      timeout: TSC_TIMEOUT_MS,\n      encoding: 'utf-8',\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    // No errors \u2014 write empty cache\n    const cache: TypeErrorCache = {\n      timestamp: performance.timeOrigin + performance.now(),\n      errorCount: 0,\n      errors: [],\n      summary: 'No type errors found',\n    };\n    writeFileSync(getCacheFilePath(sessionId), JSON.stringify(cache, null, 2));\n    logHook('type-error-indexer', 'No type errors found');\n  } catch (err: unknown) {\n    const execErr = err as { stdout?: string; stderr?: string; killed?: boolean; status?: number };\n\n    if (execErr.killed) {\n      logHook('type-error-indexer', `tsc timed out after ${TSC_TIMEOUT_MS}ms`, 'warn');\n      return outputSilentSuccess();\n    }\n\n    // tsc exits non-zero when there are errors \u2014 parse them\n    const output = (execErr.stdout || '') + (execErr.stderr || '');\n    const errors = parseTscOutput(output);\n\n    if (errors.length === 0) {\n      logHook('type-error-indexer', 'tsc failed but no parseable errors', 'warn');\n      return outputSilentSuccess();\n    }\n\n    // Dedupe by file and group\n    const fileSet = new Set(errors.map(e => e.file));\n    const summary = `${errors.length} type error${errors.length !== 1 ? 's' : ''} in ${fileSet.size} file${fileSet.size !== 1 ? 's' : ''}`;\n\n    const cache: TypeErrorCache = {\n      timestamp: performance.timeOrigin + performance.now(),\n      errorCount: errors.length,\n      errors: errors.slice(0, 50), // Cap at 50 to avoid huge cache files\n      summary,\n    };\n\n    writeFileSync(getCacheFilePath(sessionId), JSON.stringify(cache, null, 2));\n    logHook('type-error-indexer', `Cached: ${summary}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Unified SessionStart Dispatcher\n * Issue #235: Hook Architecture Refactor\n * Issue #239: Move initialization hooks to Setup event\n *\n * Consolidates session-specific async hooks into a single dispatcher.\n * Reduces \"Async hook SessionStart completed\" messages.\n *\n * Note: One-time initialization hooks (dependency-version-check)\n * moved to Setup dispatcher in Issue #239 - they only need to run once at plugin load.\n *\n * CC 2.1.19 Compliant: Single async hook with internal routing\n *\n * NOTE: Async hooks are fire-and-forget by design. They can only return\n * { async: true, asyncTimeout } - fields like systemMessage, continue,\n * decision are NOT processed by Claude Code for async hooks.\n * Failures are logged to file but not surfaced to users.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\n// Import session-specific hook implementations\n// Note: dependency-version-check moved to setup/unified-dispatcher.ts (Issue #239)\nimport { patternSyncPull } from './pattern-sync-pull.js';\nimport { sessionEnvSetup } from './session-env-setup.js';\nimport { sessionTracking } from './session-tracking.js';\nimport { memoryMetricsCollector } from './memory-metrics-collector.js';\nimport { staleTeamCleanup } from './stale-team-cleanup.js';\nimport { typeErrorIndexer } from './type-error-indexer.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult | Promise<HookResult>;\n\ninterface HookConfig {\n  name: string;\n  fn: HookFn;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Registry\n// -----------------------------------------------------------------------------\n\n/**\n * Registry of session-specific async SessionStart hooks\n * One-time initialization hooks moved to Setup dispatcher (Issue #239)\n */\nconst HOOKS: HookConfig[] = [\n  { name: 'pattern-sync-pull', fn: patternSyncPull },\n  { name: 'session-env-setup', fn: sessionEnvSetup },\n  { name: 'session-tracking', fn: sessionTracking },\n  { name: 'memory-metrics-collector', fn: memoryMetricsCollector },\n  { name: 'stale-team-cleanup', fn: staleTeamCleanup },\n  { name: 'type-error-indexer', fn: typeErrorIndexer },\n];\n\n/** Exposed for registry wiring tests */\nexport const registeredHookNames = () => HOOKS.map(h => h.name);\n\n// -----------------------------------------------------------------------------\n// Dispatcher Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Unified dispatcher that runs all SessionStart hooks in parallel\n */\nexport async function unifiedSessionStartDispatcher(input: HookInput): Promise<HookResult> {\n  // Run all hooks in parallel\n  const results = await Promise.allSettled(\n    HOOKS.map(async hook => {\n      try {\n        const result = hook.fn(input);\n        if (result instanceof Promise) {\n          await result;\n        }\n        return { hook: hook.name, status: 'success' };\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        logHook('session-start-dispatcher', `${hook.name} failed: ${message}`);\n        return { hook: hook.name, status: 'error', message };\n      }\n    })\n  );\n\n  // Count failures for logging (async hooks can't report to users)\n  const failures: string[] = [];\n\n  for (const result of results) {\n    if (result.status === 'rejected') {\n      failures.push('unknown');\n    } else if (result.value.status === 'error') {\n      failures.push(result.value.hook);\n    }\n  }\n\n  // Log failures (async hooks are fire-and-forget - can't surface to users)\n  if (failures.length > 0) {\n    logHook('session-start-dispatcher', `${failures.length}/${HOOKS.length} hooks failed: ${failures.join(', ')}`);\n  }\n\n  // Async hooks always return silent success - CC ignores other fields\n  return outputSilentSuccess();\n}\n", "/**\n * PreCompact Saver \u2014 Compaction-Aware Memory Architecture\n * CC 2.1.25+: Preserves critical context before context compaction.\n *\n * Opus 4.6 Upgrade (Issue #332):\n * - Saves session state, decision logs, and memory tier data\n * - Writes high-confidence decisions to CC native MEMORY.md\n * - Preserves active task context for post-compaction recovery\n * - Tracks compaction frequency for budget optimization\n *\n * Version: 2.0.0\n */\n\nimport { writeFileSync, existsSync, readFileSync, mkdirSync, readdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getLogDir, getSessionId, getProjectDir } from '../lib/common.js';\n\ninterface PreservedContext {\n  branch?: string;\n  activeFiles?: string[];\n  sessionNotes?: string;\n  activeTasks?: string[];\n  decisionLog?: string[];\n  memoryTierSnapshot?: {\n    graphEntries?: number;\n    localEntries?: number;\n  };\n}\n\ninterface SessionState {\n  lastCompaction?: string;\n  compactionCount?: number;\n  avgCompactionIntervalMs?: number;\n  preservedContext?: PreservedContext;\n  compactionHistory?: Array<{\n    timestamp: string;\n    contextSizeEstimate?: number;\n  }>;\n}\n\nfunction getSessionStateFile(): string {\n  const logDir = getLogDir();\n  const stateDir = join(logDir, 'sessions');\n  if (!existsSync(stateDir)) {\n    mkdirSync(stateDir, { recursive: true });\n  }\n  return join(stateDir, `${getSessionId()}-state.json`);\n}\n\nfunction loadSessionState(stateFile: string): SessionState {\n  try {\n    if (existsSync(stateFile)) {\n      return JSON.parse(readFileSync(stateFile, 'utf8'));\n    }\n  } catch {\n    // Ignore parse errors\n  }\n  return {};\n}\n\n/**\n * Count entries in local memory JSONL files\n */\nfunction countLocalMemoryEntries(): number {\n  const memoryDir = join(getProjectDir(), '.claude', 'memory');\n  if (!existsSync(memoryDir)) return 0;\n\n  try {\n    const files = readdirSync(memoryDir).filter(f => f.endsWith('.jsonl'));\n    let count = 0;\n    for (const file of files) {\n      try {\n        const content = readFileSync(join(memoryDir, file), 'utf8');\n        count += content.trim().split('\\n').filter(Boolean).length;\n      } catch {\n        // Skip unreadable files\n      }\n    }\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Read recent decisions from decision log\n */\nfunction getRecentDecisions(): string[] {\n  const decisionFile = join(getProjectDir(), '.claude', 'logs', 'decisions.jsonl');\n  if (!existsSync(decisionFile)) return [];\n\n  try {\n    const content = readFileSync(decisionFile, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    // Get last 10 decisions\n    return lines.slice(-10).map(line => {\n      try {\n        const entry = JSON.parse(line);\n        return entry.summary || entry.decision || line;\n      } catch {\n        return line;\n      }\n    });\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Calculate average compaction interval from history\n */\nfunction calculateAvgInterval(history: Array<{ timestamp: string }>): number {\n  if (history.length < 2) return 0;\n  const intervals: number[] = [];\n  for (let i = 1; i < history.length; i++) {\n    const prev = new Date(history[i - 1].timestamp).getTime();\n    const curr = new Date(history[i].timestamp).getTime();\n    if (curr > prev) intervals.push(curr - prev);\n  }\n  if (intervals.length === 0) return 0;\n  return Math.round(intervals.reduce((a, b) => a + b, 0) / intervals.length);\n}\n\n/**\n * Get files recently modified in the working tree (likely being actively edited)\n */\nfunction getRecentlyEditedFiles(): string[] {\n  try {\n    const output = execSync('git diff --name-only HEAD 2>/dev/null', {\n      encoding: 'utf8',\n      timeout: 3000,\n      cwd: getProjectDir(),\n    });\n    return output.trim().split('\\n').filter(Boolean).slice(0, 20);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get in-progress tasks from task completions log (tasks started but not completed)\n */\nfunction getInProgressTasks(): string[] {\n  const logFile = join(getProjectDir(), '.claude', 'logs', 'task-completions.jsonl');\n  if (!existsSync(logFile)) return [];\n\n  try {\n    const content = readFileSync(logFile, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    // Get recent task subjects (last 5 completed tasks give context)\n    return lines.slice(-5).map(line => {\n      try {\n        const entry = JSON.parse(line);\n        return `${entry.task_subject} [${entry.task_status}]`;\n      } catch {\n        return '';\n      }\n    }).filter(Boolean);\n  } catch {\n    return [];\n  }\n}\n\nexport function preCompactSaver(_input: HookInput): HookResult {\n  try {\n    const stateFile = getSessionStateFile();\n    const state = loadSessionState(stateFile);\n    const now = new Date().toISOString();\n\n    // Update compaction metadata\n    state.lastCompaction = now;\n    state.compactionCount = (state.compactionCount || 0) + 1;\n\n    // Track compaction history (keep last 10)\n    if (!state.compactionHistory) state.compactionHistory = [];\n    state.compactionHistory.push({ timestamp: now });\n    if (state.compactionHistory.length > 10) {\n      state.compactionHistory = state.compactionHistory.slice(-10);\n    }\n\n    // Calculate average interval\n    state.avgCompactionIntervalMs = calculateAvgInterval(state.compactionHistory);\n\n    // Snapshot memory tier state\n    const localEntries = countLocalMemoryEntries();\n    const decisions = getRecentDecisions();\n\n    // Preserve rich context for post-compaction recovery\n    state.preservedContext = {\n      branch: process.env.ORCHESTKIT_BRANCH || process.env.GIT_BRANCH || undefined,\n      activeFiles: getRecentlyEditedFiles(),\n      activeTasks: getInProgressTasks(),\n      sessionNotes: `Compaction #${state.compactionCount} at ${now}`,\n      decisionLog: decisions,\n      memoryTierSnapshot: {\n        localEntries,\n      },\n    };\n\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n\n    // Also append to compaction log for cross-session analysis\n    const compactionLog = join(getLogDir(), 'compaction-history.jsonl');\n    try {\n      bufferWrite(compactionLog, `${JSON.stringify({\n        session: getSessionId(),\n        timestamp: now,\n        count: state.compactionCount,\n        avgIntervalMs: state.avgCompactionIntervalMs,\n        localMemoryEntries: localEntries,\n        decisionsPreserved: decisions.length,\n      })}\\n`);\n    } catch {\n      // Non-critical\n    }\n\n    logHook('pre-compact-saver',\n      `Saved state before compaction #${state.compactionCount} ` +\n      `(${localEntries} memory entries, ${decisions.length} decisions preserved)`\n    );\n  } catch (error) {\n    const msg = error instanceof Error ? error.message : String(error);\n    logHook('pre-compact-saver', `Failed to save state: ${msg}`, 'warn');\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Prefill Breaking Change Guard \u2014 SessionStart Hook\n * Opus 4.6 removed support for response prefilling (prefilled assistant\n * messages return 400 errors) and deprecated `output_format` in favor of\n * `output_config.format`. This hook scans for both patterns in skill\n * content and warns users proactively at session start.\n *\n * Addresses: Issue #325, #357\n * Version: 1.1.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, readdirSync, statSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getPluginRoot, outputSilentSuccess, outputWarning, lineContainsAllCI } from '../lib/common.js';\n\nconst CACHE_VERSION = '1.0';\n\ninterface PrefillScanCache {\n  version: string;\n  scannedAt: number;\n  results: {\n    warnings: string[];\n    count: number;\n  };\n}\n\nfunction getCacheFile(projectDir: string): string {\n  return `${projectDir}/.claude/cache/prefill-scan.json`;\n}\n\nfunction getSkillDirs(skillsDir: string): string[] {\n  if (!existsSync(skillsDir)) return [];\n  try {\n    return readdirSync(skillsDir).filter(d => {\n      try { return statSync(join(skillsDir, d)).isDirectory(); } catch { return false; }\n    });\n  } catch {\n    return [];\n  }\n}\n\nfunction isCacheFresh(cacheFile: string, skillsDir: string, skillDirs: string[]): boolean {\n  try {\n    if (!existsSync(cacheFile)) return false;\n    const cache: PrefillScanCache = JSON.parse(readFileSync(cacheFile, 'utf-8'));\n    if (cache.version !== CACHE_VERSION) return false;\n\n    const { scannedAt } = cache;\n    // Check if any SKILL.md is newer than the cache\n    for (const dir of skillDirs) {\n      const skillPath = join(skillsDir, dir, 'SKILL.md');\n      if (!existsSync(skillPath)) continue;\n      if (statSync(skillPath).mtimeMs > scannedAt) return false;\n    }\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nfunction readCache(cacheFile: string): PrefillScanCache | null {\n  try {\n    return JSON.parse(readFileSync(cacheFile, 'utf-8')) as PrefillScanCache;\n  } catch {\n    return null;\n  }\n}\n\nfunction writeCache(cacheFile: string, warnings: string[]): void {\n  try {\n    mkdirSync(dirname(cacheFile), { recursive: true });\n    const cache: PrefillScanCache = {\n      version: CACHE_VERSION,\n      scannedAt: Date.now(),\n      results: { warnings, count: warnings.length },\n    };\n    writeFileSync(cacheFile, JSON.stringify(cache, null, 2), 'utf-8');\n  } catch {\n    // Non-fatal \u2014 cache write failure is silently ignored\n  }\n}\n\n/** Patterns that indicate response prefilling usage */\nconst PREFILL_PATTERNS: Array<RegExp | ((s: string) => boolean)> = [\n  /\\bprefill\\b/i,\n  /\\bpre-fill\\b/i,\n  // ReDoS-safe: replace assistant.*content.*: with line-based includes\n  (s: string) => lineContainsAllCI(s, 'assistant', 'content', ':'),\n  /\\bprefilled?\\s+(assistant|response|message)/i,\n  // ReDoS-safe: replace role.*assistant.*content with line-based includes\n  (s: string) => lineContainsAllCI(s, 'role', 'assistant', 'content'),\n];\n\n/** Patterns that indicate deprecated output_format API parameter usage */\nconst OUTPUT_FORMAT_PATTERNS = [\n  /[\"']output_format[\"']\\s*:/,                    // JSON key \"output_format\":\n  /output_format\\s*=\\s*[\"']/,                     // Python kwarg output_format=\"...\"\n  /\\boutput_format\\b.*\\b(json|text|xml)\\b/i,      // output_format with format value\n];\n\n/**\n * Scan a file's content for prefilling patterns\n */\nfunction hasPrefillPatterns(content: string): boolean {\n  return PREFILL_PATTERNS.some(pattern =>\n    typeof pattern === 'function' ? pattern(content) : pattern.test(content)\n  );\n}\n\n/**\n * Scan a file's content for deprecated output_format patterns.\n * Excludes third-party API params (ElevenLabs, etc.) and Python function args.\n */\nfunction hasOutputFormatPatterns(content: string): boolean {\n  // Skip files that are clearly about third-party APIs\n  if (/elevenlabs|mp3_\\d+/i.test(content)) return false;\n  return OUTPUT_FORMAT_PATTERNS.some(pattern => pattern.test(content));\n}\n\n/**\n * Scan skills directory for files containing prefill patterns\n */\nfunction scanSkillsForPrefill(skillsDir: string, skillDirs: string[]): string[] {\n  const matches: string[] = [];\n\n  for (const dir of skillDirs) {\n    const skillPath = join(skillsDir, dir, 'SKILL.md');\n    if (!existsSync(skillPath)) continue;\n\n    try {\n      const content = readFileSync(skillPath, 'utf-8');\n      if (hasPrefillPatterns(content) || hasOutputFormatPatterns(content)) {\n        matches.push(dir);\n      }\n    } catch {\n      // Skip unreadable files\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Check if the current model is Opus 4.6+ (where prefilling is unsupported)\n */\nfunction isOpus46OrLater(): boolean {\n  const model = process.env.CLAUDE_MODEL || '';\n  // Match opus-4-6, opus-4-7, etc. or just \"opus\"\n  return /opus/i.test(model);\n}\n\n/**\n * Prefill guard hook \u2014 runs at SessionStart\n */\nexport function prefillGuard(_input: HookInput): HookResult {\n  // Only warn when running on Opus 4.6+\n  if (!isOpus46OrLater()) {\n    return outputSilentSuccess();\n  }\n\n  const pluginRoot = getPluginRoot();\n  const skillsDir = join(pluginRoot, 'skills');\n  const cacheFile = getCacheFile(pluginRoot);\n\n  const skillDirs = getSkillDirs(skillsDir);\n\n  let affectedSkills: string[];\n\n  try {\n    if (isCacheFresh(cacheFile, skillsDir, skillDirs)) {\n      const cache = readCache(cacheFile);\n      if (cache) {\n        logHook('prefill-guard', 'Using cached scan results');\n        affectedSkills = cache.results.warnings;\n      } else {\n        affectedSkills = scanSkillsForPrefill(skillsDir, skillDirs);\n        writeCache(cacheFile, affectedSkills);\n      }\n    } else {\n      affectedSkills = scanSkillsForPrefill(skillsDir, skillDirs);\n      writeCache(cacheFile, affectedSkills);\n    }\n  } catch {\n    // Fall back to full scan on any unexpected error\n    affectedSkills = scanSkillsForPrefill(skillsDir, skillDirs);\n  }\n\n  if (affectedSkills.length === 0) {\n    logHook('prefill-guard', 'No prefilling patterns detected in skills');\n    return outputSilentSuccess();\n  }\n\n  logHook('prefill-guard', `Found prefilling patterns in ${affectedSkills.length} skills: ${affectedSkills.join(', ')}`, 'warn');\n\n  return outputWarning(\n    `Opus 4.6 deprecation: ${affectedSkills.length} skill(s) reference deprecated patterns (prefilled assistant messages or output_format parameter). ` +\n    `Affected: ${affectedSkills.slice(0, 5).join(', ')}${affectedSkills.length > 5 ? '...' : ''}. ` +\n    `Migration: use structured outputs instead of prefilling; use output_config.format instead of output_format.`\n  );\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * MCP Health Check - Warn about misconfigured MCP servers at session start\n * Hook: SessionStart\n * CC 2.1.7 Compliant\n *\n * Checks .mcp.json for enabled MCPs and validates their requirements:\n * - tavily: TAVILY_API_KEY must be set\n * - agentation: agentation-mcp must be installed\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess, outputWithContext } from '../lib/common.js';\n\ninterface McpServerEntry {\n  disabled?: boolean;\n  command?: string;\n  args?: string[];\n  [key: string]: unknown;\n}\n\ninterface McpConfig {\n  mcpServers?: Record<string, McpServerEntry>;\n}\n\n/**\n * Check a single enabled MCP server for missing requirements.\n * Returns a warning string or null if the server is properly configured.\n */\nfunction checkServer(name: string, projectDir: string): string | null {\n  if (name === 'tavily' && !process.env.TAVILY_API_KEY) {\n    return `- tavily is enabled but TAVILY_API_KEY is not set\\n  Fix: export TAVILY_API_KEY=\"tvly-...\" in ~/.zshrc, then set \"disabled\": false in .mcp.json`;\n  }\n\n  if (name === 'agentation') {\n    const binExists = existsSync(join(projectDir, 'node_modules', '.bin', 'agentation-mcp'));\n    if (binExists) return null;\n    try {\n      const pkg = JSON.parse(readFileSync(join(projectDir, 'package.json'), 'utf-8'));\n      if ('agentation-mcp' in { ...pkg.dependencies, ...pkg.devDependencies }) return null;\n    } catch { /* no package.json */ }\n    return `- agentation is enabled but agentation-mcp is not installed\\n  Fix: npm install -D agentation-mcp  or  set \"disabled\": true in .mcp.json`;\n  }\n\n  return null;\n}\n\n/**\n * MCP health check hook\n */\nexport function mcpHealthCheck(input: HookInput): HookResult {\n  if (process.env.ORCHESTKIT_SKIP_SLOW_HOOKS === '1') {\n    logHook('mcp-health-check', 'Skipping MCP check (ORCHESTKIT_SKIP_SLOW_HOOKS=1)');\n    return outputSilentSuccess();\n  }\n\n  const projectDir = input.project_dir || getProjectDir();\n  const mcpJsonPath = join(projectDir, '.mcp.json');\n\n  if (!existsSync(mcpJsonPath)) {\n    logHook('mcp-health-check', 'No .mcp.json found, skipping');\n    return outputSilentSuccess();\n  }\n\n  let config: McpConfig;\n  try {\n    config = JSON.parse(readFileSync(mcpJsonPath, 'utf-8'));\n  } catch {\n    logHook('mcp-health-check', 'Failed to parse .mcp.json', 'warn');\n    return outputSilentSuccess();\n  }\n\n  const servers = config.mcpServers;\n  if (!servers || typeof servers !== 'object') return outputSilentSuccess();\n\n  const warnings: string[] = [];\n  for (const [name, entry] of Object.entries(servers)) {\n    if (entry.disabled === true) continue;\n    const warning = checkServer(name, projectDir);\n    if (warning) warnings.push(warning);\n  }\n\n  if (warnings.length > 0) {\n    const message = `MCP misconfiguration detected:\\n${warnings.join('\\n')}`;\n    logHook('mcp-health-check', message, 'warn');\n    return outputWithContext(message);\n  }\n\n  logHook('mcp-health-check', 'All enabled MCPs are properly configured');\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-06\n\n/**\n * Shared event logger for lifecycle hooks.\n * Writes structured JSONL entries to .claude/logs/<filename>.\n */\n\nimport { writeFileSync, mkdirSync, existsSync } from 'node:fs';\nimport { join, basename } from 'node:path';\nimport { getProjectDir } from './common.js';\n\n/**\n * Append a structured event to a JSONL log file.\n * Creates the logs directory if needed. Silently ignores write failures.\n */\nexport function appendEventLog(\n  filename: string,\n  entry: Record<string, unknown>,\n): void {\n  const projectDir = getProjectDir();\n  if (!projectDir) return;\n\n  const logsDir = join(projectDir, '.claude', 'logs');\n  if (!existsSync(logsDir)) {\n    mkdirSync(logsDir, { recursive: true });\n  }\n\n  try {\n    const logPath = join(logsDir, basename(filename));\n    writeFileSync(logPath, `${JSON.stringify(entry)}\\n`, { flag: 'a' });\n  } catch {\n    // Non-critical logging \u2014 don't block hook execution\n  }\n}\n", "/**\n * TeammateIdle Hook: Progress Reporter\n *\n * CC 2.1.33 TeammateIdle event fires when an agent teammate becomes idle.\n * Logs idle events for workflow analytics and suggests work redistribution.\n *\n * @hook TeammateIdle\n * @since CC 2.1.33\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { getProjectDir } from '../lib/common.js';\nimport { appendEventLog } from '../lib/event-logger.js';\nimport { appendAnalytics, hashProject, getTeamContext } from '../lib/analytics.js';\n\nexport async function progressReporter(input: HookInput): Promise<HookResult> {\n  if (!getProjectDir()) {\n    return { continue: true };\n  }\n\n  const teammateId = input.teammate_id || input.agent_id || 'unknown';\n  const teammateType = input.teammate_type || input.subagent_type || 'unknown';\n  const idleDuration = input.idle_duration_ms || 0;\n\n  appendEventLog('teammate-activity.jsonl', {\n    timestamp: new Date().toISOString(),\n    event: 'teammate_idle',\n    teammate_id: teammateId,\n    teammate_type: teammateType,\n    idle_duration_ms: idleDuration,\n    session_id: input.session_id,\n  });\n\n  // Cross-project team activity analytics (Issue #459)\n  appendAnalytics('team-activity.jsonl', {\n    ts: new Date().toISOString(),\n    pid: hashProject(process.env.CLAUDE_PROJECT_DIR || ''),\n    event: 'idle',\n    agent: teammateType,\n    idle_ms: idleDuration,\n    ...getTeamContext(),\n  });\n\n  // Surface long idle durations (>30s) as context for work reassignment\n  if (idleDuration > 30000) {\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        additionalContext: `Agent ${teammateType} (${teammateId}) idle for ${Math.round(idleDuration / 1000)}s. Consider reassigning pending work.`,\n      },\n    };\n  }\n\n  return { continue: true };\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-06\n\n/**\n * Team Synthesis Trigger - TeammateIdle Hook\n *\n * Detects when all teammates in a team are idle and suggests synthesis.\n * Reads team config for member list and teammate-activity.jsonl for recent idle events.\n *\n * @hook TeammateIdle\n * @since CC 2.1.33\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook, getProjectDir } from '../lib/common.js';\nimport { getTeamMembers, getTeamName } from '../lib/agent-teams.js';\n\n/** Window within which idle events are considered \"recent\" */\nconst IDLE_WINDOW_MS = 60_000;\n\nexport function teamSynthesisTrigger(input: HookInput): HookResult {\n  const teamName = getTeamName();\n  if (!teamName) {\n    return outputSilentSuccess();\n  }\n\n  const members = getTeamMembers();\n  if (members.length === 0) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n  if (!projectDir) {\n    return outputSilentSuccess();\n  }\n\n  // Read recent idle events from activity log\n  const logPath = join(projectDir, '.claude', 'logs', 'teammate-activity.jsonl');\n  if (!existsSync(logPath)) {\n    return outputSilentSuccess();\n  }\n\n  const cutoff = new Date(Date.now() - IDLE_WINDOW_MS).toISOString();\n  const idleMembers = new Set<string>();\n\n  try {\n    const content = readFileSync(logPath, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n\n    // Scan recent entries (last 50 to bound cost)\n    const recent = lines.slice(-50);\n    for (const line of recent) {\n      try {\n        const entry = JSON.parse(line);\n        if (\n          entry.event === 'teammate_idle' &&\n          entry.timestamp &&\n          entry.timestamp >= cutoff\n        ) {\n          const id = entry.teammate_id || entry.member_name || '';\n          if (id) idleMembers.add(id);\n        }\n      } catch {\n        // Skip invalid JSONL lines\n      }\n    }\n  } catch {\n    return outputSilentSuccess();\n  }\n\n  // Add current idle event's teammate\n  const currentTeammateId = input.teammate_id || input.agent_id || '';\n  if (currentTeammateId) {\n    idleMembers.add(currentTeammateId);\n  }\n\n  logHook(\n    'team-synthesis-trigger',\n    `Team \"${teamName}\": ${idleMembers.size}/${members.length} idle within ${IDLE_WINDOW_MS / 1000}s`,\n  );\n\n  // All members idle? Suggest synthesis\n  if (idleMembers.size >= members.length) {\n    return outputWithContext(\n      `All ${members.length} teammates in team \"${teamName}\" are idle. ` +\n      `Consider synthesizing results and shutting down the team.`,\n    );\n  }\n\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-06\n\n/**\n * Team Quality Gate - TeammateIdle Hook\n *\n * Aggregates quality signals from idle teammates.\n * Surfaces a warning only if a teammate goes idle without producing meaningful output\n * AND has no recent task completion signal.\n *\n * @hook TeammateIdle\n * @since CC 2.1.33\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook, getProjectDir } from '../lib/common.js';\nimport { getTeamName } from '../lib/agent-teams.js';\nimport { appendEventLog } from '../lib/event-logger.js';\n\n/** Window within which completions count as \"recent\" */\nconst COMPLETION_WINDOW_MS = 300_000;\n\n/** Minimum output length to consider as productive work */\nconst MEANINGFUL_OUTPUT_MIN_CHARS = 100;\n\n/**\n * Check if the teammate produced meaningful output (primary signal).\n * Uses last_assistant_message or agent_output from the hook input.\n */\nfunction hasProductiveOutput(input: HookInput): boolean {\n  const output = input.last_assistant_message || input.agent_output || input.output || '';\n  return output.length >= MEANINGFUL_OUTPUT_MIN_CHARS;\n}\n\n/**\n * Check task-completions.jsonl for recent completion events (secondary signal).\n * Gracefully returns false if the file doesn't exist or can't be read.\n */\nfunction hasRecentCompletion(projectDir: string): boolean {\n  const completionsPath = join(projectDir, '.claude', 'logs', 'task-completions.jsonl');\n\n  if (!existsSync(completionsPath)) {\n    return false;\n  }\n\n  const cutoff = new Date(Date.now() - COMPLETION_WINDOW_MS).toISOString();\n\n  try {\n    const content = readFileSync(completionsPath, 'utf-8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const recent = lines.slice(-30);\n\n    for (const line of recent) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.timestamp && entry.timestamp >= cutoff) {\n          return true;\n        }\n      } catch {\n        // Skip invalid lines\n      }\n    }\n  } catch {\n    // Non-critical \u2014 proceed without completion data\n  }\n\n  return false;\n}\n\n/** Team quality gate for idle teammate detection. */\nexport function teamQualityGate(input: HookInput): HookResult {\n  const teamName = getTeamName();\n  if (!teamName) {\n    return outputSilentSuccess();\n  }\n\n  const projectDir = getProjectDir();\n  if (!projectDir) {\n    return outputSilentSuccess();\n  }\n\n  const teammateId = input.teammate_id || input.agent_id || 'unknown';\n  const teammateType = input.teammate_type || input.subagent_type || 'unknown';\n\n  // Primary signal: did the teammate produce meaningful output?\n  const productive = hasProductiveOutput(input);\n\n  // Secondary signal: any recent completion events in the log?\n  const recentCompletion = hasRecentCompletion(projectDir);\n\n  // Log quality status\n  appendEventLog('team-quality.jsonl', {\n    timestamp: new Date().toISOString(),\n    event: 'teammate_quality_check',\n    team_name: teamName,\n    teammate_id: teammateId,\n    teammate_type: teammateType,\n    has_productive_output: productive,\n    has_recent_completion: recentCompletion,\n    session_id: input.session_id,\n  });\n\n  // Only warn if BOTH signals are negative: no meaningful output AND no recent completion\n  if (!productive && !recentCompletion) {\n    logHook(\n      'team-quality-gate',\n      `Teammate \"${teammateId}\" (${teammateType}) idle without productive output or recent completion`,\n    );\n    return outputWithContext(\n      `Teammate \"${teammateType}\" (${teammateId}) went idle without completing a task. ` +\n        `Check if their work is stuck or needs reassignment.`,\n    );\n  }\n\n  logHook('team-quality-gate', `Teammate \"${teammateId}\" quality check passed`);\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-27\n\n/**\n * Unified TeammateIdle Dispatcher\n * Issue #853: Consolidate 3 TeammateIdle hooks into single dispatcher\n *\n * Reduces hooks.json entries from 3 to 1 for TeammateIdle event.\n * Internally routes to: progress-reporter, team-synthesis-trigger, team-quality-gate.\n *\n * CC 2.1.33 Compliant: Single hook with internal parallel routing\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\n\n// Import individual TeammateIdle hook implementations\nimport { progressReporter } from './progress-reporter.js';\nimport { teamSynthesisTrigger } from './team-synthesis-trigger.js';\nimport { teamQualityGate } from './team-quality-gate.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult | Promise<HookResult>;\n\ninterface HookConfig {\n  name: string;\n  fn: HookFn;\n  critical: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Hook registry \u2014 order matters: analytics first, then synthesis, then quality\n// -----------------------------------------------------------------------------\n\nconst HOOKS: HookConfig[] = [\n  { name: 'progress-reporter', fn: progressReporter, critical: false },\n  { name: 'team-synthesis-trigger', fn: teamSynthesisTrigger, critical: false },\n  { name: 'team-quality-gate', fn: teamQualityGate, critical: false },\n];\n\n// -----------------------------------------------------------------------------\n// Dispatcher\n// -----------------------------------------------------------------------------\n\nexport async function unifiedTeammateIdleDispatcher(input: HookInput): Promise<HookResult> {\n  const contextParts: string[] = [];\n\n  for (const hook of HOOKS) {\n    try {\n      const result = await hook.fn(input);\n\n      // Collect any additionalContext from sub-hooks\n      const ctx = result?.hookSpecificOutput?.additionalContext;\n      if (ctx && typeof ctx === 'string' && ctx.trim()) {\n        contextParts.push(ctx.trim());\n      }\n    } catch (err) {\n      logHook(\n        'teammate-idle-dispatcher',\n        `Hook \"${hook.name}\" failed: ${err instanceof Error ? err.message : String(err)}`,\n      );\n      // Non-critical hooks: log and continue\n    }\n  }\n\n  if (contextParts.length > 0) {\n    return outputWithContext(contextParts.join('\\n'));\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * TaskCompleted Hook: Completion Tracker\n *\n * CC 2.1.33 TaskCompleted event fires when a task completes.\n * Logs completion metrics and suggests follow-up verification for code tasks.\n *\n * @hook TaskCompleted\n * @since CC 2.1.33\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { getProjectDir } from '../lib/common.js';\nimport { appendEventLog } from '../lib/event-logger.js';\nimport { appendAnalytics, hashProject, getTeamContext } from '../lib/analytics.js';\n\n/** Match code implementation tasks \u2014 require 2+ word subjects to avoid false positives */\nconst IMPLEMENTATION_PATTERN = /\\b(?:implement|refactor|build|migrate)\\b.{5,}/i;\n\nexport async function completionTracker(input: HookInput): Promise<HookResult> {\n  if (!getProjectDir()) {\n    return { continue: true };\n  }\n\n  const taskId = input.task_id || 'unknown';\n  const taskSubject = input.task_subject || '';\n  const taskStatus = input.task_status || 'completed';\n  const duration = input.duration_ms || 0;\n  const tokenCount = input.token_count;\n  const toolUses = input.tool_uses;\n\n  appendEventLog('task-completions.jsonl', {\n    timestamp: new Date().toISOString(),\n    event: 'task_completed',\n    task_id: taskId,\n    task_subject: taskSubject,\n    task_status: taskStatus,\n    duration_ms: duration,\n    session_id: input.session_id,\n    ...(tokenCount !== undefined && { token_count: tokenCount }),\n    ...(toolUses !== undefined && { tool_uses: toolUses }),\n  });\n\n  // Cross-project task analytics (Issue #459)\n  appendAnalytics('task-usage.jsonl', {\n    ts: new Date().toISOString(),\n    pid: hashProject(process.env.CLAUDE_PROJECT_DIR || ''),\n    task_status: taskStatus,\n    duration_ms: duration,\n    ...(tokenCount !== undefined && { token_count: tokenCount }),\n    ...(toolUses !== undefined && { tool_uses: toolUses }),\n    ...getTeamContext(),\n  });\n\n  // Suggest verification only for substantial implementation tasks\n  if (IMPLEMENTATION_PATTERN.test(taskSubject) && taskStatus === 'completed') {\n    const tokenInfo = tokenCount !== undefined ? `, ${tokenCount} tokens, ${toolUses ?? 0} tool calls` : '';\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        additionalContext: `Task \"${taskSubject}\" completed (${Math.round(duration / 1000)}s${tokenInfo}). Consider running tests to verify.`,\n      },\n    };\n  }\n\n  return { continue: true };\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-21\n\n/**\n * Worktree Lifecycle Logger\n * Logs worktree creation and removal events, emits advisory context.\n *\n * Hook events: WorktreeCreate, WorktreeRemove\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, outputSilentSuccess, outputPromptContext } from '../lib/common.js';\n\nexport function worktreeLifecycleLogger(input: HookInput): HookResult {\n  const event = input.hook_event;\n  const worktreePath = input.tool_input?.file_path || input.tool_input?.path || 'unknown';\n\n  if (event === 'WorktreeCreate') {\n    logHook('worktree-lifecycle', `Worktree created: ${worktreePath}`);\n    return outputPromptContext(\n      `[WorktreeCreate] A new worktree was created at: ${worktreePath}. ` +\n      'You are now working in an isolated worktree. Changes here do not affect the main working tree.'\n    );\n  }\n\n  if (event === 'WorktreeRemove') {\n    logHook('worktree-lifecycle', `Worktree removed: ${worktreePath}`);\n    return outputPromptContext(\n      `[WorktreeRemove] Worktree removed: ${worktreePath}. ` +\n      'The isolated worktree has been cleaned up. You are back in the main working tree.'\n    );\n  }\n\n  logHook('worktree-lifecycle', `Unexpected event: ${event}`);\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-27\n\n/**\n * ConfigChange Hook: Settings Reload\n *\n * Fires when .claude/settings.json or project config changes mid-session.\n * Logs the change and emits advisory context so Claude knows settings shifted.\n *\n * CC 2.1.50+ fires ConfigChange automatically when config files are modified.\n *\n * @see https://docs.anthropic.com/en/docs/claude-code/hooks\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, outputPromptContext } from '../lib/common.js';\n\nexport function settingsReload(input: HookInput): HookResult {\n  const sessionId = input.session_id || 'unknown';\n\n  logHook('config-change', `Settings changed mid-session (session: ${sessionId})`);\n\n  return outputPromptContext(\n    '[ConfigChange] Project or user settings were modified during this session. ' +\n    'Permission rules, hook configurations, or plugin settings may have changed. ' +\n    'If a permission was just granted or revoked, it takes effect immediately.'\n  );\n}\n", "/**\n * Lifecycle Hooks Entry Point\n *\n * Hooks that run on session start/end (SessionStart, SessionEnd)\n * Bundle: lifecycle.mjs (~30 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\nexport * from '../lib/git.js';\n\n// Lifecycle hooks (13) - SessionStart/SessionEnd\nimport { analyticsConsentCheck } from '../lifecycle/analytics-consent-check.js';\nimport { patternSyncPull } from '../lifecycle/pattern-sync-pull.js';\nimport { patternSyncPush } from '../lifecycle/pattern-sync-push.js';\nimport { prStatusEnricher } from '../lifecycle/pr-status-enricher.js';\nimport { sessionCleanup } from '../lifecycle/session-cleanup.js';\nimport { sessionContextLoader } from '../lifecycle/session-context-loader.js';\nimport { sessionEnvSetup } from '../lifecycle/session-env-setup.js';\nimport { sessionTracking } from '../lifecycle/session-tracking.js';\nimport { sessionMetricsSummary } from '../lifecycle/session-metrics-summary.js';\nimport { dependencyVersionCheck } from '../lifecycle/dependency-version-check.js';\nimport { unifiedSessionStartDispatcher } from '../lifecycle/unified-dispatcher.js';\nimport { preCompactSaver } from '../lifecycle/pre-compact-saver.js';\nimport { prefillGuard } from '../lifecycle/prefill-guard.js';\nimport { mcpHealthCheck } from '../lifecycle/mcp-health-check.js';\n\n// TeammateIdle hooks (CC 2.1.33) \u2014 consolidated into unified dispatcher (#853)\nimport { progressReporter } from '../teammate-idle/progress-reporter.js';\nimport { teamSynthesisTrigger } from '../teammate-idle/team-synthesis-trigger.js';\nimport { teamQualityGate } from '../teammate-idle/team-quality-gate.js';\nimport { unifiedTeammateIdleDispatcher } from '../teammate-idle/unified-dispatcher.js';\n\n// TaskCompleted hooks (CC 2.1.33)\nimport { completionTracker } from '../task-completed/completion-tracker.js';\n\n// WorktreeCreate/WorktreeRemove hooks (CC 2.1.50)\nimport { worktreeLifecycleLogger } from '../worktree/worktree-lifecycle-logger.js';\n\n// ConfigChange hooks (CC 2.1.50)\nimport { settingsReload } from '../config-change/settings-reload.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Lifecycle hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'lifecycle/analytics-consent-check': analyticsConsentCheck,\n  'lifecycle/pattern-sync-pull': patternSyncPull,\n  'lifecycle/pattern-sync-push': patternSyncPush,\n  'lifecycle/pr-status-enricher': prStatusEnricher,\n  'lifecycle/session-cleanup': sessionCleanup,\n  'lifecycle/session-context-loader': sessionContextLoader,\n  'lifecycle/session-env-setup': sessionEnvSetup,\n  'lifecycle/session-tracking': sessionTracking,\n  'lifecycle/session-metrics-summary': sessionMetricsSummary,\n  'lifecycle/dependency-version-check': dependencyVersionCheck,\n  'lifecycle/unified-dispatcher': unifiedSessionStartDispatcher,\n  'lifecycle/pre-compact-saver': preCompactSaver,\n  'lifecycle/prefill-guard': prefillGuard,\n  'lifecycle/mcp-health-check': mcpHealthCheck,\n\n  // TeammateIdle hooks (CC 2.1.33)\n  'teammate-idle/unified-dispatcher': unifiedTeammateIdleDispatcher,\n  'teammate-idle/progress-reporter': progressReporter,\n  'teammate-idle/team-synthesis-trigger': teamSynthesisTrigger,\n  'teammate-idle/team-quality-gate': teamQualityGate,\n\n  // TaskCompleted hooks (CC 2.1.33)\n  'task-completed/completion-tracker': completionTracker,\n\n  // WorktreeCreate/WorktreeRemove hooks (CC 2.1.50)\n  'worktree/worktree-lifecycle-logger': worktreeLifecycleLogger,\n\n  // ConfigChange hooks (CC 2.1.50)\n  'config-change/settings-reload': settingsReload,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "appendFileSync", "mkdirSync", "dirname", "buffer", "flushing", "handlersRegistered", "bufferWrite", "filePath", "content", "ensureHandlers", "flush", "grouped", "entry", "arr", "path", "contents", "ensureHandlers", "handlersRegistered", "flush", "execSync", "os", "path", "getHomeDir", "getTempDir", "getProjectDir", "getPluginRoot", "getLogDir", "getMetricsFile", "path", "getTempDir", "joinPath", "path", "pathSeparator", "execSync", "createHash", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "basename", "MAX_PROJECT_LENGTH", "MAX_BRANCH_LENGTH", "SAFE_CHARS", "getProjectName", "projectDir", "dir", "name", "sanitizeName", "getGitBranchForSession", "branch", "sanitized", "formatDateComponent", "date", "d", "month", "day", "formatTimeComponent", "hours", "minutes", "generateShortHash", "entropy", "maxLength", "generateSmartSessionId", "project", "dateStr", "timeStr", "hash", "getCachedSessionId", "cachePath", "data", "age", "maxAge", "cacheSessionId", "sessionId", "instanceDir", "getOrGenerateSessionId", "cached", "newId", "getLogDir", "getProjectDir", "getPluginRoot", "getEnvFile", "getSessionId", "getOrGenerateSessionId", "getCachedBranch", "projectDir", "branch", "execSync", "getLogLevel", "normalizeLineEndings", "content", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputWithNotification", "userMessage", "claudeContext", "result", "outputAllowWithContext", "systemMessage", "outputError", "message", "outputWarning", "outputStderrWarning", "outputDeny", "outputWithUpdatedInput", "updatedInput", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "existsSync", "statSync", "rotated", "renameSync", "ensureDir", "dir", "mkdirSync", "logHook", "hookName", "logDir", "timestamp", "bufferWrite", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "extractContext", "estimateTokenCount", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "lineContainsAll", "terms", "line", "t", "lineContainsAllCI", "lower", "normalizeCommand", "command", "escapeRegex", "str", "execSync", "getCurrentBranch", "projectDir", "dir", "getProjectDir", "execSync", "isProtectedBranch", "branch", "currentBranch", "getRepoRoot", "isGitRepo", "getGitStatus", "hasUncommittedChanges", "getDefaultBranch", "extractIssueNumber", "patterns", "pattern", "match", "getStagedFiles", "output", "f", "analyzeStagedChanges", "files", "directories", "extensions", "hasTests", "hasConfig", "hasDocs", "hasSource", "file", "parts", "ext", "validateBranchName", "validPrefixes", "prefix", "existsSync", "readFileSync", "getConsentStatus", "projectDir", "consentFile", "existsSync", "status", "readFileSync", "getLastConsentEvent", "consentLog", "log", "shouldShowReminder", "lastTimestamp", "lastDate", "analyticsConsentCheck", "input", "getProjectDir", "logHook", "outputSilentSuccess", "lastEvent", "existsSync", "readFileSync", "writeFileSync", "statSync", "mkdirSync", "MAX_FILE_SIZE_BYTES", "shouldSkipSlowHooks", "isSyncEnabled", "projectDir", "configFile", "existsSync", "readFileSync", "checkFileSize", "filePath", "stats", "statSync", "logHook", "pullGlobalPatterns", "globalPatternsFile", "getHomeDir", "projectPatternsFile", "globalList", "projectPatterns", "projectList", "existingTexts", "p", "newPatterns", "mergedPatterns", "mkdirSync", "writeFileSync", "err", "patternSyncPull", "input", "outputSilentSuccess", "getProjectDir", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "isSyncEnabled", "projectDir", "configFile", "existsSync", "readFileSync", "pushProjectPatterns", "projectPatternsFile", "home", "getHomeDir", "globalPatternsFile", "logHook", "projectList", "globalPatterns", "globalList", "existingTexts", "p", "newPatterns", "mergedPatterns", "mkdirSync", "writeFileSync", "err", "patternSyncPush", "input", "getProjectDir", "outputSilentSuccess", "execSync", "SKIP_BRANCHES", "prStatusEnricher", "input", "logHook", "projectDir", "getProjectDir", "branch", "getCachedBranch", "outputSilentSuccess", "prJson", "execSync", "pr", "unresolvedCount", "threadsJson", "t", "draftLabel", "reviewLabel", "unresolvedLabel", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "readdirSync", "unlinkSync", "copyFileSync", "join", "homedir", "existsSync", "readFileSync", "readdirSync", "statSync", "rmSync", "join", "getTeamName", "getTeamMembers", "teamName", "homeDir", "configPath", "join", "existsSync", "members", "readFileSync", "m", "listAllTeams", "homeDir", "teamsDir", "join", "existsSync", "readdirSync", "name", "statSync", "isStaleTeam", "teamName", "maxAgeHours", "teamPath", "configPath", "cleanupTeam", "ok", "sub", "dir", "rmSync", "mkdirSync", "statSync", "renameSync", "createHash", "getAnalyticsDir", "joinPath", "getHomeDir", "hashProject", "projectDir", "createHash", "getTeamContext", "team", "rotateIfNeeded", "filePath", "maxBytes", "statSync", "month", "rotated", "renameSync", "isTestEnv", "appendAnalytics", "file", "entry", "dir", "mkdirSync", "bufferWrite", "existsSync", "readFileSync", "getTotalTools", "metricsFile", "getMetricsFile", "existsSync", "tools", "readFileSync", "sum", "count", "archiveMetrics", "metricsFile", "archiveDir", "existsSync", "totalTools", "getTotalTools", "logHook", "mkdirSync", "archiveName", "archivePath", "copyFileSync", "err", "cleanupOldArchives", "keepCount", "files", "readdirSync", "f", "toDelete", "file", "unlinkSync", "cleanupRotatedLogs", "logDir", "patterns", "pattern", "prefix", "sanitizeFirstPrompt", "raw", "cleaned", "taskSummaryMatch", "argsMatch", "nameMatch", "parts", "args", "promptIdx", "sanitizeSessionsIndex", "projectDir", "home", "homedir", "ccProjectsDir", "join", "encodedPath", "indexFile", "data", "readFileSync", "changed", "entry", "writeFileSync", "sessionCleanup", "input", "getProjectDir", "getMetricsFile", "teamName", "cleanupTeam", "lastMsgLen", "appendAnalytics", "hashProject", "getTeamContext", "outputSilentSuccess", "existsSync", "readFileSync", "isValidJsonFile", "filePath", "existsSync", "readFileSync", "sessionContextLoader", "input", "logHook", "projectDir", "getProjectDir", "contextLoaded", "agentType", "sessionState", "identityFile", "knowledgeIndex", "statusFile", "agentConfig", "dir", "addedDirState", "compactionManifest", "manifest", "error", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "getCurrentBranch", "projectDir", "execSync", "sessionEnvSetup", "input", "logHook", "getProjectDir", "sessionId", "getSessionId", "metricsFile", "getMetricsFile", "mkdirSync", "agentType", "metrics", "writeFileSync", "err", "sessionState", "existsSync", "state", "readFileSync", "branch", "outputSilentSuccess", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "createHash", "os", "IDENTITY_CONFIG_FILE", "SALT", "cachedIdentity", "generateAnonymousId", "input", "createHash", "SALT", "getMachineId", "readUserConfig", "projectDir", "configPath", "IDENTITY_CONFIG_FILE", "existsSync", "content", "readFileSync", "error", "logHook", "getGitIdentity", "result", "execSync", "getEnvIdentity", "resolveUserIdentity", "cachedIdentity", "dir", "getProjectDir", "machineId", "config", "git", "env", "userId", "anonId", "getIdentityContext", "identity", "resolveUserIdentity", "getSessionId", "SESSION_ID_PATTERN", "isValidSessionId", "sessionId", "getSessionDir", "projectDir", "sid", "getSessionId", "pDir", "getProjectDir", "getEventsPath", "ensureSessionDir", "dir", "existsSync", "mkdirSync", "eventCounter", "counterLoaded", "counterDirty", "lastPersistTime", "PERSIST_INTERVAL", "getCounterPath", "loadPersistedCounter", "counterPath", "data", "readFileSync", "logHook", "persistCounter", "now", "writeFileSync", "generateEventId", "trackEvent", "eventType", "name", "options", "event", "generateEventId", "getIdentityContext", "sanitizeForStorage", "truncate", "ensureSessionDir", "eventsPath", "getEventsPath", "bufferWrite", "logHook", "error", "getTimeOfDay", "hour", "trackSessionStart", "context", "now", "sessionContext", "trackEvent", "truncate", "str", "maxLen", "sanitizeForStorage", "obj", "sanitized", "sensitiveKeys", "key", "value", "s", "execSync", "getGitBranch", "projectDir", "sessionTracking", "input", "getProjectDir", "gitBranch", "trackSessionStart", "logHook", "outputSilentSuccess", "error", "existsSync", "readFileSync", "sessionMetricsSummary", "_input", "logHook", "metricsFile", "getMetricsFile", "existsSync", "outputSilentSuccess", "metrics", "readFileSync", "tools", "errors", "totalTools", "sum", "count", "topTools", "a", "b", "tool", "err", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "KNOWN_VULNS", "CACHE_TTL_HOURS", "shouldSkipSlowHooks", "versionLessThan", "current", "target", "currentParts", "p", "targetParts", "i", "c", "t", "versionMatchesVuln", "currentVersion", "vulnPattern", "operator", "vulnVersion", "cleanVersion", "version", "checkPackageVulnerability", "packageName", "cleanedVersion", "pkgLower", "vuln", "getCachedWarnings", "cacheFile", "existsSync", "cache", "readFileSync", "saveCache", "warnings", "mkdirSync", "writeFileSync", "parsePackageJson", "filePath", "criticalCount", "highCount", "pkg", "allDeps", "parseRequirementsTxt", "lines", "line", "trimmed", "match", "dependencyVersionCheck", "input", "logHook", "outputSilentSuccess", "projectDir", "getProjectDir", "hasPackageJson", "hasRequirementsTxt", "hasPyprojectToml", "hasGoMod", "cached", "outputWithContext", "totalCritical", "totalHigh", "allWarnings", "result", "summary", "fullWarning", "existsSync", "readFileSync", "mkdirSync", "join", "dirname", "countJsonlLines", "filePath", "existsSync", "readFileSync", "line", "countSessions", "analyticsPath", "existsSync", "lines", "readFileSync", "line", "count", "collectMemoryMetrics", "projectDir", "dir", "getProjectDir", "memoryDir", "join", "logsDir", "graphQueuePath", "completedFlowsPath", "countJsonlLines", "appendMetricSnapshot", "metrics", "metricsPath", "snapshot", "metricsDir", "dirname", "mkdirSync", "bufferWrite", "logHook", "error", "memoryMetricsCollector", "input", "logHook", "projectDir", "getProjectDir", "metrics", "collectMemoryMetrics", "appendMetricSnapshot", "error", "outputSilentSuccess", "MAX_AGE_HOURS", "staleTeamCleanup", "_input", "teams", "listAllTeams", "outputSilentSuccess", "cleaned", "name", "isStaleTeam", "cleanupTeam", "logHook", "execSync", "writeFileSync", "mkdirSync", "existsSync", "join", "TSC_TIMEOUT_MS", "parseTscOutput", "output", "errors", "errorRegex", "match", "getCacheFilePath", "sessionId", "cacheDir", "join", "getProjectDir", "existsSync", "mkdirSync", "hasTypeScript", "projectDir", "typeErrorIndexer", "input", "logHook", "outputSilentSuccess", "execSync", "cache", "writeFileSync", "err", "execErr", "fileSet", "e", "summary", "HOOKS", "patternSyncPull", "sessionEnvSetup", "sessionTracking", "memoryMetricsCollector", "staleTeamCleanup", "typeErrorIndexer", "unifiedSessionStartDispatcher", "input", "results", "HOOKS", "hook", "result", "error", "message", "logHook", "failures", "outputSilentSuccess", "writeFileSync", "existsSync", "readFileSync", "mkdirSync", "readdirSync", "execSync", "join", "getSessionStateFile", "logDir", "getLogDir", "stateDir", "join", "existsSync", "mkdirSync", "getSessionId", "loadSessionState", "stateFile", "readFileSync", "countLocalMemoryEntries", "memoryDir", "getProjectDir", "files", "readdirSync", "f", "count", "file", "content", "getRecentDecisions", "decisionFile", "line", "entry", "calculateAvgInterval", "history", "intervals", "i", "prev", "curr", "a", "b", "getRecentlyEditedFiles", "execSync", "getInProgressTasks", "logFile", "preCompactSaver", "_input", "state", "now", "localEntries", "decisions", "writeFileSync", "compactionLog", "bufferWrite", "logHook", "error", "msg", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "readdirSync", "statSync", "mkdirSync", "join", "dirname", "CACHE_VERSION", "getCacheFile", "projectDir", "getSkillDirs", "skillsDir", "existsSync", "readdirSync", "d", "statSync", "join", "isCacheFresh", "cacheFile", "skillDirs", "cache", "readFileSync", "scannedAt", "dir", "skillPath", "readCache", "writeCache", "warnings", "mkdirSync", "dirname", "writeFileSync", "PREFILL_PATTERNS", "s", "lineContainsAllCI", "OUTPUT_FORMAT_PATTERNS", "hasPrefillPatterns", "content", "pattern", "hasOutputFormatPatterns", "scanSkillsForPrefill", "matches", "isOpus46OrLater", "model", "prefillGuard", "_input", "outputSilentSuccess", "pluginRoot", "getPluginRoot", "affectedSkills", "logHook", "outputWarning", "existsSync", "readFileSync", "join", "checkServer", "name", "projectDir", "existsSync", "join", "pkg", "readFileSync", "mcpHealthCheck", "input", "logHook", "outputSilentSuccess", "getProjectDir", "mcpJsonPath", "config", "servers", "warnings", "entry", "warning", "message", "outputWithContext", "writeFileSync", "mkdirSync", "existsSync", "join", "basename", "appendEventLog", "filename", "entry", "projectDir", "getProjectDir", "logsDir", "join", "existsSync", "mkdirSync", "logPath", "basename", "writeFileSync", "progressReporter", "input", "getProjectDir", "teammateId", "teammateType", "idleDuration", "appendEventLog", "appendAnalytics", "hashProject", "getTeamContext", "existsSync", "readFileSync", "join", "IDLE_WINDOW_MS", "teamSynthesisTrigger", "input", "teamName", "getTeamName", "outputSilentSuccess", "members", "getTeamMembers", "projectDir", "getProjectDir", "logPath", "join", "existsSync", "cutoff", "idleMembers", "recent", "readFileSync", "line", "entry", "id", "currentTeammateId", "logHook", "outputWithContext", "existsSync", "readFileSync", "join", "COMPLETION_WINDOW_MS", "MEANINGFUL_OUTPUT_MIN_CHARS", "hasProductiveOutput", "input", "hasRecentCompletion", "projectDir", "completionsPath", "join", "existsSync", "cutoff", "recent", "readFileSync", "line", "entry", "teamQualityGate", "teamName", "getTeamName", "outputSilentSuccess", "getProjectDir", "teammateId", "teammateType", "productive", "recentCompletion", "appendEventLog", "logHook", "outputWithContext", "HOOKS", "progressReporter", "teamSynthesisTrigger", "teamQualityGate", "unifiedTeammateIdleDispatcher", "input", "contextParts", "hook", "ctx", "err", "logHook", "outputWithContext", "outputSilentSuccess", "IMPLEMENTATION_PATTERN", "completionTracker", "input", "getProjectDir", "taskId", "taskSubject", "taskStatus", "duration", "tokenCount", "toolUses", "appendEventLog", "appendAnalytics", "hashProject", "getTeamContext", "tokenInfo", "worktreeLifecycleLogger", "input", "event", "worktreePath", "logHook", "outputPromptContext", "outputSilentSuccess", "settingsReload", "input", "sessionId", "logHook", "outputPromptContext", "hooks", "analyticsConsentCheck", "patternSyncPull", "patternSyncPush", "prStatusEnricher", "sessionCleanup", "sessionContextLoader", "sessionEnvSetup", "sessionTracking", "sessionMetricsSummary", "dependencyVersionCheck", "unifiedSessionStartDispatcher", "preCompactSaver", "prefillGuard", "mcpHealthCheck", "unifiedTeammateIdleDispatcher", "progressReporter", "teamSynthesisTrigger", "teamQualityGate", "completionTracker", "worktreeLifecycleLogger", "settingsReload", "getHook", "name", "listHooks"]
}
