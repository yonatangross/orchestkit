// OrchestKit Hooks - skill bundle
// Generated: 2026-02-17T09:38:04.578Z

function Gs(e){return typeof e.command=="string"}function Ws(e){return typeof e.file_path=="string"&&typeof e.content=="string"}function zs(e){return typeof e.file_path=="string"&&typeof e.old_string=="string"&&typeof e.new_string=="string"}function Zs(e){return typeof e.file_path=="string"&&e.content===void 0}import{appendFileSync as Q,existsSync as tt,statSync as ee,renameSync as se,mkdirSync as ne,readSync as oe}from"node:fs";import{execSync as re}from"node:child_process";import jt from"node:os";import O from"node:path";function Nt(){return process.env.HOME||process.env.USERPROFILE||jt.homedir()}function F(){return process.env.CLAUDE_PROJECT_DIR||"."}function q(){return process.env.CLAUDE_PLUGIN_ROOT||process.env.CLAUDE_PROJECT_DIR||"."}function K(){return process.env.CLAUDE_PLUGIN_ROOT?O.join(Nt(),".claude","logs","ork"):O.join(F(),".claude","logs")}var Js=O.join,Ys=O.sep;import{execSync as Lt}from"node:child_process";import{createHash as Ft}from"node:crypto";import{existsSync as J,readFileSync as Mt,writeFileSync as Ut,mkdirSync as Bt}from"node:fs";import{join as M,basename as Gt}from"node:path";var Wt=20,zt=15,Zt=/[^a-z0-9-]/g;function Vt(e){let t=e||process.env.CLAUDE_PROJECT_DIR||process.cwd(),s=Gt(t);return Y(s,Wt)}function qt(e){if(process.env.ORCHESTKIT_SESSION_BRANCH)return process.env.ORCHESTKIT_SESSION_BRANCH;let t=e||process.env.CLAUDE_PROJECT_DIR||process.cwd();try{let s=Lt("git branch --show-current",{cwd:t,encoding:"utf8",timeout:2e3,stdio:["pipe","pipe","pipe"]}).trim(),n=Y(s||"detached",zt);return process.env.ORCHESTKIT_SESSION_BRANCH=n,n}catch{return"nobranch"}}function Kt(e){let t=e||new Date,s=String(t.getMonth()+1).padStart(2,"0"),n=String(t.getDate()).padStart(2,"0");return`${s}${n}`}function Jt(e){let t=e||new Date,s=String(t.getHours()).padStart(2,"0"),n=String(t.getMinutes()).padStart(2,"0");return`${s}${n}`}function Yt(){let e=`${process.pid}-${Date.now()}-${Math.random()}`;return Ft("sha256").update(e).digest("hex").slice(0,4)}function Y(e,t){return e.toLowerCase().replace(Zt,"-").replace(/-+/g,"-").replace(/^-|-$/g,"").slice(0,t)}function Xt(e,t){let s=Vt(e),n=qt(e),o=Kt(t),r=Jt(t),i=Yt();return`${s}-${n}-${o}-${r}-${i}`}function Qt(e){let t=e||process.env.CLAUDE_PROJECT_DIR||process.cwd(),s=M(t,".instance","session-id.json");if(J(s))try{let n=JSON.parse(Mt(s,"utf8"));if(n.session_id&&n.created_at){let o=Date.now()-new Date(n.created_at).getTime(),r=1440*60*1e3;if(o<r)return n.session_id}}catch{}}function te(e,t){let s=t||process.env.CLAUDE_PROJECT_DIR||process.cwd(),n=M(s,".instance"),o=M(n,"session-id.json");try{J(n)||Bt(n,{recursive:!0}),Ut(o,JSON.stringify({session_id:e,created_at:new Date().toISOString()},null,2))}catch{}}function X(e){if(process.env.CLAUDE_SESSION_ID)return process.env.CLAUDE_SESSION_ID;let t=Qt(e);if(t)return t;let s=Xt(e);return te(s,e),s}function v(){return K()}function m(){return F()}function B(){return q()}function un(){return process.env.CLAUDE_ENV_FILE?process.env.CLAUDE_ENV_FILE:`${B()}/.claude/.instance_env`}function U(){return X()}function pn(e){if(process.env.ORCHESTKIT_BRANCH)return process.env.ORCHESTKIT_BRANCH;try{let t=re("git branch --show-current",{cwd:e||m(),encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim();return process.env.ORCHESTKIT_BRANCH=t,t}catch{return"unknown"}}function ie(){return process.env.ORCHESTKIT_LOG_LEVEL||"warn"}function ln(e){return e.replace(/\r\n/g,`
`)}function ce(e){let t=["debug","info","warn","error"];return t.indexOf(e)>=t.indexOf(ie())}function a(){return{continue:!0,suppressOutput:!0}}function fn(){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{permissionDecision:"allow"}}}function h(e){return{continue:!1,stopReason:e,hookSpecificOutput:{permissionDecision:"deny",permissionDecisionReason:e}}}function k(e){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PostToolUse",additionalContext:e}}}function ae(e){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:e}}}function dn(e,t){let s={continue:!0,suppressOutput:!0};return e&&(s.systemMessage=e),t&&(s.hookSpecificOutput={hookEventName:"UserPromptSubmit",additionalContext:t}),s}function mn(e,t){let s={continue:!0,hookSpecificOutput:{hookEventName:"PreToolUse",additionalContext:e,permissionDecision:"allow"}};return t?s.systemMessage=t:s.suppressOutput=!0,s}function gn(e){return{continue:!0,systemMessage:e}}function hn(e){return{continue:!0,systemMessage:`\u26A0 ${e}`}}function yn(e){process.stderr.write(`\u26A0 ${e}
`),process.exit(2)}function kn(e){return{continue:!1,stopReason:e,hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"deny",permissionDecisionReason:e}}}function _n(e){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PreToolUse",updatedInput:e}}}var ue=200*1024,pe=100*1024;function et(e,t){if(tt(e))try{if(ee(e).size>t){let n=`${e}.old.${Date.now()}`;se(e,n)}}catch{}}function st(e){tt(e)||ne(e,{recursive:!0})}function y(e,t,s="debug"){if(!ce(s))return;let n=v(),o=`${n}/hooks.log`;try{st(n),et(o,ue);let r=new Date().toISOString().replace("T"," ").slice(0,19);Q(o,`[${r}] [${s.toUpperCase()}] [${e}] ${t}
`)}catch{}}function vn(e,t,s){let n=v(),o=`${n}/permission-feedback.log`;try{st(n),et(o,pe);let r=new Date().toISOString(),i=s?.tool_name||process.env.HOOK_TOOL_NAME||"unknown",c=s?.session_id||U();Q(o,`${r} | ${e} | ${t} | tool=${i} | session=${c}
`)}catch{}}function le(e){if(!e)return 0;let n=(e.match(/[{};()=><]/g)||[]).length/e.length>.03?2.8:3.5;return Math.ceil(e.length/n)}function xn(e,t,s,n,o){let r=le(e);return n&&n.isOverBudget(s)?(y(t,`Budget exhausted for ${s}, suppressing ${r}t`),a()):(o&&o.trackTokenUsage(t,s,r),ae(e))}function Sn(){try{let e=[],s=Buffer.allocUnsafe(256),n,o=0;for(;;)try{if(n=oe(o,s,0,256,null),n===0)break;e.push(Buffer.from(s.subarray(0,n)))}catch{break}let r=Buffer.concat(e).toString("utf8").trim();return r?JSON.parse(r):{tool_name:"",session_id:U(),tool_input:{}}}catch{return{tool_name:"",session_id:U(),tool_input:{}}}}function Rn(e,t){let s=t.replace(/^\./,"").split("."),n=e;for(let o of s){if(n==null)return;n=n[o]}return n}function bn(e){return e.replace(/\\\s*[\r\n]+/g," ").replace(/\n/g," ").replace(/\s+/g," ").trim()}function $n(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}import{execSync as b}from"node:child_process";function I(e){let t=e||m();try{return b("git branch --show-current",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{return"unknown"}}function fe(e){let t=e||I();return["dev","main","master"].includes(t)}function R(e){let t=e||m();try{return b("git rev-parse --show-toplevel",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{return t}}function In(e){let t=e||m();try{return b("git rev-parse --git-dir",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function de(e){let t=e||m();try{return b("git status --short",{cwd:t,encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]}).trim()}catch{return""}}function nt(e){return de(e).length>0}function ot(e){let t=e||m();try{return b("git rev-parse --verify main",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),"main"}catch{try{return b("git rev-parse --verify master",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),"master"}catch{return"main"}}}function me(e){let t=[/issue\/(\d+)/i,/feature\/(\d+)/i,/fix\/(\d+)/i,/bug\/(\d+)/i,/feat\/(\d+)/i,/^(\d+)-/,/-(\d+)$/,/#(\d+)/];for(let s of t){let n=e.match(s);if(n)return parseInt(n[1],10)}return null}function ge(e){let t=e||m();try{let s=b("git diff --cached --name-only",{cwd:t,encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]}).trim();return s?s.split(`
`).filter(n=>n.trim()):[]}catch{return[]}}function An(e){let t=ge(e),s=new Set,n=new Set,o=!1,r=!1,i=!1,c=!1;for(let u of t){let p=u.split("/");p.length>1&&(s.add(p[0]),p.length>2&&s.add(`${p[0]}/${p[1]}`));let g=u.split(".").pop()||"";n.add(g),/\.(test|spec)\.\w+$/.test(u)||/^tests?\//.test(u)||/__tests__\//.test(u)?o=!0:/\.(md|mdx|txt|rst)$/.test(u)||/^docs?\//.test(u)||u==="README.md"?i=!0:/\.(json|ya?ml|toml|ini|cfg|env)$/.test(u)||/config/i.test(u)||u==="package.json"||u==="tsconfig.json"?r=!0:c=!0}return{files:t,directories:s,extensions:n,hasTests:o,hasConfig:r,hasDocs:i,hasSource:c}}function Cn(e){if(fe(e))return null;let t=["issue/","feature/","fix/","bug/","feat/","chore/","docs/","refactor/","test/","ci/","perf/","style/","release/","hotfix/"];return t.some(n=>e.startsWith(n))?e.startsWith("issue/")&&!me(e)?"issue/ branches should include an issue number (e.g., issue/123-description)":null:`Branch name should start with a valid prefix: ${t.join(", ")}`}function rt(e,...t){let s=e.tool_input.file_path;if(!s)return a();let n=s.split(".").pop()?.toLowerCase()||"";return t.map(r=>r.toLowerCase().replace(/^\./,"")).includes(n)?null:a()}function E(e){return rt(e,"py","ts","tsx","js","jsx","go","rs","java")}function j(e){return rt(e,"py")}import{basename as he,dirname as ye}from"node:path";function it(e){let t=j(e);if(t)return t;let s=e.tool_input.file_path;if(!s)return a();if(!s.includes("/app/")&&!s.includes("/backend/"))return a();let n=he(s),o=ye(s),r=[];if(n==="__init__.py")return a();if(o.endsWith("/routers")||o.includes("/routers/")){let i=/^(router_|routes_|api_).*\.py$/,c=/^(deps|dependencies|utils|helpers|base)\.py$/;!i.test(n)&&!c.test(n)&&(r.push("ROUTER NAMING: Files in routers/ must be prefixed"),r.push(`  Got: ${n}`),r.push("  Expected: router_*.py, routes_*.py, api_*.py, deps.py"))}if(o.endsWith("/services")||o.includes("/services/")){let i=/_service\.py$/,c=/^(base|utils|helpers|abstract)\.py$/;!i.test(n)&&!c.test(n)&&(r.push("SERVICE NAMING: Files in services/ must end with _service.py"),r.push(`  Got: ${n}`),r.push("  Expected: *_service.py, base.py, utils.py"))}if(o.endsWith("/repositories")||o.includes("/repositories/")){let i=/_(repository|repo)\.py$/,c=/^(base|abstract|utils)\.py$/;!i.test(n)&&!c.test(n)&&(r.push("REPOSITORY NAMING: Files in repositories/ must end with _repository.py"),r.push(`  Got: ${n}`),r.push("  Expected: *_repository.py, *_repo.py, base.py"))}if(o.endsWith("/schemas")||o.includes("/schemas/")){let i=/_(schema|dto|request|response)\.py$/,c=/^(base|common|shared|utils)\.py$/;!i.test(n)&&!c.test(n)&&(r.push("SCHEMA NAMING: Files in schemas/ must use proper suffix"),r.push(`  Got: ${n}`),r.push("  Expected: *_schema.py, *_dto.py, *_request.py, *_response.py"))}if(o.endsWith("/models")||o.includes("/models/")){let i=/_(model|entity|orm)\.py$/,c=/^(base|abstract|mixins)\.py$/;!i.test(n)&&!c.test(n)&&(r.push("MODEL NAMING: Files in models/ must use proper suffix"),r.push(`  Got: ${n}`),r.push("  Expected: *_model.py, *_entity.py, *_orm.py, base.py"))}if(/^[A-Z][a-zA-Z]+\.py$/.test(n)&&(r.push("NAMING: Python files should use snake_case, not PascalCase"),r.push(`  Got: ${n}`)),r.length>0){let i=`Backend naming violation in ${n}: ${r[0]}`;return y("backend-file-naming",`BLOCKED: ${i}`),h(i)}return a()}import{execSync as ke}from"child_process";import{readFileSync as _e,existsSync as ve}from"fs";import{join as xe}from"path";var Se=100,G=10240,ct=["decided","chose","selected","will use","implemented","architecture:","pattern:","approach:","recommendation:","best practice:","conclusion:"],Re=["database-engineer","backend-system-architect","frontend-ui-developer","security-auditor","test-generator","workflow-architect","llm-integrator","data-pipeline-engineer","metrics-architect","ux-researcher","ci-cd-engineer","infrastructure-architect","accessibility-specialist"],be=["postgresql","postgres","pgvector","redis","mongodb","sqlite","fastapi","django","flask","express","nextjs","react","vue","angular","typescript","python","jwt","oauth","passkeys","langchain","langgraph","langfuse","docker","kubernetes","terraform","aws","gcp","pytest","jest","vitest","playwright","msw"],$e=["cursor-pagination","repository-pattern","service-layer","clean-architecture","dependency-injection","event-sourcing","cqrs","saga-pattern","circuit-breaker","rate-limiting","optimistic-locking","caching","cache-aside","rag","semantic-search"],Ee=[["cursor-pagination",/cursor[- ]?(based)?[- ]?pagination/i],["jwt-validation",/jwt|json web token/i],["dependency-injection",/dependency injection|di pattern|ioc/i],["rate-limiting",/rate[- ]?limit|throttl/i],["circuit-breaker",/circuit[- ]?breaker|resilience/i],["event-sourcing",/event[- ]?sourc/i],["cqrs",/cqrs|command.*query.*separation/i],["idempotency",/idempoten/i]],we=["critical","security","breaking","migration","architecture","production"],Te=["refactor","optimize","improve","update","enhance","fix"],w=null;function Ie(){if(process.env.CLAUDE_CODE_VERSION)return process.env.CLAUDE_CODE_VERSION;try{let t=ke("claude --version 2>/dev/null",{encoding:"utf-8",timeout:2e3}).match(/(\d+\.\d+\.\d+)/);if(t)return t[1]}catch{}return"2.1.16"}function Ae(){if(w)return w;try{let e=B(),t=xe(e,".claude-plugin","plugin.json");if(ve(t))return w=JSON.parse(_e(t,"utf-8")).version||"unknown",w}catch{}return w="unknown",w}function at(e){let t=e.toLowerCase();return{agents:[...new Set(Re.filter(s=>t.includes(s)))],technologies:[...new Set(be.filter(s=>t.includes(s)))],patterns:[...new Set($e.filter(s=>t.includes(s)))]}}function Ce(e){let t=e.toLowerCase();return/recommend|suggests|advises/.test(t)?"RECOMMENDS":/chose|selected|decided/.test(t)?"CHOSEN_FOR":/replace|instead of/.test(t)?"REPLACES":/conflict|incompatible/.test(t)?"CONFLICTS_WITH":"RELATES_TO"}var De=[/\bbecause\s+([^.,!?\n]+)/gi,/\bsince\s+([^.,!?\n]+)/gi,/\bdue to\s+([^.,!?\n]+)/gi,/\bto avoid\s+([^.,!?\n]+)/gi,/\bso that\s+([^.,!?\n]+)/gi,/\bin order to\s+([^.,!?\n]+)/gi,/\bas it\s+([^.,!?\n]+)/gi,/\bfor\s+(better|improved|faster|simpler|easier)\s+([^.,!?\n]+)/gi],He=[/\bover\s+([^.,!?\n]+)/gi,/\binstead of\s+([^.,!?\n]+)/gi,/\brather than\s+([^.,!?\n]+)/gi,/\bnot\s+([^.,!?\n]+)/gi,/\bversus\s+([^.,!?\n]+)/gi,/\bvs\.?\s+([^.,!?\n]+)/gi],Pe=[/\b(must|need to|required|constraint|requirement)\s+([^.,!?\n]+)/gi,/\b(have to|has to|should)\s+([^.,!?\n]+)/gi,/\b(mandatory|essential)\s+([^.,!?\n]+)/gi],Oe=[/\b(tradeoff|trade-off|downside|drawback)\s*:?\s+([^.,!?\n]+)/gi,/\bbut\s+([^.,!?\n]+)/gi,/\bhowever\s+([^.,!?\n]+)/gi,/\balthough\s+([^.,!?\n]+)/gi,/\b(cost|limitation)\s+is\s+([^.,!?\n]+)/gi];function je(e){let t=e.toLowerCase();return ct.some(s=>t.includes(s))}function Ne(e){let t=[];for(let s of ct){let n=new RegExp(`[^\\n]*${s}[^\\n]*`,"gi"),o=e.match(n);if(o)for(let r of o.slice(0,3)){let i=r.trim().slice(0,300);i.length>30&&t.push(i)}}return[...new Set(t)].slice(0,5)}function Le(e){for(let t of De){let s=e.match(t);if(s)return s[1]?.trim().slice(0,200)}}function Fe(e){let t=[];for(let s of He){let n=e.matchAll(s);for(let o of n){let r=o[1]?.trim();r&&r.length>2&&r.length<100&&t.push(r)}}return[...new Set(t)].slice(0,3)}function Me(e){let t=[];for(let s of Pe){let n=e.matchAll(s);for(let o of n){let r=o[2]?.trim()||o[1]?.trim();r&&r.length>3&&r.length<150&&t.push(r)}}return[...new Set(t)].slice(0,3)}function Ue(e){let t=[];for(let s of Oe){let n=e.matchAll(s);for(let o of n){let r=o[2]?.trim()||o[1]?.trim();r&&r.length>3&&r.length<150&&t.push(r)}}return[...new Set(t)].slice(0,3)}function Be(e){let t=[/\b(?:chose|decided on|selected|using|will use|going with)\s+([^.,!?\n]+)/i,/\b(?:the decision is|decision:)\s+([^.,!?\n]+)/i,/\brecommend(?:ation)?:?\s+([^.,!?\n]+)/i];for(let s of t){let n=e.match(s);if(n)return n[1].trim().slice(0,100)}return e.slice(0,100).trim()}function Ge(e){let t=.5;return e.rationale&&(t+=.2),e.alternatives&&e.alternatives.length>0&&(t+=.1),e.constraints&&e.constraints.length>0&&(t+=.05),e.tradeoffs&&e.tradeoffs.length>0&&(t+=.05),e.entities.length>=1&&(t+=.05),e.entities.length>=2&&(t+=.05),e.importance==="high"&&(t+=.1),Math.min(.99,t)}function We(e){let t=Ne(e),s=[];for(let n of t){let o=at(n),r=[...o.agents,...o.technologies,...o.patterns],i={what:Be(n),text:n,rationale:Le(n),alternatives:Fe(n),constraints:Me(n),tradeoffs:Ue(n),entities:r,confidence:0,category:ut(n),importance:ze(n)};i.confidence=Ge(i),s.push(i)}return s}function ut(e){let t=e.slice(0,G).toLowerCase();return/pagination|cursor|offset/.test(t)?"pagination":/security|vulnerability|owasp/.test(t)?"security":/database|sql|postgres|schema/.test(t)?"database":/api|endpoint|rest|graphql/.test(t)?"api":/auth|login|jwt|oauth/.test(t)?"authentication":/test|pytest|jest|vitest/.test(t)?"testing":/deploy|ci|cd|docker|kubernetes/.test(t)?"deployment":/monitoring|logging|tracing|metrics/.test(t)?"observability":/react|frontend|ui|tailwind/.test(t)?"frontend":/llm|rag|embedding|langchain/.test(t)?"ai-ml":/architecture|design|pattern/.test(t)?"architecture":"decision"}function ze(e){let t=e.toLowerCase();return we.some(s=>t.includes(s))?"high":Te.some(s=>t.includes(s))?"medium":"low"}function Ze(e){for(let[t,s]of Ee)if(s.test(e))return t;return null}function pt(e){let t=e.skill_name||e.tool_input?.skill||"",s=e.tool_result,n=typeof s=="string"?s:s?.content||e.output||"";if(!n||n.length<Se)return a();let o=n.length>G?n.slice(0,G):n;if(!je(o))return a();let r=We(o),i=at(o),c=i.agents.length+i.technologies.length+i.patterns.length;if(r.length===0&&c===0)return a();let u=[],p=r[0],g=p?.category||ut(n.slice(0,200));if(r.length>0){let f=p?.importance||"low",l=Ze(p?.text||""),d=Ie(),H=Ae(),S={category:g,source:"orchestkit-plugin",skill:t||"unknown",cc_version:d,plugin_version:H,importance:f,timestamp:new Date().toISOString(),confidence:p?.confidence||.5};l&&(S.best_practice=l),p?.rationale&&(S.rationale=p.rationale),p?.alternatives?.length&&(S.alternatives=p.alternatives),p?.constraints?.length&&(S.constraints=p.constraints),p?.tradeoffs?.length&&(S.tradeoffs=p.tradeoffs);let _=`[Decisions] Found ${r.length} decision(s) (category: ${g}, importance: ${f})`;if(p&&(_+=`

Primary Decision: "${p.what.slice(0,100)}"`,p.rationale&&(_+=`
Rationale: "${p.rationale.slice(0,150)}"`),p.alternatives?.length&&(_+=`
Alternatives considered: ${p.alternatives.join(", ")}`),p.constraints?.length&&(_+=`
Constraints: ${p.constraints.join("; ")}`),p.tradeoffs?.length&&(_+=`
Tradeoffs: ${p.tradeoffs.join("; ")}`),_+=`
Confidence: ${(p.confidence*100).toFixed(0)}%`),_+=`

To persist to knowledge graph:
mcp__memory__create_entities with entities: [{"name": "${g}-decision", "entityType": "Decision", "observations": ["<decision>"]}]`,u.push(_),p?.alternatives?.length){let P=p.alternatives.map(Ot=>({from:p.what,to:Ot,relationType:"CHOSE_OVER"}));u.push(`[Relations] Create CHOSE_OVER relations:
mcp__memory__create_relations with:
relations: ${JSON.stringify(P)}`)}}if(c>0){let f=Ce(n),l=[...i.agents.map(d=>({name:d,entityType:"Agent",observations:[`Agent: ${d}`]})),...i.technologies.map(d=>({name:d,entityType:"Technology",observations:[`Tech: ${d}`]})),...i.patterns.map(d=>({name:d,entityType:"Pattern",observations:[`Pattern: ${d}`]}))];u.push(`[Entities] Found ${c} entities for graph memory:
- Agents: ${i.agents.length}
- Technologies: ${i.technologies.length}
- Patterns: ${i.patterns.length}

mcp__memory__create_entities with:
entities: ${JSON.stringify(l.slice(0,5))}

Relation type: ${f}`)}return{continue:!0,systemMessage:u.join(`

`)}}import{basename as Ve}from"node:path";function lt(e){let t=j(e);if(t)return t;let s=e.tool_input.file_path,n=e.tool_input.content||e.tool_result||"";if(!s||!n)return a();let o=[];if(s.includes("/routers/")&&(/db\.(add|delete|commit|flush|rollback|refresh|execute|scalar)/.test(n)&&o.push("DATABASE: Direct database operations not allowed in routers"),/^from sqlalchemy import/m.test(n)&&o.push("IMPORT: SQLAlchemy imports not allowed in routers")),s.includes("/services/")&&(/HTTPException\s*\(/.test(n)&&o.push("HTTP: HTTPException not allowed in services - use domain exceptions"),/from fastapi import.*(Request|Response)/.test(n)&&o.push("HTTP: Request/Response types not allowed in services")),s.includes("/repositories/")&&(/HTTPException/.test(n)&&o.push("HTTP: HTTPException not allowed in repositories"),/from.*(services|routers).*import/.test(n)&&o.push("IMPORT: Repositories cannot import from services or routers")),o.length>0){let i=`Layer violation in ${Ve(s)||s}: ${o[0]}`;return y("backend-layer-validator",`BLOCKED: ${i}`),h(i)}return a()}import{existsSync as N,appendFileSync as qe,mkdirSync as Ke}from"node:fs";import{execSync as Je}from"node:child_process";function ft(e){let t=m(),s=v(),n=`${s}/coverage-check.log`,o=parseInt(process.env.COVERAGE_THRESHOLD||"80",10);try{Ke(s,{recursive:!0})}catch{}let r=[],i=new Date().toISOString().replace("T"," ").slice(0,19);r.push(`[${i}] Coverage Check`);let c=`${t}/.coverage`,u=`${t}/coverage.xml`;if(N(c)||N(u))try{let f=Je("coverage report --fail-under=0",{cwd:t,encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}).split(`
`).find(l=>l.includes("TOTAL"));if(f){let l=f.match(/(\d+)%/);if(l){let d=parseInt(l[1],10);r.push(`Python coverage: ${d}%`),d<o?r.push(`WARNING: Coverage ${d}% is below threshold ${o}%`):r.push("Coverage meets threshold")}}}catch{}let p=`${t}/coverage`;if(N(p)){let g=`${p}/coverage-summary.json`;N(g)&&(r.push(""),r.push("JavaScript/TypeScript coverage report found"),r.push("Check coverage/lcov-report/index.html for details"))}try{qe(n,r.join(`
`)+`
`)}catch{}return a()}import{existsSync as Ye,readFileSync as Xe}from"node:fs";var Qe=["coverage/coverage-summary.json","coverage/coverage-final.json",".vitest/coverage/coverage-summary.json","coverage.json",".coverage.json","htmlcov/status.json"];function ts(e,t){try{let s=JSON.parse(t);return e.includes("coverage-summary.json")?s?.total?.lines?.pct??s?.total?.statements?.pct??null:e.includes("coverage.json")?s?.totals?.percent_covered??null:s?.total?.pct!==void 0?s.total.pct:null}catch{return null}}function dt(e){let t=m(),s=parseInt(process.env.COVERAGE_THRESHOLD||"80",10),n="",o="";for(let c of Qe){let u=`${t}/${c}`;if(Ye(u)){n=u;try{o=Xe(u,"utf8")}catch{continue}break}}if(!n||!o)return a();let r=ts(n,o);if(r===null)return a();if(Math.floor(r)<s){let c=`BLOCKED: Coverage ${r}% is below threshold ${s}%

Coverage report: ${n}

Actions required:
  1. Identify uncovered code paths
  2. Add tests for critical business logic
  3. Re-run tests with coverage:

     TypeScript: npm test -- --coverage
     Python:     pytest --cov=app --cov-report=term-missing

  4. Ensure coverage >= ${s}% before proceeding

Tip: Focus on testing:
  - Business logic (services, utils)
  - Edge cases and error handling
  - Critical user flows`;return h(c)}return a()}import{existsSync as A,readFileSync as es}from"node:fs";import{basename as L,dirname as T}from"node:path";function ss(e){return/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(e)||/test_.*\.py$/.test(e)||/_test\.py$/.test(e)}function ns(e){if(/\.(ts|tsx|js|jsx)$/.test(e)){let t=e.replace(/\.[^.]+$/,""),s=e.split(".").pop()||"ts",n=[`${t}.test.${s}`,`${t}.spec.${s}`,`${t}.test.ts`,`${t}.test.tsx`];for(let u of n)if(A(u))return u;let o=T(e),i=L(e).replace(/\.[^.]+$/,""),c=[`${o}/__tests__/${i}.test.${s}`,`${o}/__tests__/${i}.spec.${s}`];for(let u of c)if(A(u))return u}else if(e.endsWith(".py")){let t=T(e),n=`test_${L(e)}`;if(A(`${t}/${n}`))return`${t}/${n}`;let o=T(t);if(A(`${o}/tests/${n}`))return`${o}/tests/${n}`;if(A(`${t}/tests/${n}`))return`${t}/tests/${n}`}return null}function os(e,t){let s=[];if(/\.(ts|tsx|js|jsx)$/.test(t)){let n=e.match(/export (function|class|const|async function)\s+([A-Za-z_][A-Za-z0-9_]*)/g);if(n)for(let o of n){let r=o.split(/\s+/).pop();r&&s.push(r)}}else if(t.endsWith(".py")){let n=e.split(`
`);for(let o of n){let r=o.match(/^(def|class)\s+([A-Za-z][A-Za-z0-9_]*)/);r&&r[2]&&s.push(r[2])}}return[...new Set(s)]}function mt(e){let t=e.tool_input?.file_path||"",s=e.tool_input?.content||e.tool_result||"";if(!t||!s)return a();if(ss(t))return a();if(!/\.(ts|tsx|js|jsx|py)$/.test(t))return a();let n=[],o=[],r=ns(t),i=os(s,t);if(i.length>0)if(r)try{let c=es(r,"utf8"),u=[];for(let p of i)new RegExp(`\\b${p.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`).test(c)||u.push(p);if(u.length>0){o.push("TEST COVERAGE: New units without tests"),o.push(`  Implementation: ${t}`),o.push(`  Test file: ${r}`),o.push(""),o.push(`  Untested units (${u.length}/${i.length}):`);for(let p of u.slice(0,5))o.push(`    - ${p}`);o.push(""),o.push("  Add tests before committing")}}catch{}else{if(n.push("TEST COVERAGE: No test file found for implementation"),n.push(`  Implementation: ${t}`),n.push("  Expected test file:"),/\.(ts|tsx|js|jsx)$/.test(t)){let c=t.replace(/\.[^.]+$/,""),u=t.split(".").pop()||"ts",p=T(t),g=L(t);n.push(`    - ${c}.test.${u}`),n.push(`    - ${p}/__tests__/${g}`)}else if(t.endsWith(".py")){let c=L(t),u=T(t);n.push(`    - ${u}/test_${c}`),n.push(`    - ${T(u)}/tests/test_${c}`)}n.push(""),n.push(`  Found ${i.length} testable units:`);for(let c of i.slice(0,5))n.push(`    - ${c}`)}if(n.length>0)return h(`Missing test coverage for new code: ${n[0]}`);if(o.length>0){let c=o.join(`
`);return k(`Test coverage warnings detected:

${c}`)}return a()}import{basename as rs}from"node:path";function gt(e){let t=e.tool_input?.file_path||"",s=e.tool_input?.content||e.tool_result||"";if(!t||!s)return a();if(!/\/routers\/.*\.py$/.test(t))return a();let n=rs(t);if(/^(deps|dependencies|__init__)\.py$/.test(n))return a();let o=[];if(/=\s*[A-Z][a-zA-Z]*Service\s*\(\s*\)/.test(s)){let r=s.match(/[A-Z][a-zA-Z]*Service\s*\(\s*\)/);o.push("INSTANTIATION: Direct service instantiation not allowed"),o.push(`  Found: ${r?.[0]||"Service()"}`),o.push("  "),o.push("  Use dependency injection:"),o.push("    service: MyService = Depends(get_my_service)")}if(/=\s*[A-Z][a-zA-Z]*(Repository|Repo)\s*\(\s*\)/.test(s)){let r=s.match(/[A-Z][a-zA-Z]*(Repository|Repo)\s*\(\s*\)/);o.push("INSTANTIATION: Direct repository instantiation not allowed"),o.push(`  Found: ${r?.[0]||"Repository()"}`),o.push("  "),o.push("  Use dependency injection:"),o.push("    repo: MyRepository = Depends(get_my_repository)")}if(/^[a-z_]+\s*=\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)\s*\(/m.test(s)&&(o.push("GLOBAL: Global service/repository instance not allowed"),o.push("  "),o.push("  Global instances cause:"),o.push("    - Shared state between requests"),o.push("    - Difficult testing"),o.push("    - Connection pool issues"),o.push("  "),o.push("  Use Depends() for request-scoped instances")),/:\s*(Async)?Session[^=]*\)/.test(s)&&(/:\s*(Async)?Session\s*=\s*Depends/.test(s)||(o.push("DI: Database session must use Depends()"),o.push("  "),o.push("  BAD:  async def get_users(db: AsyncSession):"),o.push("  GOOD: async def get_users(db: AsyncSession = Depends(get_db)):"))),/@router\.(get|post|put|patch|delete)/.test(s)&&/:\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)[^=)]*\)/.test(s)&&(/:\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)\s*=\s*Depends/.test(s)||(o.push("DI: Service/Repository parameters must use Depends()"),o.push("  "),o.push("  BAD:  async def create_user(user_service: UserService):"),o.push("  GOOD: async def create_user(user_service: UserService = Depends(get_user_service)):"))),/async def/.test(s)){/db\.query\(/.test(s)&&(/await.*db\.query\(/.test(s)||(o.push("ASYNC: Sync database call in async function"),o.push("  Found: db.query() (sync pattern)"),o.push("  "),o.push("  Use async SQLAlchemy 2.0 patterns:"),o.push("    result = await db.execute(select(User))"),o.push("    users = result.scalars().all()")));let r=/db\.(add|delete|commit|flush|rollback|refresh)\(/;if(r.test(s)&&/AsyncSession/.test(s)){let i=s.split(`
`);for(let c of i)if(r.test(c)&&!c.includes("await")){o.push("ASYNC: Missing await for async database operation"),o.push("  "),o.push("  With AsyncSession, use await:"),o.push("    await db.commit()"),o.push("    await db.refresh(user)");break}}}if(o.length>0){y("di-pattern-enforcer",`BLOCKED: DI violation in ${t}`);let r=`Dependency injection violation in ${t}. See stderr for details.`;return k(r)}return a()}import{readFileSync as is,readdirSync as cs}from"node:fs";function as(e,t){let s=[];if(/\.(ts|tsx|js|jsx)$/.test(t)){let n=e.match(/(function|class|const|export function|export class)\s+[A-Za-z_][A-Za-z0-9_]*/g);n&&s.push(...n)}else if(t.endsWith(".py")){let n=e.split(`
`);for(let o of n){let r=o.match(/^(def|class)\s+[A-Za-z_][A-Za-z0-9_]*/);r&&s.push(r[0])}}return[...new Set(s)]}function us(e,t){let s=[],n=["node_modules",".venv","venv","__pycache__","dist","build",".next",".git"];function o(r){try{let i=cs(r,{withFileTypes:!0});for(let c of i){let u=`${r}/${c.name}`;c.isDirectory()?n.includes(c.name)||o(u):c.isFile()&&t.test(c.name)&&s.push(u)}}catch{}}return o(e),s}function ps(e){let t=[],s=e.split(`
`),n="",o=0,r=0;for(let i=0;i<s.length;i++){let c=s[i].trim();c&&c===n?(o++,o>=3&&t.push(`Line ${r}: ${n.substring(0,50)}`)):(n=c,o=1,r=i+1)}return t}function ls(e,t){let s=[],n=[];if(/\.(ts|tsx|js|jsx)$/.test(t)){/new Date.*toLocaleDateString/.test(e)&&(s.push("UTILITY: Direct date formatting detected"),s.push("  Use centralized date utilities: import { formatDate } from '@/lib/dates'"));let o=(e.match(/fetch\s*\(\s*['"]/g)||[]).length;o>2&&(n.push(`UTILITY: Multiple fetch calls detected (${o})`),n.push("  Consider using centralized API client or custom hook"));let r=(e.match(/if\s*\([^)]*\.test\([^)]*\)/g)||[]).length;r>3&&(n.push(`UTILITY: Multiple inline validations detected (${r})`),n.push("  Use Zod schemas: const schema = z.object({...})"))}if(t.endsWith(".py")){let o=(e.match(/json\.loads/g)||[]).length;o>3&&(n.push(`UTILITY: Multiple json.loads detected (${o})`),n.push("  Consider centralized JSON handling with error recovery"));let r=(e.match(/os\.getenv|os\.environ/g)||[]).length;r>5&&(n.push(`UTILITY: Multiple environment variable accesses (${r})`),n.push("  Use Settings/Config class with Pydantic validation"))}return{errors:s,warnings:n}}function ht(e){let t=e.tool_input?.file_path||"",s=e.tool_input?.content||e.tool_result||"";if(!t||!s)return a();if(!/\.(ts|tsx|js|jsx|py)$/.test(t))return a();let n=[],o=[],r=as(s,t);if(r.length>0){let u=R()||m(),p=us(u,/\.(ts|tsx|js|jsx|py)$/);for(let g of r){let f=g.split(/\s+/).pop()||"";if(f){for(let l of p)if(l!==t)try{let d=is(l,"utf8");if(new RegExp(`\\b${f.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`).test(d)&&d.includes(g)){let S=l.replace(u+"/","");o.push(`DUPLICATE: '${f}' already exists in:`),o.push(`  - ${S}`),o.push("  Consider:"),o.push("    1. Reusing existing implementation"),o.push("    2. Extracting to shared utility"),o.push("    3. Using different name if intentionally different");break}}catch{}}}}let i=ps(s);if(i.length>0){o.push("COPY-PASTE: Repeated code blocks detected:");for(let u of i.slice(0,5))o.push(`  ${u}`);o.push("  Refactor repeated logic into functions")}let c=ls(s,t);if(n.push(...c.errors),o.push(...c.warnings),n.length>0){let u=`Duplicate code violation in ${t}. See stderr for details.`;return k(u)}if(o.length>0){let u=`Potential code duplication detected in ${t}. Review warnings on stderr.`;return k(u)}return a()}import{existsSync as W,readFileSync as yt,readdirSync as fs}from"node:fs";function kt(e){let t=m(),s=[];s.push("::group::LLM Evaluation Summary");let n=`${t}/eval_results.json`;if(W(n)){s.push("Evaluation results found:");try{let i=yt(n,"utf8"),c=JSON.parse(i);if(typeof c=="object"&&c!==null){for(let[u,p]of Object.entries(c))if(typeof p=="number"){let g=Number.isInteger(p)?p.toString():p.toFixed(2);s.push(`  ${u}: ${g}`)}}}catch{try{let c=yt(n,"utf8").split(`
`).slice(0,20);s.push(...c)}catch{s.push("  (Unable to read file)")}}}let o=`${t}/.deepeval`;if(W(o)){s.push(""),s.push("DeepEval results directory found");try{let i=fs(o).slice(0,5);for(let c of i)s.push(`  ${c}`)}catch{}}let r=`${t}/ragas_results.json`;W(r)&&(s.push(""),s.push("RAGAS evaluation results found")),s.push(""),s.push("Evaluation complete - review metrics above"),s.push("::endgroup::");for(let i of s)process.stderr.write(i+`
`);return a()}import{existsSync as $,appendFileSync as ds,mkdirSync as ms,readdirSync as gs}from"node:fs";function _t(e){let t=v(),s=m(),n=`${t}/evidence-collector.log`;try{ms(t,{recursive:!0})}catch{}let o=new Date().toISOString().replace("T"," ").slice(0,19),r=[];r.push(`[${o}] Evidence Collection`),r.push("Recent command results:");let i=process.env.CC_LAST_EXIT_CODE;i&&r.push(`  Last exit code: ${i}`),($(`${s}/pytest.xml`)||$(`${s}/junit.xml`))&&r.push("  Test results: Found (XML format)");let c=`${s}/test-results`;if($(c)){r.push("  Test results directory: Found");try{let u=gs(c).slice(0,5);for(let p of u)r.push(`    ${p}`)}catch{}}($(`${s}/.coverage`)||$(`${s}/coverage`))&&r.push("  Coverage data: Found"),($(`${s}/lint-results.json`)||$(`${s}/eslint-report.json`))&&r.push("  Lint results: Found"),r.push("Evidence verification complete.");try{ds(n,r.join(`
`)+`
`)}catch{}return a()}import{basename as hs}from"node:path";function ys(e){return e.includes("/shared/")?"shared":e.includes("/lib/")?"lib":e.includes("/utils/")?"utils":e.includes("/components/")&&!e.includes("/features/")?"components":e.includes("/hooks/")&&!e.includes("/features/")?"hooks":e.includes("/features/")?"features":e.includes("/app/")||e.includes("/pages/")?"app":e.includes("/repositories/")?"repositories":e.includes("/services/")&&e.endsWith(".py")?"services":e.includes("/routers/")?"routers":null}function vt(e){let t=E(e);if(t)return t;let s=e.tool_input.file_path||"",n=e.tool_input.content||e.tool_result||"";if(!s||!n)return a();let o=ys(s);if(!o)return a();let r=[];if(/\.(ts|tsx|js|jsx)$/.test(s))switch(o){case"shared":case"lib":case"utils":/from ['"](@\/|\.\.\/)*(features|app)\//.test(n)&&r.push(`${o}/ cannot import from features/ or app/`);break;case"components":case"hooks":/from ['"](@\/|\.\.\/)*(features|app)\//.test(n)&&r.push(`${o}/ cannot import from features/ or app/`);break;case"features":/from ['"](@\/|\.\.\/)*app\//.test(n)&&r.push("features/ cannot import from app/");break}if(s.endsWith(".py"))switch(o){case"repositories":/from (app\.)?(services|routers)/.test(n)&&r.push("repositories/ cannot import from services/ or routers/");break;case"services":/from (app\.)?routers\.[a-z]/.test(n)&&(/from (app\.)?routers\.(deps|dependencies)/.test(n)||r.push("services/ cannot import from routers/"));break}if(r.length>0){let c=`Import direction violation in ${hs(s)||s}: ${r[0]}`;return y("import-direction-enforcer",`BLOCKED: ${c}`),h(c)}return a()}import{existsSync as ks,readFileSync as _s}from"node:fs";import{execSync as C}from"node:child_process";function vs(){try{return C("git worktree list --porcelain",{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).split(`
`).filter(t=>t.startsWith("worktree ")).map(t=>t.replace("worktree ",""))}catch{return[]}}function xs(e){try{return C("git rev-parse --abbrev-ref HEAD",{cwd:e,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{return"unknown"}}function Ss(e,t){try{let s=C(`git status --short "${t}"`,{cwd:e,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]});return/^.M|^M.|^A/.test(s)}catch{return!1}}function Rs(e,t){try{let s=parseInt(C(`git rev-list --count ${e}..${t}`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim(),10),n=parseInt(C(`git rev-list --count ${t}..${e}`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim(),10);return{ahead:s||0,behind:n||0}}catch{return{ahead:0,behind:0}}}function xt(e){let t=e.tool_input.file_path||"",s=e.tool_input.content||e.tool_result||"";if(!t||!s)return a();let n=vs();if(n.length===0)return a();let o=[],r=[],i=R()||m(),c=i,u=t.replace(i+"/","").replace(i,"");for(let f of n){if(f===c)continue;let l=`${f}/${u}`;if(!ks(l))continue;let d=xs(f);if(Ss(f,u)){r.push({worktree:f,branch:d,status:"modified"});try{let H=_s(l,"utf8"),S=s.split(`
`),_=H.split(`
`),P=Math.abs(S.length-_.length);P>10&&(o.push(`OVERLAP: Significant changes in both branches (~${P} lines)`),o.push(`  Branch: ${d}`),o.push("  High risk of merge conflict"))}catch{}}}let p=I(),g=ot();if(p!==g){let{ahead:f,behind:l}=Rs(g,p);l>10&&(o.push(`DIVERGENCE: Current branch is ${l} commits behind ${g}`),o.push("  Consider rebasing before continuing development"),o.push("  This reduces merge conflict risk"))}if(r.length>0){o.unshift("MERGE CONFLICT RISK: Concurrent modifications detected"),o.unshift(""),o.unshift(`File: ${t}`);for(let f of r)o.push(`  Branch: ${f.branch}`),o.push(`  Status: ${f.status}`),o.push(`  Path: ${f.worktree}`);o.push(""),o.push("Recommendations:"),o.push("  1. Coordinate changes with other instances"),o.push("  2. Consider splitting work to avoid overlapping files"),o.push("  3. Communicate before merging")}if(o.length>0){let f=`Potential merge conflicts detected in ${t}. Review warnings on stderr.`;return process.stderr.write(o.join(`
`)+`
`),k(f)}return a()}import{existsSync as z,readFileSync as bs}from"node:fs";import{execSync as $s}from"node:child_process";function x(e,t){try{return $s(e,{cwd:t||m(),encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}).trim()}catch{return""}}function St(e){let t=e.tool_input?.command||"";if(!/\b(gh\s+pr\s+merge|git\s+merge|git\s+rebase)\b/i.test(t))return a();let s=e.tool_input.target_branch||"main",n=I();if(n===s)return process.stderr.write(`Already on target branch ${s}
`),a();process.stderr.write(`Checking merge readiness: ${n} -> ${s}

`);let o=R()||m(),r=[],i=[],c=[];if(process.stderr.write(`1. Checking for uncommitted changes...
`),nt()){let l=x("git status --short");r.push("Uncommitted changes detected:"),r.push(l.split(`
`).slice(0,10).join(`
`))}else c.push("No uncommitted changes");process.stderr.write(`2. Checking branch divergence...
`),x(`git fetch origin ${s}`);let u=parseInt(x(`git rev-list --count origin/${s}..${n}`)||"0",10),p=parseInt(x(`git rev-list --count ${n}..origin/${s}`)||"0",10);if(process.stderr.write(`   Ahead: ${u} commits, Behind: ${p} commits
`),p>20?(r.push(`Branch is significantly behind ${s} (${p} commits)`),r.push(`Rebase or merge ${s} before proceeding`)):p>5?(i.push(`Branch is behind ${s} by ${p} commits`),i.push("Consider rebasing for easier merge")):c.push(`Branch is up to date (behind by ${p})`),process.stderr.write(`3. Checking for merge conflicts...
`),x(`git merge --no-commit --no-ff origin/${s}`).includes("CONFLICT")){let l=x("git diff --name-only --diff-filter=U");r.push(`Merge conflicts detected with ${s}:`);for(let d of l.split(`
`).slice(0,10))d&&r.push(`  - ${d}`);r.push("Resolve conflicts before merging"),x("git merge --abort")}else c.push("No merge conflicts detected"),x("git merge --abort");process.stderr.write(`4. Running quality gates on changed files...
`);let f=x(`git merge-base ${n} origin/${s}`);if(f){let d=x(`git diff --name-only ${f} ${n}`).split(`
`).filter(Boolean).length;process.stderr.write(`   Checking ${d} changed files...
`),c.push("Quality gates check performed")}else i.push("Cannot determine merge base - skipping file checks");if(process.stderr.write(`5. Checking test suite...
`),z(`${o}/package.json`)&&bs(`${o}/package.json`,"utf8").includes('"test":')&&c.push("Frontend test script found"),(z(`${o}/pytest.ini`)||z(`${o}/pyproject.toml`))&&c.push("Backend test configuration found"),process.stderr.write(`
`),process.stderr.write("=".repeat(60)+`
`),process.stderr.write(`
MERGE READINESS REPORT

`),process.stderr.write(`Branch: ${n} -> ${s}

`),c.length>0){process.stderr.write(`PASSED CHECKS:
`);for(let l of c)process.stderr.write(`   ${l}
`);process.stderr.write(`
`)}if(i.length>0){process.stderr.write(`WARNINGS:
`);for(let l of i)process.stderr.write(`   ${l}
`);process.stderr.write(`
`)}if(r.length>0){process.stderr.write(`BLOCKERS:
`);for(let l of r)process.stderr.write(`   ${l}
`);return process.stderr.write(`
MERGE NOT READY - Fix blockers before merging
`),{continue:!1,stopReason:"Merge not ready - blockers detected"}}return i.length>0?(process.stderr.write(`MERGE READY WITH WARNINGS
`),process.stderr.write(`Review warnings before proceeding with merge
`)):(process.stderr.write(`MERGE READY - All checks passed!
`),process.stderr.write(`You can safely merge this branch
`)),a()}import{existsSync as Es,readFileSync as ws}from"node:fs";import{execSync as Ts}from"node:child_process";import{basename as Is}from"node:path";function Rt(e){let t=e.tool_input?.file_path||process.env.CC_TOOL_FILE_PATH||"";if(!t)return a();if(!t.includes("alembic/versions")||!t.endsWith(".py"))return a();if(!Es(t))return a();process.stderr.write(`::group::Migration Validation: ${Is(t)}
`);let s=[],n;try{n=ws(t,"utf8")}catch{return s.push("Cannot read migration file"),k(`Migration validation failed for ${t}`)}n.includes("def upgrade")||s.push("Missing upgrade() function in migration"),n.includes("def downgrade")||s.push("Missing downgrade() function in migration"),/^revision = /m.test(n)||s.push("Missing revision ID in migration");try{Ts(`python3 -m py_compile "${t}"`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{s.push("Python syntax error in migration")}if(s.length>0){process.stderr.write(`::error::Migration validation failed
`);for(let r of s)process.stderr.write(`  - ${r}
`);process.stderr.write(`::endgroup::
`),y("migration-validator",`BLOCKED: ${s[0]}`);let o=`Migration validation failed for ${t}. See stderr for details.`;return k(o)}return process.stderr.write(`Migration file is valid
`),process.stderr.write(`::endgroup::
`),a()}import{existsSync as As}from"node:fs";function bt(e){let t=e.tool_input.file_path||"",s=e.tool_input.content||e.tool_result||"";if(!t||!s)return a();let o=`${R()||m()}/.claude/context/knowledge/patterns/established.json`;if(!As(o))return a();let r=[],i=[];if(t.endsWith(".py")&&(t.includes("/backend/")||t.includes("/api/"))&&(t.includes("/routers/")&&/from.*repositories.*import/.test(s)&&(r.push("PATTERN: Router imports repository directly"),r.push("  Established pattern: routers -> services -> repositories"),r.push("  Import from services/ layer instead")),t.includes("/services/")&&/from.*routers.*import/.test(s)&&(r.push("PATTERN: Service imports router (circular dependency)"),r.push("  Established pattern: Services are independent of HTTP layer")),/from sqlalchemy import/.test(s)&&(/from sqlalchemy\.ext\.asyncio import/.test(s)||/Session|sessionmaker/.test(s)&&(r.push("PATTERN: Using sync SQLAlchemy instead of async"),r.push("  Established pattern: All DB operations use async/await"),r.push("  Import: from sqlalchemy.ext.asyncio import AsyncSession"))),/from pydantic import.*BaseModel/.test(s)&&(/@validator\(/.test(s)&&(r.push("PATTERN: Using Pydantic v1 @validator decorator"),r.push("  Established pattern: Pydantic v2 with @field_validator"),r.push("  Update: @field_validator('field_name', mode='after')")),/@root_validator/.test(s)&&(r.push("PATTERN: Using Pydantic v1 @root_validator decorator"),r.push("  Established pattern: Pydantic v2 with @model_validator"),r.push("  Update: @model_validator(mode='after')")))),/\.(ts|tsx|js|jsx)$/.test(t)&&(t.includes("/frontend/")||t.includes("/src/"))&&(/React\.FC</.test(s)&&(r.push("PATTERN: Using React.FC instead of explicit Props type"),r.push("  Established pattern: function Component(props: Props): React.ReactNode"),r.push("  Remove React.FC, use explicit function declaration")),/fetch\(|axios\./.test(s)&&(/from ['"]zod['"]/.test(s)||(r.push("PATTERN: API call without Zod validation"),r.push("  Established pattern: All API responses validated with Zod"),r.push("  Import: import { z } from 'zod'"))),/<form/.test(s)&&(/useFormStatus|useActionState|useOptimistic/.test(s)||(i.push("PATTERN: Form without React 19 form hooks"),i.push("  Established pattern: Use useFormStatus for pending state"),i.push("  Consider: useOptimistic for optimistic updates"))),/new Date.*toLocaleDateString|toLocaleString/.test(s)&&(r.push("PATTERN: Direct date formatting instead of centralized utility"),r.push("  Established pattern: Use @/lib/dates helpers"),r.push("  Import: import { formatDate, formatDateShort } from '@/lib/dates'"))),(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(t)||/test_.*\.py$/.test(t))&&(/\/\/ Arrange|\/\/ Act|\/\/ Assert|# Arrange|# Act|# Assert/i.test(s)||(i.push("PATTERN: AAA pattern comments missing"),i.push("  Established pattern: Structure tests with Arrange-Act-Assert"),i.push("  Add comments for clarity in complex tests")),/\.(ts|tsx|js|jsx)$/.test(t)&&/jest\.mock.*fetch|global\.fetch/.test(s)&&(r.push("PATTERN: Using jest.mock for fetch instead of MSW"),r.push("  Established pattern: Use MSW for API mocking"),r.push("  Import: import { http, HttpResponse } from 'msw'")),t.endsWith(".py")&&/class Test.*setUp/.test(s)&&(r.push("PATTERN: Using unittest setUp instead of pytest fixtures"),r.push("  Established pattern: Use pytest fixtures"),r.push("  Convert: @pytest.fixture\\ndef setup_data():"))),(t.includes("/llm/")||t.includes("/ai/")||t.includes("/agent/"))&&(/prompt.*\{.*id.*\}|f".*\{.*\.id\}.*"/.test(s)&&(r.push("PATTERN: Database IDs in LLM prompts"),r.push("  Established pattern: IDs flow around LLM, not through it"),r.push("  Pass IDs via metadata, join results after LLM processing")),/await.*openai|await.*anthropic|await.*llm/.test(s)&&(/asyncio\.timeout|asyncio\.wait_for|Promise\.race/.test(s)||(r.push("PATTERN: LLM call without timeout protection"),r.push("  Established pattern: Wrap all LLM calls with timeout"),r.push("  Python: async with asyncio.timeout(30):"),r.push("  TypeScript: await Promise.race([call, timeout])")))),r.length>0)return h(`Pattern consistency violations detected in ${t}`);if(i.length>0){process.stderr.write(`WARNING: Pattern consistency issues detected
`),process.stderr.write(`File: ${t}

`);for(let c of i)process.stderr.write(`  ${c}
`)}return a()}var Cs=[/sk-[a-zA-Z0-9]{20,}/,/ghp_[a-zA-Z0-9]{36}/,/AKIA[A-Z0-9]{16}/,/xox[baprs]-[a-zA-Z0-9-]+/,/tvly-[a-zA-Z0-9-]{10,}/,/m0-[a-zA-Z0-9]{10,}/],Ds=[/password\s*[:=]\s*['"][^'"]+['"]/i,/secret\s*[:=]\s*['"][^'"]+['"]/i];function $t(e){let t=e.tool_result||e.output||"";if(!t)return a();for(let s of Cs)if(s.test(t)){process.stderr.write(`::warning::Potential API key detected in output - verify redaction
`);break}for(let s of Ds)if(s.test(t)){process.stderr.write(`::warning::Potential hardcoded credential in output
`);break}return a()}import{appendFileSync as Hs,mkdirSync as Ps}from"node:fs";function Et(e){let t=v(),s=`${t}/review-summary.log`;try{Ps(t,{recursive:!0})}catch{}let o=`[${new Date().toISOString().replace("T"," ").slice(0,19)}] Code Review Summary
Review checklist:
  [ ] All blocking issues addressed
  [ ] Non-blocking suggestions noted
  [ ] Tests pass
  [ ] No security concerns
  [ ] Documentation updated if needed

Conventional comment prefixes used:
  - blocking: Must fix before merge
  - suggestion: Consider this improvement
  - nitpick: Minor style issue
  - question: Needs clarification
  - praise: Good work!
`;try{Hs(s,o+`
`)}catch{}return a()}import{appendFileSync as Os,mkdirSync as js}from"node:fs";function wt(e){let t=v(),s=`${t}/security-summary.log`;try{js(t,{recursive:!0})}catch{}let o=`[${new Date().toISOString().replace("T"," ").slice(0,19)}] Security Scan Complete
Review findings for:
  - Critical/High vulnerabilities (fix immediately)
  - Dependency CVEs (update packages)
  - Hardcoded secrets (move to env vars)
  - OWASP Top 10 violations

Next steps:
  1. Triage findings by severity
  2. Create issues for critical/high
  3. Update dependencies with CVEs
`;try{Os(s,o+`
`)}catch{}return a()}import{basename as Ns,dirname as Ls}from"node:path";var Tt=4;function It(e){let t=E(e);if(t)return t;let s=e.tool_input.file_path||"";if(!s)return a();let n=s.replace(/\\/g,"/"),o=[],r=Ns(n);if(n.includes("/src/")||n.includes("/app/")){let i="";n.includes("/src/")?i=n.split("/src/")[1]||"":i=n.split("/app/")[1]||"";let c=i.split(/[/\\]/).filter(Boolean).length;c>Tt&&o.push(`NESTING: Max depth exceeded - ${c} levels (max: ${Tt})`)}if(/^index\.(ts|tsx|js)$/.test(r)&&!n.includes("/app/")&&!/\/(node_modules|dist|build)\//.test(n)&&o.push("BARREL: Barrel files (index.ts) are discouraged - import directly from source"),/\.(tsx|ts|jsx|js)$/.test(n)&&(/^[A-Z][a-zA-Z0-9]*\.(tsx|jsx)$/.test(r)&&(/(components\/|features\/|app\/|pages\/)/.test(n)||o.push("COMPONENT: React components must be in components/, features/, or app/")),/^use[A-Z][a-zA-Z0-9]*\.(ts|tsx)$/.test(r)&&(/(hooks\/|\/hooks\/)/.test(n)||o.push("HOOK: Custom hooks must be in hooks/ directory"))),n.endsWith(".py")){let i=Ls(n);/^(router_|routes_|api_).*\.py$/.test(r)&&!i.endsWith("/routers")&&!i.endsWith("routers")&&o.push("ROUTER: Router files must be in routers/ directory"),/_service\.py$/.test(r)&&!i.endsWith("/services")&&!i.endsWith("services")&&o.push("SERVICE: Service files must be in services/ directory"),/_(repository|repo)\.py$/.test(r)&&!i.endsWith("/repositories")&&!i.endsWith("repositories")&&o.push("REPOSITORY: Repository files must be in repositories/ directory")}if(o.length>0){let i=`Structure violation: ${o[0]}`;return y("structure-location-validator",`BLOCKED: ${i}`),h(i)}return a()}import{basename as Fs}from"node:path";function Ms(e){return!!(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(e)||/(^|\/)test_[^/]*\.py$/.test(e)||/_test\.py$/.test(e))}function At(e){let t=E(e);if(t)return t;let s=e.tool_input.file_path||"";if(!s)return a();let n=Fs(s),o=Ms(s);if(o&&!/(tests\/|__tests__\/|\/test\/|test\/)/.test(s)){let r=`Test file must be in tests/, __tests__/, or test/ directory: ${n}`;return y("test-location-validator",`BLOCKED: ${r}`),h(r)}if(!o&&/(tests\/|__tests__\/|\/test\/)/.test(s)){let i=[/^(conftest|fixtures|factories|mocks|__init__|setup|helpers|utils)\.py$/,/^(setup|helpers|utils|mocks|fixtures)\.(ts|js)$/].some(u=>u.test(n)),c=/\/(fixtures|mocks|factories|__mocks__)\//.test(s);if(!i&&!c){let u=`Source files cannot be in test directories: ${n}`;return y("test-location-validator",`BLOCKED: ${u}`),h(u)}}if(/\.(ts|tsx|js|jsx)$/.test(s)&&/(tests\/|__tests__)/.test(s)){if(/^(setup|jest|vitest|config|helpers|utils|mocks)\./.test(n))return a();if(!/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(n)){let r=`Test files must use .test.ts or .spec.ts suffix: ${n}`;return y("test-location-validator",`BLOCKED: ${r}`),h(r)}}if(s.endsWith(".py")&&/(tests\/|\/test\/)/.test(s)){if(/^(conftest|__init__|fixtures|factories|mocks|helpers)\.py$/.test(n))return a();if(!/^test_.*\.py$/.test(n)&&!/_test\.py$/.test(n)){let r=`Python test files must be named test_*.py or *_test.py: ${n}`;return y("test-location-validator",`BLOCKED: ${r}`),h(r)}}return a()}function Us(e){return!!(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(e)||/(^|\/)test_[^/]*\.py$/.test(e)||/_test\.py$/.test(e))}function Ct(e){let t=e.tool_input?.file_path||"",s=e.tool_input?.content||e.tool_result||"";if(!t||!s)return a();if(!Us(t))return a();let n=[];if(/\.(ts|tsx|js|jsx)$/.test(t)){let o=s.match(/(test|it)\(['"][^'"]{1,10}['"]/g);o&&o.some(u=>/test[0-9]|works|^test$/i.test(u))&&(n.push("Test names too short or generic. Use descriptive names:"),n.push("  BAD:  test('test1'), test('works')"),n.push("  GOOD: test('should return user when ID exists')")),/^let [a-zA-Z_][a-zA-Z0-9_]* =/m.test(s)&&(/beforeEach\s*\(\s*(async\s*)?\(\s*\)\s*=>/.test(s)||(n.push("Shared mutable state detected without beforeEach reset:"),n.push("  Add beforeEach(() => { /* reset state */ }) to ensure test isolation")));let r=(s.match(/expect\(/g)||[]).length,i=(s.match(/(test|it)\s*\(/g)||[]).length||1,c=Math.floor(r/i);c>5&&(n.push(`High assertion count (avg ${c} per test):`),n.push("  Consider splitting into focused tests with 1-3 assertions each"),n.push("  Or add AAA comments (// Arrange, // Act, // Assert)")),/console\.(log|warn|error)\(/.test(s)&&(n.push("console.log found in test file:"),n.push("  Remove debugging statements before committing"),n.push("  Use proper assertions instead")),/(test|it|describe)\.only\(/.test(s)&&(n.push(".only() found - this skips other tests:"),n.push("  Remove .only() before committing")),/(test|it|describe)\.skip\(/.test(s)&&(/TODO|FIXME|skip.*because|temporarily/i.test(s)||(n.push(".skip() found without explanation:"),n.push("  Add a comment explaining why the test is skipped"),n.push("  Example: test.skip('reason: waiting for API fix')")))}return t.endsWith(".py")&&(/def test[A-Z]/.test(s)&&(n.push("Test names must use snake_case, not camelCase:"),n.push("  BAD:  def testUserCreation()"),n.push("  GOOD: def test_user_creation()")),/def (setUp|tearDown|setUpClass|tearDownClass)\s*\(/.test(s)&&(n.push("Use pytest fixtures instead of unittest setUp/tearDown:"),n.push("  BAD:  def setUp(self): ..."),n.push("  GOOD: @pytest.fixture\\n        def setup_data(): ...")),/class Test.*:/.test(s)&&(/^\s+[a-z_]+ = \[\]/m.test(s)||/^\s+[a-z_]+ = \{\}/m.test(s))&&(n.push("Class-level mutable defaults can cause test pollution:"),n.push("  BAD:  class TestUser:\\n            items = []"),n.push("  GOOD: Use @pytest.fixture to create fresh instances")),/^\s+print\(/m.test(s)&&(n.push("print() found in test file:"),n.push("  Remove debugging statements before committing"),n.push("  Use proper assertions or pytest's capfd fixture")),(/@pytest\.mark\.skip\s*$/.test(s)||/@pytest\.mark\.skip\(\s*\)/.test(s))&&(n.push("@pytest.mark.skip without reason:"),n.push("  Add reason: @pytest.mark.skip(reason='waiting for fix')")),/async def test_/.test(s)&&(/@pytest\.mark\.asyncio/.test(s)||(n.push("Async test found without @pytest.mark.asyncio:"),n.push("  Add: @pytest.mark.asyncio"),n.push("  Or set asyncio_mode = auto in pytest.ini")))),n.length>0?(y("test-pattern-validator",`BLOCKED: ${n[0]}`),h(`Test pattern violations detected in ${t}`)):a()}import{existsSync as Dt}from"node:fs";import{execSync as D}from"node:child_process";import{basename as Z,dirname as V}from"node:path";function Bs(e){let t=e;for(;t!=="/";){if(Dt(`${t}/package.json`))return t;t=V(t)}return null}function Ht(e){let t=e.tool_input?.file_path||process.env.CC_TOOL_FILE_PATH||"";if(!t)return a();if(/test.*\.py$/.test(t)||/_test\.py$/.test(t)){process.stderr.write(`::group::Auto-running Python test: ${Z(t)}
`);let s=V(t);try{if(Dt(`${s}/pyproject.toml`))try{D("command -v poetry",{stdio:["pipe","pipe","pipe"]});let o=D(`poetry run pytest "${t}" -v --tb=short`,{cwd:s,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(o.join(`
`)+`
`)}catch{}try{D("command -v pytest",{stdio:["pipe","pipe","pipe"]});let o=D(`pytest "${t}" -v --tb=short`,{cwd:s,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(o.join(`
`)+`
`)}catch{process.stderr.write(`pytest not found - skipping auto-run
`)}}catch(n){n instanceof Error&&process.stderr.write(`Test execution error: ${n.message}
`)}process.stderr.write(`::endgroup::
`)}if(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(t)){process.stderr.write(`::group::Auto-running TypeScript test: ${Z(t)}
`);let s=Bs(V(t));if(s)try{let n=Z(t).replace(/\.[^.]+$/,"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),r=D(`npm test -- --testPathPattern="${n}"`,{cwd:s,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(r.join(`
`)+`
`)}catch(n){n instanceof Error&&process.stderr.write(`Test execution error: ${n.message}
`)}process.stderr.write(`::endgroup::
`)}return a()}var Pt={"skill/backend-file-naming":it,"skill/decision-processor":pt,"skill/backend-layer-validator":lt,"skill/coverage-check":ft,"skill/coverage-threshold-gate":dt,"skill/cross-instance-test-validator":mt,"skill/di-pattern-enforcer":gt,"skill/duplicate-code-detector":ht,"skill/eval-metrics-collector":kt,"skill/evidence-collector":_t,"skill/import-direction-enforcer":vt,"skill/merge-conflict-predictor":xt,"skill/merge-readiness-checker":St,"skill/migration-validator":Rt,"skill/pattern-consistency-enforcer":bt,"skill/redact-secrets":$t,"skill/review-summary-generator":Et,"skill/security-summary":wt,"skill/structure-location-validator":It,"skill/test-location-validator":At,"skill/test-pattern-validator":Ct,"skill/test-runner":Ht};function Zr(e){return Pt[e]}function Vr(){return Object.keys(Pt)}export{An as analyzeStagedChanges,$n as escapeRegex,le as estimateTokenCount,me as extractIssueNumber,pn as getCachedBranch,I as getCurrentBranch,ot as getDefaultBranch,un as getEnvFile,Rn as getField,de as getGitStatus,Zr as getHook,v as getLogDir,ie as getLogLevel,B as getPluginRoot,m as getProjectDir,R as getRepoRoot,U as getSessionId,ge as getStagedFiles,nt as hasUncommittedChanges,Pt as hooks,Gs as isBashInput,zs as isEditInput,In as isGitRepo,fe as isProtectedBranch,Zs as isReadInput,Ws as isWriteInput,Vr as listHooks,y as logHook,vn as logPermissionFeedback,bn as normalizeCommand,ln as normalizeLineEndings,mn as outputAllowWithContext,h as outputBlock,kn as outputDeny,gn as outputError,ae as outputPromptContext,xn as outputPromptContextBudgeted,fn as outputSilentAllow,a as outputSilentSuccess,yn as outputStderrWarning,hn as outputWarning,k as outputWithContext,dn as outputWithNotification,_n as outputWithUpdatedInput,Sn as readHookInput,ce as shouldLog,Cn as validateBranchName};
//# sourceMappingURL=skill.mjs.map
