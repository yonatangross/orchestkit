// OrchestKit Hooks - stop bundle
// Generated: 2026-01-28T12:57:14.892Z

var pt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,n)=>(typeof require<"u"?require:e)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});function rs(t){return typeof t.command=="string"}function is(t){return typeof t.file_path=="string"&&typeof t.content=="string"}function cs(t){return typeof t.file_path=="string"&&typeof t.old_string=="string"&&typeof t.new_string=="string"}function as(t){return typeof t.file_path=="string"&&t.content===void 0}import{appendFileSync as dt,existsSync as gt,statSync as de,renameSync as ge,mkdirSync as fe,readSync as me}from"node:fs";import{execSync as ye}from"node:child_process";function ft(){return process.env.CLAUDE_PLUGIN_ROOT?`${process.env.HOME||process.env.USERPROFILE||"/tmp"}/.claude/logs/ork`:`${p()}/.claude/logs`}function p(){return process.env.CLAUDE_PROJECT_DIR||"."}function mt(){return process.env.CLAUDE_PLUGIN_ROOT||process.env.CLAUDE_PROJECT_DIR||"."}function f(){return process.env.CLAUDE_SESSION_ID||`fallback-${process.pid}-${Date.now()}`}function ds(t){if(process.env.ORCHESTKIT_BRANCH)return process.env.ORCHESTKIT_BRANCH;try{let e=ye("git branch --show-current",{cwd:t||p(),encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim();return process.env.ORCHESTKIT_BRANCH=e,e}catch{return"unknown"}}function ke(){return process.env.ORCHESTKIT_LOG_LEVEL||"warn"}function he(t){let e=["debug","info","warn","error"];return e.indexOf(t)>=e.indexOf(ke())}function u(){return{continue:!0,suppressOutput:!0}}function gs(){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{permissionDecision:"allow"}}}function fs(t){return{continue:!1,stopReason:t,hookSpecificOutput:{permissionDecision:"deny",permissionDecisionReason:t}}}function yt(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PostToolUse",additionalContext:t}}}function Se(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:t}}}function ms(t,e){let n={continue:!0,hookSpecificOutput:{hookEventName:"PreToolUse",additionalContext:t,permissionDecision:"allow"}};return e?n.systemMessage=e:n.suppressOutput=!0,n}function ys(t){return{continue:!0,systemMessage:t}}function ks(t){return{continue:!0,systemMessage:`\u26A0 ${t}`}}function hs(t){return{continue:!1,stopReason:t,hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"deny",permissionDecisionReason:t}}}var _e=200*1024,be=100*1024;function kt(t,e){if(gt(t))try{if(de(t).size>e){let s=`${t}.old.${Date.now()}`;ge(t,s)}}catch{}}function ht(t){gt(t)||fe(t,{recursive:!0})}function r(t,e,n="debug"){if(!he(n))return;let s=ft(),o=`${s}/hooks.log`;try{ht(s),kt(o,_e);let i=new Date().toISOString().replace("T"," ").slice(0,19);dt(o,`[${i}] [${n.toUpperCase()}] [${t}] ${e}
`)}catch{}}function Ss(t,e,n){let s=ft(),o=`${s}/permission-feedback.log`;try{ht(s),kt(o,be);let i=new Date().toISOString(),c=n?.tool_name||process.env.HOOK_TOOL_NAME||"unknown",a=n?.session_id||f();dt(o,`${i} | ${t} | ${e} | tool=${c} | session=${a}
`)}catch{}}function we(t){if(!t)return 0;let s=(t.match(/[{};()=><]/g)||[]).length/t.length>.03?2.8:3.5;return Math.ceil(t.length/s)}function _s(t,e,n,s,o){let i=we(t);return s&&s.isOverBudget(n)?(r(e,`Budget exhausted for ${n}, suppressing ${i}t`),u()):(o&&o.trackTokenUsage(e,n,i),Se(t))}function bs(){try{let t=[],n=Buffer.allocUnsafe(256),s,o=0;for(;;)try{if(s=me(o,n,0,256,null),s===0)break;t.push(Buffer.from(n.subarray(0,s)))}catch{break}let i=Buffer.concat(t).toString("utf8").trim();return i?JSON.parse(i):{tool_name:"",session_id:f(),tool_input:{}}}catch{return{tool_name:"",session_id:f(),tool_input:{}}}}function ws(t,e){let n=e.replace(/^\./,"").split("."),s=t;for(let o of n){if(s==null)return;s=s[o]}return s}function $s(t){return t.replace(/\\\s*[\r\n]+/g," ").replace(/\n/g," ").replace(/\s+/g," ").trim()}function xs(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}import{existsSync as wt,readFileSync as $e,writeFileSync as xe,mkdirSync as ve}from"node:fs";import{createHash as Ie}from"node:crypto";var St=500,Y=3,_t=15,bt=3,De=.9;function $t(){return`${p()}/.claude/feedback/calibration-data.json`}function Re(){let t=`${p()}/.claude/feedback`;if(!wt(t))try{ve(t,{recursive:!0})}catch{}}function x(){let t=$t();if(wt(t))try{return JSON.parse($e(t,"utf8"))}catch{r("calibration-engine","Failed to load calibration data, using defaults")}return{schemaVersion:"1.0.0",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),records:[],adjustments:[],stats:{totalDispatches:0,successRate:0,avgConfidence:0,topAgents:[]}}}function V(t){Re();let e=$t();t.updatedAt=new Date().toISOString();try{xe(e,JSON.stringify(t,null,2)),r("calibration-engine","Saved calibration data")}catch(n){r("calibration-engine",`Failed to save calibration data: ${n}`)}}function Te(t){return Ie("sha256").update(t.toLowerCase().trim()).digest("hex").slice(0,16)}function Ts(t,e,n,s,o,i,c){let a=x(),d={timestamp:new Date().toISOString(),sessionId:f(),agent:e,promptHash:Te(t),matchedKeywords:n,dispatchConfidence:s,outcome:o,durationMs:i,feedback:c};a.records.push(d),a.records.length>St&&(a.records=a.records.slice(-St)),Oe(a,d),Ae(a),V(a),r("calibration-engine",`Recorded outcome: ${e} -> ${o} (conf: ${s})`)}function Oe(t,e){let n=e.outcome==="success",s=e.outcome==="failure"||e.outcome==="rejected";if(!n&&!s)return;let o=n?bt:-bt;for(let i of e.matchedKeywords){let c=t.adjustments.find(a=>a.keyword===i&&a.agent===e.agent);c?(c.adjustment=Math.max(-_t,Math.min(_t,c.adjustment+o)),c.sampleCount++,c.lastUpdated=new Date().toISOString()):t.adjustments.push({keyword:i,agent:e.agent,adjustment:o,sampleCount:1,lastUpdated:new Date().toISOString()})}}function xt(t){let e=Date.now(),n=1440*60*1e3;for(let s of t.adjustments){let o=e-new Date(s.lastUpdated).getTime();Math.floor(o/n)>7&&(s.adjustment=Math.round(s.adjustment*De),Math.abs(s.adjustment)<1&&(s.adjustment=0))}t.adjustments=t.adjustments.filter(s=>s.adjustment!==0)}function Ae(t){let e=t.records;if(e.length===0)return;t.stats.totalDispatches=e.length;let n=e.filter(i=>i.outcome==="success").length;t.stats.successRate=n/e.length;let s=e.reduce((i,c)=>i+c.dispatchConfidence,0)/e.length;t.stats.avgConfidence=Math.round(s);let o=new Map;for(let i of e){let c=o.get(i.agent)||{count:0,success:0};c.count++,i.outcome==="success"&&c.success++,o.set(i.agent,c)}t.stats.topAgents=Array.from(o.entries()).map(([i,c])=>({agent:i,count:c.count,successRate:c.success/c.count})).sort((i,c)=>c.count-i.count).slice(0,10)}function Os(){return x().adjustments.filter(e=>e.sampleCount>=Y)}function As(t){let n=x().records.filter(o=>o.agent===t);return n.length<Y?null:n.filter(o=>o.outcome==="success").length/n.length}function Ps(){return x().stats}function js(){return x().records.length>=Y}function vt(t){r("auto-remember-continuity","Hook triggered");let n=(t.project_dir||p()).split("/").pop()||"project",o=!!process.env.MEM0_API_KEY?"\n   [Optional] Also sync to mem0 cloud with `--mem0` flag for semantic search":"",i=`Before ending this session, consider preserving important context in the knowledge graph:

1. **Session Continuity** - If there's unfinished work or next steps:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "session-${n}",
     "entityType": "Session",
     "observations": ["What was done: [...]", "Next steps: [...]"]
   }]}
   \`\`\`${o}

2. **Important Decisions** - If architectural/design decisions were made:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "decision-[topic]",
     "entityType": "Decision",
     "observations": ["Decided: [...]", "Rationale: [...]"]
   }]}
   \`\`\`

3. **Patterns Learned** - If something worked well or failed:
   - Use \`/remember --success "pattern that worked"\`
   - Use \`/remember --failed "pattern that caused issues"\`

Skip if this was just a quick question/answer session.`;return r("auto-remember-continuity","Outputting memory prompt for session end"),{continue:!0,suppressOutput:!0}}import{existsSync as It,mkdirSync as Pe,readFileSync as je,writeFileSync as Dt}from"node:fs";function N(t){r("auto-save-context","Stop hook - auto-saving context (Protocol 2.0)");let n=`${t.project_dir||p()}/.claude/context/session`,s=`${n}/state.json`;try{It(n)||Pe(n,{recursive:!0})}catch{}let o=new Date().toISOString();try{if(It(s)){let i=je(s,"utf-8"),c=JSON.parse(i),a={$schema:c.$schema||"context://session/v1",_meta:c._meta||{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:c.session_id||null,started:c.started||null,last_activity:o,current_task:c.current_task||{description:"No active task",status:"pending"},next_steps:c.next_steps||[],blockers:c.blockers||[]};Dt(s,JSON.stringify(a,null,2)),r("auto-save-context","Updated session state timestamp")}else Dt(s,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:null,started:o,last_activity:o,current_task:{description:"No active task",status:"pending"},next_steps:[],blockers:[]},null,2)),r("auto-save-context","Created new session state (Protocol 2.0 compliant)")}catch(i){r("auto-save-context",`Error saving context: ${i}`)}return u()}import{existsSync as Rt,readFileSync as He}from"node:fs";import{execSync as Z}from"node:child_process";function Ce(t){let e=`${t}/.instance/id.json`;try{return Rt(e)&&JSON.parse(He(e,"utf-8")).instance_id||null}catch{return null}}function X(t,e){try{Z(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function Tt(t){let e=t.project_dir||p(),n=`${e}/.claude/coordination/.claude.db`;if(!Rt(n))return r("cleanup-instance","No coordination database, skipping cleanup"),u();let s=Ce(e);if(!s)return r("cleanup-instance","No instance ID to clean up"),u();r("cleanup-instance",`Cleaning up instance: ${s}`),r("cleanup-instance","Releasing all locks..."),X(n,`DELETE FROM file_locks WHERE instance_id = '${s}';`),r("cleanup-instance","All locks released");try{Z(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='work_claims';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(X(n,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${s}' AND status = 'active';`),r("cleanup-instance","Work claims handled"))}catch{}try{Z(`sqlite3 "${n}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='instances';"`,{encoding:"utf8",timeout:5e3}).trim()==="1"&&(X(n,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${s}';`),r("cleanup-instance","Instance status updated to terminated"))}catch{}return r("cleanup-instance","Multi-instance cleanup completed"),u()}import{existsSync as tt,mkdirSync as et,readFileSync as nt,writeFileSync as T}from"node:fs";var Q=10;function Ee(t){let e=`${t}/session/state.json`;if(!tt(e)){r("context-compressor","No session state to archive");return}try{let n=nt(e,"utf-8"),s=JSON.parse(n),o=s.session_id||`session-${new Date().toISOString().replace(/[:.]/g,"-")}`,i=`${t}/archive/sessions`;et(i,{recursive:!0});let c=`${i}/${o}.json`,a={...s,ended:new Date().toISOString(),archived:!0};T(c,JSON.stringify(a,null,2)),r("context-compressor",`Archived session to ${c}`),T(e,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always"},session_id:null,started:null,current_task:null,files_touched:[],decisions_this_session:[],blockers:[],next_steps:[],scratchpad:{notes:[]}},null,2)),r("context-compressor","Reset session state")}catch(n){r("context-compressor",`Error archiving session: ${n}`)}}function Fe(t){let e=`${t}/knowledge/decisions/active.json`;if(tt(e))try{let n=nt(e,"utf-8"),s=JSON.parse(n),o=s.decisions||[];if(o.length<=Q)return;let i=`${t}/archive/decisions`;et(i,{recursive:!0});let c=new Date,a=`${i}/${c.getFullYear()}-${String(c.getMonth()+1).padStart(2,"0")}.json`,d=o.slice(0,-Q);T(a,JSON.stringify(d,null,2)),s.decisions=o.slice(-Q),T(e,JSON.stringify(s,null,2)),r("context-compressor",`Archived ${d.length} old decisions`)}catch(n){r("context-compressor",`Error compressing decisions: ${n}`)}}function Ne(t){let e=`${t}/session/state.json`;if(tt(e))try{let n=nt(e,"utf-8"),s=JSON.parse(n),o={sessionId:s.session_id||"unknown",compactedAt:new Date().toISOString(),keyDecisions:(s.decisions_this_session||[]).slice(-5),filesTouched:(s.files_touched||[]).slice(-20),blockers:s.blockers||[],nextSteps:s.next_steps||[]},i=`${t}/session`;et(i,{recursive:!0}),T(`${i}/compaction-manifest.json`,JSON.stringify(o,null,2)),r("context-compressor",`Wrote compaction manifest for session ${o.sessionId}`)}catch(n){r("context-compressor",`Error writing compaction manifest: ${n}`)}}function Ot(t){r("context-compressor","Starting end-of-session compression...");let n=`${t.project_dir||p()}/context`;return Ne(n),Ee(n),Fe(n),r("context-compressor","End-of-session compression complete"),u()}import{existsSync as b,readFileSync as We,writeFileSync as Me,mkdirSync as Je}from"node:fs";import{execSync as v}from"node:child_process";function Be(t){let e=`${t}/.claude/hooks/logs/.last-test-run`;if(!b(e))return!0;try{let n=v("git diff --name-only HEAD",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]});if(/\.(py|js|ts|go|rs)$/.test(n))return!0}catch{return!0}return r("full-test-suite","No code changes detected, skipping tests"),!1}function Ue(t,e){let n=0;if(b(`${t}/pytest.ini`)||b(`${t}/pyproject.toml`)||b(`${t}/tests`)&&b(`${t}/requirements.txt`)){r("full-test-suite","Detected Python project, running pytest...");try{v("pytest --tb=short --timeout=300 -q",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if(b(`${t}/package.json`)){r("full-test-suite","Detected Node.js project...");try{if(JSON.parse(We(`${t}/package.json`,"utf-8")).scripts?.test){r("full-test-suite","Running npm test...");let o="npm test -- --passWithNoTests --watchAll=false";try{v("which pnpm",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),o="pnpm test --passWithNoTests"}catch{try{v("which yarn",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),o="yarn test --passWithNoTests"}catch{}}v(o,{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}}catch{n=1}}if(b(`${t}/go.mod`)){r("full-test-suite","Detected Go project, running go test...");try{v("go test -v -timeout 5m ./...",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}if(b(`${t}/Cargo.toml`)){r("full-test-suite","Detected Rust project, running cargo test...");try{v("cargo test",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{n=1}}return n===0}function At(t){r("full-test-suite","=== Full Test Suite Started ===");let e=t.project_dir||p(),n=`${e}/.claude/hooks/logs`;try{Je(n,{recursive:!0})}catch{}let s=`${n}/full-test-suite.log`;if(!Be(e))return u();if(Ue(e,s)){r("full-test-suite","=== All tests passed ===");try{Me(`${n}/.last-test-run`,String(Date.now()))}catch{}}else r("full-test-suite","=== Some tests failed ===");return u()}import{existsSync as qe,readFileSync as Le,unlinkSync as Ge,rmdirSync as ze}from"node:fs";import{execSync as O}from"node:child_process";function Ke(){try{return O("which gh",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),O("gh auth status",{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function Ye(t){try{return O("git remote get-url origin",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).includes("github")}catch{return!1}}function Ve(t,e,n){let s=e.commits||[];if(s.length===0)return"";let o=s.map(c=>`- \`${c.sha}\`: ${c.message}`).join(`
`),i=e.tasks_completed?.length>0?`### Sub-tasks Completed
${e.tasks_completed.map(c=>`- [x] ${c}`).join(`
`)}`:"";return`## Claude Code Progress Update

**Session**: \`${n.slice(0,8)}...\`
**Branch**: \`${e.branch||"unknown"}\`

### Commits (${s.length})
${o}

${i}
---
*Automated by [OrchestKit](https://github.com/yonatangross/orchestkit)*`}function Xe(t,e){try{return O(`gh issue comment ${t} --body "${e.replace(/"/g,'\\"')}"`,{encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function W(t){r("issue-work-summary","Session ending, checking for issue progress to post...");let e=t.project_dir||p(),n=t.session_id||f(),o=`/tmp/claude-session-${n.replace(/[^a-zA-Z0-9_-]/g,"")}`,i=`${o}/issue-progress.json`;if(!qe(i))return r("issue-work-summary",`No progress file found at ${i}`),u();if(!Ke())return r("issue-work-summary","gh CLI not available or not authenticated, skipping"),u();if(!Ye(e))return r("issue-work-summary","Not a GitHub repository, skipping"),u();let c;try{c=JSON.parse(Le(i,"utf-8"))}catch{return r("issue-work-summary","Failed to read progress file"),u()}let a=c.issues?Object.keys(c.issues):[];if(a.length===0)return r("issue-work-summary","No issues to process"),u();let d=0;for(let l of a){let g=c.issues[l];if((g.commits||[]).length===0){r("issue-work-summary",`No commits for issue #${l}, skipping`);continue}try{O(`gh issue view ${l} --json number`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{r("issue-work-summary",`Issue #${l} not found or not accessible, skipping`);continue}let h=Ve(l,g,n);h&&Xe(l,h)&&(d++,r("issue-work-summary",`Successfully posted comment to issue #${l}`))}r("issue-work-summary",`Posted progress comments to ${d} issue(s)`);try{Ge(i);try{ze(o)}catch{}r("issue-work-summary","Cleaned up progress file")}catch{}return u()}import{existsSync as I,readFileSync as R,mkdirSync as Ze,appendFileSync as A,writeFileSync as Qe}from"node:fs";import{spawn as tn}from"node:child_process";function en(t,e){if(!I(t))return 0;try{let s=JSON.parse(R(t,"utf-8")).decisions||[];if(I(e)){let i=JSON.parse(R(e,"utf-8")).synced_decisions||[];return s.filter(c=>!i.includes(c.decision_id)).length}return s.length}catch{return 0}}function nn(t){if(!I(t))return{count:0,patterns:[]};try{let e=R(t,"utf-8"),n;try{n=e.split(`
`).filter(o=>o.trim()).map(o=>JSON.parse(o))}catch{n=[JSON.parse(e)]}let s=n.filter(o=>o.pending_sync===!0);return{count:s.length,patterns:s}}catch{return{count:0,patterns:[]}}}function sn(t){return t.split("/").pop()||"project"}function on(t){let e="",n="",s="",o=`${t}/.claude/context/session/state.json`;if(I(o))try{let c=JSON.parse(R(o,"utf-8"));e=c.current_task||c.task||""}catch{}let i=`${t}/.claude/logs/blockers.jsonl`;if(I(i))try{n=R(i,"utf-8").split(`
`).filter(l=>l.trim()).map(l=>JSON.parse(l)).filter(l=>!l.resolved).slice(-5).map(l=>l.description||"").join("; ")}catch{}return{currentTask:e,blockers:n,nextSteps:s}}function Pt(t){if(!process.env.MEM0_API_KEY)return r("mem0-pre-compaction-sync","Mem0 not configured (no MEM0_API_KEY), skipping"),u();let e=t.project_dir||p(),n=mt(),s=`${n}/.claude/coordination/decision-log.json`,o=`${e}/.claude/logs/agent-patterns.jsonl`,i=`${n}/.claude/coordination/.decision-sync-state.json`,c=en(s,i),{count:a,patterns:d}=nn(o),{currentTask:l,blockers:g,nextSteps:y}=on(e);if(c===0&&a===0&&!l)return u();let h=sn(e),$=`${e}/.claude/logs/mem0-sync.log`;try{Ze(`${e}/.claude/logs`,{recursive:!0})}catch{}let m=[];if(c>0&&m.push(`${c} decisions to sync`),a>0){m.push(`${a} agent patterns pending`);let z=new Set(d.map(S=>S.agent_id||S.agent).filter(Boolean)),F=Array.from(z).slice(0,5);F.length>0&&m.push(`agents: ${F.join(", ")}`)}let at=m.length>0?m.join("; "):"No pending items",L=l||"Session work";c>0&&(L+=` (${c} decisions made)`),a>0&&(L+=` (${a} patterns learned)`);let G=`Session Summary: ${L}`;g&&(G+=` | Blockers: ${g}`),y&&(G+=` | Next: ${y}`);let ut=`${n}/skills/mem0-memory/scripts/crud/add-memory.py`,pe=process.env.MEM0_API_KEY,E;if(I(ut)&&pe){let z=new Date().toISOString();try{A($,`[${z}] Auto-sync triggered for session summary
`)}catch{}let F=JSON.stringify({type:"session_summary",status:"in_progress",project:h,has_blockers:!!g,has_next_steps:!!y,source:"orchestkit-plugin"}),S=tn("python3",[ut,"--text",G,"--user-id",`${h}-continuity`,"--metadata",F,"--enable-graph"],{detached:!0,stdio:["ignore","pipe","pipe"]});if(S.on("error",_=>{let k=new Date().toISOString();try{A($,`[${k}] Sync child process error: ${_.message}
`)}catch{}}),S.on("close",_=>{let k=new Date().toISOString();try{_===0?A($,`[${k}] Sync completed successfully
`):A($,`[${k}] Sync exited with code ${_}
`)}catch{}}),S.stderr){let _="";S.stderr.on("data",k=>{_+=k.toString()}),S.stderr.on("end",()=>{if(_.trim()){let k=new Date().toISOString();try{A($,`[${k}] Sync stderr: ${_.trim()}
`)}catch{}}})}if(S.unref(),a>0&&I(o))try{let k=R(o,"utf-8").split(`
`).filter(K=>K.trim()).map(K=>{let lt=JSON.parse(K);return lt.pending_sync=!1,JSON.stringify(lt)}).join(`
`);Qe(o,k)}catch{}E=`[Mem0 Sync] Auto-synced: ${at}`}else E=`[Mem0 Sync] ${at} - Execute /mem0-sync to persist session context`;return r("mem0-pre-compaction-sync",E),{continue:!0,systemMessage:E}}import{existsSync as M,readFileSync as jt,unlinkSync as Ht}from"node:fs";import{execSync as Ct}from"node:child_process";function J(t,e){try{Ct(`sqlite3 "${t}" "${e}"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]})}catch{}}function st(t,e){try{return Ct(`sqlite3 "${t}" "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='${e}';"`,{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()==="1"}catch{return!1}}function rn(t){let e=`${t}/heartbeat.pid`;if(M(e))try{let n=parseInt(jt(e,"utf-8").trim(),10);try{process.kill(n,0),process.kill(n),r("multi-instance-cleanup",`Stopped heartbeat process (PID: ${n})`)}catch{}Ht(e)}catch{}}function cn(t,e){r("multi-instance-cleanup","Releasing all locks..."),J(t,`DELETE FROM file_locks WHERE instance_id = '${e}';`),r("multi-instance-cleanup","All locks released")}function an(t,e){r("multi-instance-cleanup","Handling work claims..."),st(t,"work_claims")?(J(t,`UPDATE work_claims SET status = 'abandoned', completed_at = datetime('now') WHERE instance_id = '${e}' AND status = 'active';`),r("multi-instance-cleanup","Work claims handled")):r("multi-instance-cleanup","No work_claims table, skipping")}function un(t,e){st(t,"instances")?(J(t,`UPDATE instances SET status = 'terminated', last_heartbeat = datetime('now') WHERE id = '${e}';`),r("multi-instance-cleanup","Instance status updated to terminated")):r("multi-instance-cleanup","No instances table, skipping status update")}function ln(t,e){if(!st(t,"messages")){r("multi-instance-cleanup","No messages table, skipping broadcast");return}let n=`msg-${Math.random().toString(36).slice(2,18)}`,s=new Date().toISOString(),o=JSON.stringify({instance_id:e,timestamp:s}).replace(/'/g,"''");J(t,`INSERT INTO messages (message_id, from_instance, to_instance, message_type, payload, expires_at) VALUES ('${n}', '${e}', NULL, 'shutdown', '${o}', datetime('now', '+1 hour'));`),r("multi-instance-cleanup","Shutdown broadcast sent")}function pn(t){let e=["knowledge_cache.json","claims.json","session_discoveries.json"];for(let n of e){let s=`${t}/${n}`;try{M(s)&&Ht(s)}catch{}}r("multi-instance-cleanup","Instance files cleaned up")}function Et(t){let e=t.project_dir||p(),n=`${e}/.instance`,s=`${e}/.claude/coordination/.claude.db`;if(!M(s))return r("multi-instance-cleanup","No coordination database, skipping cleanup"),u();let o=`${n}/id.json`;if(!M(o))return r("multi-instance-cleanup","No instance identity, skipping cleanup"),u();let i;try{i=JSON.parse(jt(o,"utf-8")).instance_id}catch{return r("multi-instance-cleanup","Failed to read instance ID"),u()}return r("multi-instance-cleanup",`Starting multi-instance cleanup for ${i}...`),rn(n),cn(s,i),an(s,i),ln(s,i),un(s,i),pn(n),r("multi-instance-cleanup","=== Cleanup Summary ==="),r("multi-instance-cleanup",`Instance: ${i}`),r("multi-instance-cleanup","Status: terminated"),r("multi-instance-cleanup","Multi-instance cleanup completed"),u()}import{existsSync as D,mkdirSync as dn,readFileSync as gn,writeFileSync as P,readdirSync as Ft}from"node:fs";import{execSync as w}from"node:child_process";function fn(t,e){if(!D(`${t}/package.json`)||!D(`${t}/package-lock.json`)&&!D(`${t}/yarn.lock`)&&!D(`${t}/pnpm-lock.yaml`))return null;r("security-scan","Running npm audit...");try{w("npm audit --json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]})}catch(n){if(n.stdout){P(`${e}/npm-audit.json`,n.stdout);try{let s=JSON.parse(n.stdout);return{critical:s.metadata?.vulnerabilities?.critical||0,high:s.metadata?.vulnerabilities?.high||0}}catch{}}}return r("security-scan","npm audit complete"),{critical:0,high:0}}function mn(t,e){if(!D(`${t}/requirements.txt`)&&!D(`${t}/pyproject.toml`))return null;try{w("which pip-audit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return r("security-scan","pip-audit not installed, skipping"),null}r("security-scan","Running pip-audit...");try{let n=w("pip-audit --format json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]});P(`${e}/pip-audit.json`,n);let s=JSON.parse(n);return r("security-scan","pip-audit complete"),Array.isArray(s)?s.length:0}catch{return 0}}function yn(t,e){try{w("which semgrep",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return r("security-scan","semgrep not installed, skipping"),null}r("security-scan","Running semgrep...");try{let n=w("semgrep --config auto --json --quiet",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]});P(`${e}/semgrep.json`,n);let o=(JSON.parse(n).results||[]).filter(i=>i.extra?.severity==="ERROR").length;return r("security-scan","semgrep complete"),o}catch{return 0}}function kn(t,e){try{if(!w('find . -name "*.py" -maxdepth 2 | head -1',{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()&&!D(`${t}/backend`))return null}catch{return null}try{w("which bandit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return r("security-scan","bandit not installed, skipping"),null}r("security-scan","Running bandit...");try{return w(`bandit -r . -f json -o ${e}/bandit.json`,{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]}),r("security-scan","bandit complete"),0}catch{return 0}}function hn(t,e){r("security-scan","Running secret detection...");let n=/(api[_-]?key|secret[_-]?key|password|token)\s*[=:]\s*["'][^"']{8,}/i,s=0,o=[],i=[".py",".js",".ts",".env"];function c(a){try{let d=Ft(a,{withFileTypes:!0});for(let l of d){let g=`${a}/${l.name}`;if(l.isDirectory()){["node_modules",".git","dist","build"].includes(l.name)||c(g);continue}if(i.some(y=>l.name.endsWith(y)))try{let y=gn(g,"utf-8");n.test(y)&&(o.push({file:g,type:"potential_secret"}),s++)}catch{}}}catch{}}return c(t),P(`${e}/secrets.json`,JSON.stringify({findings:o,count:s},null,2)),r("security-scan",`Secret detection complete: ${s} potential issues`),s}function Sn(t,e){r("security-scan","Aggregating results...");let n=0,s=0;e.npmAudit&&(n+=e.npmAudit.critical,s+=e.npmAudit.high),e.pipAudit!==null&&(s+=e.pipAudit),e.semgrep!==null&&(s+=e.semgrep);let o=Ft(t).filter(c=>c.endsWith(".json")&&!c.includes("aggregated")).map(c=>c.replace(".json","")),i={timestamp:new Date().toISOString(),summary:{critical:n,high:s,medium:0},scans_completed:o};P(`${t}/aggregated-report.json`,JSON.stringify(i,null,2)),r("security-scan","=== Security Scan Complete ==="),r("security-scan",`Critical: ${n}, High: ${s}`),n>0&&console.error(`Security: ${n} critical, ${s} high vulnerabilities found`)}function Nt(t){r("security-scan","=== Security Scan Started ===");let e=t.project_dir||p(),n=`${e}/.claude/hooks/logs/security`;dn(n,{recursive:!0});let s={npmAudit:null,pipAudit:null,semgrep:null,bandit:null,secrets:0};return s.npmAudit=fn(e,n),s.pipAudit=mn(e,n),s.semgrep=yn(e,n),s.bandit=kn(e,n),s.secrets=hn(e,n),Sn(n,s),u()}import{existsSync as j,mkdirSync as B,readFileSync as H,writeFileSync as ot}from"node:fs";function _n(t){if(!j(t))return"";try{let n=JSON.parse(H(t,"utf-8")).tools||{};return Object.entries(n).sort(([,o],[,i])=>i-o).slice(0,10).map(([o])=>o).join(",")}catch{return""}}function bn(t){if(!j(t))return 0;try{let n=JSON.parse(H(t,"utf-8")).tools||{};return Object.values(n).reduce((s,o)=>s+o,0)}catch{return 0}}function wn(t){return t.includes("Write")&&t.includes("Bash")&&/test|pytest|jest|vitest/i.test(t)?"test-driven-development":t.includes("Read")&&t.includes("Grep")?"code-exploration":t.includes("Edit")&&!t.includes("Write")?"refactoring":t.includes("Write")&&t.includes("Read")?"feature-development":t.includes("Bash")&&/git|gh/i.test(t)?"git-operations":"general"}function $n(t){return"unknown"}function xn(t){if(j(t))try{return JSON.parse(H(t,"utf-8"))}catch{}return{version:"1.0.0",last_updated:null,sessions_count:0,workflow_types:{"test-driven-development":0,"code-exploration":0,refactoring:0,"feature-development":0,"git-operations":0,general:0},common_tool_sequences:[],dominant_languages:{python:0,typescript:0,javascript:0,go:0,rust:0,unknown:0},average_tools_per_session:0,average_session_duration_seconds:0,tool_frequency:{}}}function vn(t,e,n,s,o){let i=xn(t),c=new Date().toISOString();if(i.last_updated=c,i.sessions_count+=1,i.workflow_types[e]=(i.workflow_types[e]||0)+1,i.dominant_languages[n]=(i.dominant_languages[n]||0)+1,i.average_tools_per_session=(i.average_tools_per_session*(i.sessions_count-1)+s)/i.sessions_count,o.split(",").filter(Boolean).length>2){let d=new Set([o,...i.common_tool_sequences]);i.common_tool_sequences=Array.from(d).slice(0,20)}B(t.replace(/\/[^/]+$/,""),{recursive:!0}),ot(t,JSON.stringify(i,null,2))}function In(t){if(j(t))try{return JSON.parse(H(t,"utf-8"))}catch{}return{version:"1.0",updated:"",patterns:[],categories:{},stats:{total:0,successes:0,failures:0}}}function Dn(t){let e=`${t}/.claude/feedback/patterns-queue.json`,n=`${t}/.claude/feedback/learned-patterns.json`;if(!j(e)){r("session-patterns","No patterns queue found");return}let s;try{s=JSON.parse(H(e,"utf-8"))}catch{r("session-patterns","Failed to parse patterns queue");return}let o=s.patterns?.length||0;if(o===0){r("session-patterns","Patterns queue is empty");return}r("session-patterns",`Processing ${o} queued patterns...`);let i=In(n),c=new Date().toISOString(),a=[...i.patterns,...s.patterns],d=new Map;for(let m of a)d.set(m.text,m);let l=Array.from(d.values()),g=l.filter(m=>m.outcome==="success").length,y=l.filter(m=>m.outcome==="failed").length,h={};for(let m of l)h[m.category]=(h[m.category]||0)+1;let $={version:"1.0",updated:c,patterns:l,categories:h,stats:{total:l.length,successes:g,failures:y}};B(n.replace(/\/[^/]+$/,""),{recursive:!0}),ot(n,JSON.stringify($,null,2)),r("session-patterns","Merged patterns successfully"),ot(e,JSON.stringify({patterns:[]}))}function U(t){r("session-patterns","Session ending, processing patterns...");let e=t.project_dir||p(),n="/tmp/claude-session-metrics.json",s=`${e}/.claude/feedback/workflow-patterns.json`;B(`${e}/.claude/feedback`,{recursive:!0}),B(`${e}/.claude/logs`,{recursive:!0});let o=bn(n);if(o>=5){let i=_n(n),c=wn(i),a=$n(i);vn(s,c,a,o,i),r("session-patterns",`Workflow analyzed: type=${c} lang=${a} tools=${o}`)}else r("session-patterns",`Session too short for workflow analysis (tools: ${o})`);return Dn(e),r("session-patterns","Pattern processing complete"),u()}import{existsSync as Lt,readFileSync as Gt}from"node:fs";import{existsSync as Wt,readFileSync as Rn,writeFileSync as Tn,mkdirSync as On}from"node:fs";function Mt(){let t=f();return`${p()}/.claude/orchestration/task-registry-${t}.json`}function An(){let t=`${p()}/.claude/orchestration`;if(!Wt(t))try{On(t,{recursive:!0})}catch{}}function Jt(){let t=Mt();if(Wt(t))try{return JSON.parse(Rn(t,"utf8"))}catch{}return{schemaVersion:"1.0.0",sessionId:f(),tasks:[],pipelines:[],updatedAt:new Date().toISOString()}}function Pn(t){An();let e=Mt();t.updatedAt=new Date().toISOString();try{Tn(e,JSON.stringify(t,null,2))}catch(n){r("task-integration",`Failed to save registry: ${n}`)}}function Bt(t,e){return`### Delete Orphaned Task

\`\`\`
TaskUpdate:
  taskId: "${t}"
  status: "deleted"
\`\`\`

**Reason**: ${e}`}function Ut(){let t=Jt(),e=new Set(t.tasks.filter(n=>n.status==="failed").map(n=>n.taskId));return e.size===0?[]:t.tasks.filter(n=>n.status!=="pending"||!n.blockedBy||n.blockedBy.length===0?!1:n.blockedBy.every(s=>e.has(s)))}function qt(t=1440*60*1e3){let e=Jt(),n=Date.now()-t;e.tasks=e.tasks.filter(s=>s.status==="pending"||s.status==="in_progress"?!0:new Date(s.createdAt).getTime()>n),e.pipelines=e.pipelines.filter(s=>s.status==="running"?!0:new Date(s.startedAt).getTime()>n),Pn(e)}function zt(t){r("task-completion-check","Stop hook - checking task completion");let e=[],n=t.project_dir||p(),s=t.session_id||f(),o=`${n}/.claude/orchestration/task-registry-${s}.json`;if(Lt(o))try{let l=(JSON.parse(Gt(o,"utf-8")).tasks||[]).filter(g=>g.status==="in_progress");l.length>0&&(r("task-completion-check",`WARNING: ${l.length} orchestration tasks still in progress`),e.push(`${l.length} orchestration task(s) still in progress at session stop`))}catch(d){r("task-completion-check",`Error reading registry: ${d}`)}let i=Ut(),c="";if(i.length>0){r("task-completion-check",`Found ${i.length} orphaned tasks`),c=`

## Orphaned Tasks

The following tasks are orphaned (all blockers failed) and should be deleted:
`;for(let d of i)c+=`
${Bt(d.taskId,"All blocking tasks have failed")}`}let a="/tmp/claude-active-todos.json";if(Lt(a))try{let l=JSON.parse(Gt(a,"utf-8")).filter(g=>g.status==="in_progress");l.length>0&&(r("task-completion-check",`WARNING: ${l.length} legacy tasks in progress at stop`),e.push(`${l.length} legacy task(s) still in progress`))}catch(d){r("task-completion-check",`Error reading legacy todos: ${d}`)}if(e.length>0||c){let d=`## Task Completion Warning

${e.map(l=>`- ${l}`).join(`
`)}`;return c&&(d+=c),yt(d)}return u()}import{existsSync as rt,readFileSync as jn,writeFileSync as Ao,mkdirSync as Po}from"node:fs";function Yt(){return`${p()}/.claude/orchestration`}function Hn(){let t=f();return`${Yt()}/session-${t}.json`}function Cn(){return`${p()}/.claude/orchestration/config.json`}var Kt={enableAutoDispatch:!0,enableSkillInjection:!0,maxSkillInjectionTokens:800,enableCalibration:!0,enablePipelines:!0,maxRetries:3,retryDelayBaseMs:1e3};function Vt(){let t=Cn();if(rt(t))try{let e=jn(t,"utf8");return{...Kt,...JSON.parse(e)}}catch{}return Kt}function it(){let t=Hn();try{if(rt(t)){let{unlinkSync:e}=pt("node:fs");e(t),r("orchestration-state","Cleared session state")}}catch{}}function ct(){let t=Yt();if(rt(t))try{let{readdirSync:e,statSync:n,unlinkSync:s}=pt("node:fs"),o=e(t).filter(i=>i.startsWith("session-")&&i.endsWith(".json")).map(i=>({name:i,path:`${t}/${i}`,mtime:n(`${t}/${i}`).mtime.getTime()})).sort((i,c)=>c.mtime-i.mtime);for(let i of o.slice(5))try{s(i.path),r("orchestration-state",`Cleaned up old state: ${i.name}`)}catch{}}catch{}}var En=720*60*60*1e3;function Fn(t){let e=Date.now()-En,n=t.records.length;t.records=t.records.filter(o=>new Date(o.timestamp).getTime()>e);let s=t.records.length;n!==s&&r("calibration-persist",`Cleaned up ${n-s} old records`)}function Nn(t){let e=t.stats,n=e.topAgents.slice(0,3).map(s=>`${s.agent}(${Math.round(s.successRate*100)}%)`).join(", ");return`Calibration summary: ${e.totalDispatches} dispatches, ${Math.round(e.successRate*100)}% success rate, ${t.adjustments.length} adjustments active. Top agents: ${n||"none"}`}function q(t){if(!Vt().enableCalibration)return it(),ct(),u();r("calibration-persist","Running end-of-session calibration persistence...");try{let n=x();xt(n),Fn(n),V(n);let s=Nn(n);r("calibration-persist",s)}catch(n){r("calibration-persist",`Error during calibration persist: ${n}`)}try{it(),ct(),qt(),r("calibration-persist","Cleaned up session state")}catch(n){r("calibration-persist",`Error during state cleanup: ${n}`)}return u()}var Xt=[{name:"auto-save-context",fn:N},{name:"session-patterns",fn:U},{name:"issue-work-summary",fn:W},{name:"calibration-persist",fn:q}];async function Zt(t){let n=(await Promise.allSettled(Xt.map(async s=>{try{let o=s.fn(t);return o instanceof Promise&&await o,{hook:s.name,status:"success"}}catch(o){let i=o instanceof Error?o.message:String(o);return r("stop-dispatcher",`${s.name} failed: ${i}`),{hook:s.name,status:"error",message:i}}}))).filter(s=>s.status==="rejected"||s.status==="fulfilled"&&s.value.status==="error");return n.length>0&&r("stop-dispatcher",`${n.length}/${Xt.length} hooks had errors`),u()}import{existsSync as Qt,readFileSync as Wn,writeFileSync as zo,mkdirSync as Mn,appendFileSync as Jn}from"node:fs";import{join as te,dirname as Bn}from"node:path";function Un(t){return te(p(),".claude","memory","flows",`${t}.json`)}function qn(){return te(p(),".claude","memory","completed-flows.jsonl")}function ee(t){let e=Un(t);if(!Qt(e))return null;try{let n=Wn(e,"utf-8");return JSON.parse(n)}catch(n){return r("decision-flow-tracker",`Failed to load flow for ${t}: ${n}`,"warn"),null}}function Ln(t){let e=qn();try{let n=Bn(e);Qt(n)||Mn(n,{recursive:!0});let s=JSON.stringify(t)+`
`;return Jn(e,s),!0}catch(n){return r("decision-flow-tracker",`Failed to archive flow: ${n}`,"warn"),!1}}function ne(t){if(t.length<3)return"mixed";let e={exploration:0,modification:0,testing:0,building:0,agent:0,execution:0,git:0,other:0};for(let n of t)e[n.category]++;if(e.testing>=2){let n=t.map((o,i)=>o.category==="testing"?i:-1).filter(o=>o>=0),s=t.map((o,i)=>o.category==="modification"?i:-1).filter(o=>o>=0);if(n.length>=2&&s.length>0&&n[0]<s[0])return"test-first"}if(e.exploration>=3&&e.modification>0&&Gn(t,"exploration")>=3)return"explore-first";if(e.modification>=2&&e.execution+e.testing>=2&&zn(t,"modification",["execution","testing"])>=2)return"iterate-fast";if(e.agent>=3||e.agent/t.length>.3)return"agent-delegate";if(e.modification>=3&&e.testing===1){let n=t.map((s,o)=>s.category==="testing"?o:-1).filter(s=>s>=0).pop();if(n&&n>t.length-3)return"big-bang"}return"mixed"}function Gn(t,e){let n=0,s=0;for(let o of t)o.category===e?(s++,n=Math.max(n,s)):s=0;return n}function zn(t,e,n){let s=0,o=!1;for(let i of t){let c=i.category===e,a=n.includes(i.category);c&&!o?o=!0:a&&o&&(s++,o=!1)}return s}function se(t){let e=t.filter(n=>n.result==="success").length;return{total_actions:t.length,reads:t.filter(n=>n.category==="exploration").length,writes:t.filter(n=>n.category==="modification").length,tests:t.filter(n=>n.category==="testing").length,builds:t.filter(n=>n.category==="building").length,agent_spawns:t.filter(n=>n.category==="agent").length,success_rate:t.length>0?e/t.length:0}}function oe(t){let e=ee(t);return e?(e.inferred_pattern=ne(e.actions),e.stats=se(e.actions),e):null}function re(t){let e=ee(t);if(!e)return!1;e.inferred_pattern=ne(e.actions),e.stats=se(e.actions);let n=Ln(e);return n&&r("decision-flow-tracker",`Completed flow for ${t}: ${e.actions.length} actions, pattern: ${e.inferred_pattern}`,"info"),n}import{existsSync as ce,readFileSync as Kn,writeFileSync as Yn,mkdirSync as Vn}from"node:fs";import{join as Xn,dirname as Zn}from"node:path";var C="workflow-preference-learner",Qn=5;function ae(){return Xn(p(),".claude","memory","workflow-preferences.json")}function ts(){let t=ae();if(!ce(t))return ie();try{let e=Kn(t,"utf-8");return JSON.parse(e)}catch{return ie()}}function es(t){let e=ae();try{let n=Zn(e);return ce(n)||Vn(n,{recursive:!0}),Yn(e,JSON.stringify(t,null,2)),!0}catch(n){return r(C,`Failed to save workflow preferences: ${n}`,"warn"),!1}}function ie(){let t=["test-first","explore-first","iterate-fast","big-bang","agent-delegate","mixed"],e={},n={};for(let s of t)e[s]=0,n[s]=[];return{pattern_counts:e,pattern_success_rates:n,total_sessions:0,preferences:[],updated_at:new Date().toISOString()}}function ns(t){let e=[],n=new Date().toISOString();for(let[s,o]of Object.entries(t.pattern_counts)){if(o===0)continue;let i=t.pattern_success_rates[s]||[],c=i.length>0?i.reduce((a,d)=>a+d,0)/i.length:0;e.push({pattern:s,frequency:t.total_sessions>0?o/t.total_sessions:0,count:o,total_sessions:t.total_sessions,avg_success_rate:c,updated_at:n})}return e.sort((s,o)=>o.frequency-s.frequency),e}function ss(t,e){if(!e.inferred_pattern)return;let n=e.inferred_pattern,s=e.stats.success_rate;t.pattern_counts[n]=(t.pattern_counts[n]||0)+1,t.total_sessions++,t.pattern_success_rates[n]||(t.pattern_success_rates[n]=[]),t.pattern_success_rates[n].push(s),t.pattern_success_rates[n].length>20&&(t.pattern_success_rates[n]=t.pattern_success_rates[n].slice(-20)),t.preferences=ns(t),t.updated_at=new Date().toISOString()}function ue(t){let e=t.session_id||f(),n=oe(e);if(!n)return r(C,`No decision flow found for session ${e}`,"debug"),u();if(n.actions.length<Qn)return r(C,`Too few actions (${n.actions.length}) for pattern detection`,"debug"),u();if(re(e),n.inferred_pattern==="mixed")return u();let s=ts();ss(s,n),es(s),r(C,`Session pattern: ${n.inferred_pattern} (${n.actions.length} actions, ${(n.stats.success_rate*100).toFixed(0)}% success)`,"info");let o=s.preferences[0];return o&&o.frequency>.6&&o.count>=5&&r(C,`Strong workflow preference: ${o.pattern} (${(o.frequency*100).toFixed(0)}% of sessions)`,"info"),u()}var le={"stop/auto-remember-continuity":vt,"stop/auto-save-context":N,"stop/cleanup-instance":Tt,"stop/context-compressor":Ot,"stop/full-test-suite":At,"stop/issue-work-summary":W,"stop/mem0-pre-compaction-sync":Pt,"stop/multi-instance-cleanup":Et,"stop/security-scan-aggregator":Nt,"stop/session-patterns":U,"stop/task-completion-check":zt,"stop/calibration-persist":q,"stop/unified-dispatcher":Zt,"stop/workflow-preference-learner":ue};function yr(t){return le[t]}function kr(){return Object.keys(le)}export{xt as applyDecay,xs as escapeRegex,we as estimateTokenCount,Os as getAdjustments,As as getAgentSuccessRate,ds as getCachedBranch,Ps as getCalibrationStats,ws as getField,yr as getHook,ft as getLogDir,ke as getLogLevel,mt as getPluginRoot,p as getProjectDir,f as getSessionId,js as hasMinimalCalibrationData,Te as hashPrompt,le as hooks,rs as isBashInput,cs as isEditInput,as as isReadInput,is as isWriteInput,kr as listHooks,x as loadCalibrationData,r as logHook,Ss as logPermissionFeedback,$s as normalizeCommand,ms as outputAllowWithContext,fs as outputBlock,hs as outputDeny,ys as outputError,Se as outputPromptContext,_s as outputPromptContextBudgeted,gs as outputSilentAllow,u as outputSilentSuccess,ks as outputWarning,yt as outputWithContext,bs as readHookInput,Ts as recordOutcome,V as saveCalibrationData,he as shouldLog};
//# sourceMappingURL=stop.mjs.map
