{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/analytics-buffer.ts", "../src/lib/paths.ts", "../src/lib/session-id-generator.ts", "../src/lib/calibration-engine.ts", "../src/stop/auto-remember-continuity.ts", "../src/stop/auto-save-context.ts", "../src/stop/full-test-suite.ts", "../src/stop/issue-work-summary.ts", "../src/lib/sanitize-shell.ts", "../src/stop/security-scan-aggregator.ts", "../src/stop/session-patterns.ts", "../src/lib/session-tracker.ts", "../src/lib/user-identity.ts", "../src/lib/tool-categories.ts", "../src/stop/task-completion-check.ts", "../src/lib/task-integration.ts", "../src/lib/orchestration-state.ts", "../src/stop/calibration-persist.ts", "../src/lib/user-profile.ts", "../src/lib/decision-flow-tracker.ts", "../src/stop/session-profile-aggregator.ts", "../src/stop/session-end-tracking.ts", "../src/stop/workflow-preference-learner.ts", "../src/skill/coverage-check.ts", "../src/skill/evidence-collector.ts", "../src/skill/coverage-threshold-gate.ts", "../src/skill/cross-instance-test-validator.ts", "../src/skill/di-pattern-enforcer.ts", "../src/skill/duplicate-code-detector.ts", "../src/lib/git.ts", "../src/skill/eval-metrics-collector.ts", "../src/skill/migration-validator.ts", "../src/skill/review-summary-generator.ts", "../src/skill/security-summary.ts", "../src/skill/test-pattern-validator.ts", "../src/skill/test-runner.ts", "../src/stop/unified-dispatcher.ts", "../src/entries/stop.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PostToolUseFailure'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification'\n  | 'PreCompact'\n  | 'TeammateIdle'\n  | 'TaskCompleted'\n  | 'WorktreeCreate'\n  | 'WorktreeRemove';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** Whether a stop hook is currently active (prevents re-entry) */\n  stop_hook_active?: boolean;\n  /** Permission mode (CC 2.1.25: dontAsk mode makes quality gates warn-only) */\n  permissionMode?: 'default' | 'acceptEdits' | 'dontAsk';\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // TeammateIdle specific fields (CC 2.1.33)\n  /** Teammate agent ID */\n  teammate_id?: string;\n  /** Teammate agent type */\n  teammate_type?: string;\n  /** How long the teammate has been idle (ms) */\n  idle_duration_ms?: number;\n\n  // TaskCompleted specific fields (CC 2.1.33)\n  /** Completed task ID */\n  task_id?: string;\n  /** Task subject */\n  task_subject?: string;\n  /** Task result status */\n  task_status?: string;\n  /** Token count consumed by the task (CC 2.1.30) */\n  token_count?: number;\n  /** Number of tool invocations in the task (CC 2.1.30) */\n  tool_uses?: number;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n\n  // Stop/SubagentStop specific fields (CC 2.1.47)\n  /** The final assistant message text (Stop and SubagentStop, CC 2.1.47+) */\n  last_assistant_message?: string;\n\n  // Workspace/statusline fields (CC 2.1.47)\n  /** Directories added via /add-dir, from statusline workspace section (CC 2.1.47+) */\n  added_dirs?: string[];\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PostToolUseFailure' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n  /** Modified tool input (CC 2.1.25: canonical way to modify tool inputs) */\n  updatedInput?: Record<string, unknown>;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\nimport {\n  getLogDir as getLogDirFromPaths,\n  getProjectDir as getProjectDirFromPaths,\n  getPluginRoot as getPluginRootFromPaths,\n} from './paths.js';\nimport { getOrGenerateSessionId } from './session-id-generator.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// Re-export from paths.ts for cross-platform compatibility\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getLogDir(): string {\n  return getLogDirFromPaths();\n}\n\n/**\n * Get the project directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getProjectDir(): string {\n  return getProjectDirFromPaths();\n}\n\n/**\n * Get the plugin root directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getPluginRoot(): string {\n  return getPluginRootFromPaths();\n}\n\n/**\n * Get the environment file path (CC 2.1.25: CLAUDE_ENV_FILE support)\n * Falls back to .instance_env for backward compatibility\n */\nexport function getEnvFile(): string {\n  if (process.env.CLAUDE_ENV_FILE) {\n    return process.env.CLAUDE_ENV_FILE;\n  }\n  // Fallback to legacy .instance_env\n  const pluginRoot = getPluginRoot();\n  return `${pluginRoot}/.claude/.instance_env`;\n}\n\n/**\n * Get the session ID\n *\n * Resolution order:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime - preferred)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate smart session ID: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n *\n * Example smart ID: \"orchestkit-main-0130-1745-a3f2\"\n *\n * The old fallback format \"fallback-{pid}-{timestamp}\" was confusing and unhelpful.\n * Smart IDs are human-readable, showing project, branch, and time context.\n */\nexport function getSessionId(): string {\n  return getOrGenerateSessionId();\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Normalize line endings from CRLF to LF for cross-platform compatibility.\n * Windows uses \\r\\n (CRLF) while Unix uses \\n (LF).\n * This is critical for parsing YAML frontmatter where we match '---' exactly.\n */\nexport function normalizeLineEndings(content: string): string {\n  return content.replace(/\\r\\n/g, '\\n');\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with user notification + Claude context (CC 2.1.9+)\n * Issue #278: Dual-channel output for three-tier UX\n *\n * @param userMessage - Brief message shown to user via systemMessage (optional)\n * @param claudeContext - Full context for Claude via additionalContext (optional)\n * @returns HookResult with appropriate channels set\n *\n * Usage:\n * - Both set: User sees notification, Claude gets context\n * - Only claudeContext: Silent injection (Claude-only)\n * - Only userMessage: User notification without context\n */\nexport function outputWithNotification(\n  userMessage: string | undefined,\n  claudeContext: string | undefined\n): HookResult {\n  const result: HookResult = {\n    continue: true,\n    suppressOutput: true,\n  };\n\n  if (userMessage) {\n    result.systemMessage = userMessage;\n  }\n\n  if (claudeContext) {\n    result.hookSpecificOutput = {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: claudeContext,\n    };\n  }\n\n  return result;\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message via JSON stdout \u2014 visible to both user and Claude (CC 2.1.7+).\n * Use this when Claude needs to see and act on the warning (e.g., cost advice, quality gates).\n * For user-only warnings where Claude should NOT see the message, use outputStderrWarning.\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output warning via stderr + exit(2) \u2014 visible to user only, Claude does NOT see it (CC 2.1.39).\n * Use this for informational warnings that should not influence Claude's behavior\n * (e.g., deprecation notices, non-actionable advisories).\n *\n * IMPORTANT: This function calls process.exit(2) and never returns.\n * Do NOT use inside unified dispatchers \u2014 it will crash the dispatcher process.\n * Only use in standalone hook entry points.\n */\nexport function outputStderrWarning(message: string): never {\n  process.stderr.write(`\\u26a0 ${message}\\n`);\n  process.exit(2);\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with updatedInput - modifies tool input before execution (CC 2.1.25)\n * Canonical way to modify tool inputs from PreToolUse hooks\n */\nexport function outputWithUpdatedInput(updatedInput: Record<string, unknown>): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      updatedInput,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    bufferWrite(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    bufferWrite(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction (shared by all sync dispatchers)\n// -----------------------------------------------------------------------------\n\n/**\n * Extract additionalContext from a hook result.\n * Handles both the correct hookSpecificOutput.additionalContext format\n * and the legacy bare systemMessage format.\n *\n * Issue #682: Deduplicated from 5 dispatchers into shared utility.\n */\nexport function extractContext(result: HookResult): string | null {\n  // Standard format: hookSpecificOutput.additionalContext\n  if (result.hookSpecificOutput?.additionalContext) {\n    return result.hookSpecificOutput.additionalContext as string;\n  }\n\n  // Legacy format: bare systemMessage (antipattern-detector bug)\n  if (result.systemMessage && typeof result.systemMessage === 'string') {\n    return result.systemMessage;\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker?.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// ReDoS-Safe String Matching\n// -----------------------------------------------------------------------------\n\n/**\n * Check if any single line contains all specified substrings (ReDoS-safe O(n)).\n * Use instead of polynomial regexes like /A.*B.*C/.test(content).\n */\nexport function lineContainsAll(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => terms.every(t => line.includes(t)));\n}\n\n/**\n * Check if any single line contains all specified substrings (case-insensitive, ReDoS-safe O(n)).\n */\nexport function lineContainsAllCI(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => {\n    const lower = line.toLowerCase();\n    return terms.every(t => lower.includes(t.toLowerCase()));\n  });\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Analytics Write Buffer \u2014 Batches appendFileSync calls and flushes on exit\n *\n * Reduces per-hook I/O overhead by buffering analytics/metrics/log writes\n * and flushing them in a single batch per file path. Registered process\n * handlers ensure data is written before the process terminates.\n *\n * Issue #688: Buffer analytics writes and flush on process exit\n */\n\nimport { appendFileSync, mkdirSync } from 'node:fs';\nimport { dirname } from 'node:path';\n\ninterface BufferEntry {\n  filePath: string;\n  content: string;\n}\n\nconst buffer: BufferEntry[] = [];\nlet flushing = false;\nlet handlersRegistered = false;\n\n/**\n * Queue an analytics/log write for batched flushing.\n * Call this instead of appendFileSync for non-essential writes.\n */\nexport function bufferWrite(filePath: string, content: string): void {\n  buffer.push({ filePath, content });\n  ensureHandlers();\n}\n\n/**\n * Flush all buffered writes to disk immediately.\n * Groups entries by file path to minimize syscalls.\n */\nexport function flush(): void {\n  if (flushing || buffer.length === 0) return;\n  flushing = true;\n\n  // Group by filePath to write each file once\n  const grouped = new Map<string, string[]>();\n  for (const entry of buffer) {\n    const arr = grouped.get(entry.filePath);\n    if (arr) {\n      arr.push(entry.content);\n    } else {\n      grouped.set(entry.filePath, [entry.content]);\n    }\n  }\n\n  for (const [path, contents] of grouped) {\n    try {\n      mkdirSync(dirname(path), { recursive: true });\n      appendFileSync(path, contents.join(''));\n    } catch {\n      // Ignore flush errors \u2014 never block process exit\n    }\n  }\n\n  buffer.length = 0;\n  flushing = false;\n}\n\n/** Number of entries currently buffered (for testing) */\nexport function pendingCount(): number {\n  return buffer.length;\n}\n\n/** Clear buffer without writing (for testing) */\nexport function _resetForTesting(): void {\n  buffer.length = 0;\n  flushing = false;\n}\n\nfunction ensureHandlers(): void {\n  if (handlersRegistered) return;\n  handlersRegistered = true;\n\n  process.on('exit', flush);\n  process.on('SIGTERM', () => { flush(); process.exit(0); });\n  process.on('SIGINT', () => { flush(); process.exit(0); });\n}\n", "/**\n * Cross-platform path utilities for TypeScript hooks\n *\n * Provides consistent path handling across Windows, macOS, and Linux.\n * All path construction uses path.join() for correct separators.\n * All temp directories use os.tmpdir() for platform awareness.\n */\n\nimport os from 'node:os';\nimport path from 'node:path';\n\n/**\n * Get the user's home directory (cross-platform)\n * Prefers explicit env vars, falls back to os.homedir()\n */\nexport function getHomeDir(): string {\n  return process.env.HOME || process.env.USERPROFILE || os.homedir();\n}\n\n/**\n * Get the system temp directory (cross-platform)\n * Returns /tmp on Unix, C:\\Users\\X\\AppData\\Local\\Temp on Windows\n */\nexport function getTempDir(): string {\n  return os.tmpdir();\n}\n\n/**\n * Get the project directory from environment\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory from environment\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the log directory path (cross-platform)\n * Uses path.join() for correct separators on all platforms\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return path.join(getHomeDir(), '.claude', 'logs', 'ork');\n  }\n  return path.join(getProjectDir(), '.claude', 'logs');\n}\n\n/**\n * Get the memory directory path (cross-platform)\n */\nexport function getMemoryDir(): string {\n  return path.join(getProjectDir(), '.claude', 'memory');\n}\n\n/**\n * Get the coordination directory path (cross-platform)\n */\nexport function getCoordinationDir(): string {\n  return path.join(getProjectDir(), '.claude', 'coordination');\n}\n\n/**\n * Get the session metrics file path (cross-platform)\n * Uses CLAUDE_METRICS_FILE env var if set (for test isolation), otherwise temp dir.\n */\nexport function getMetricsFile(): string {\n  return process.env.CLAUDE_METRICS_FILE || path.join(getTempDir(), 'claude-session-metrics.json');\n}\n\n/**\n * Get the session error metrics file path (cross-platform)\n */\nexport function getSessionErrorsFile(): string {\n  return process.env.CLAUDE_SESSION_ERRORS_FILE || path.join(getTempDir(), 'claude-session-errors.json');\n}\n\n/**\n * Get the session temp directory for a given session ID (cross-platform)\n */\nexport function getSessionTempDir(sessionId: string): string {\n  return path.join(getTempDir(), `claude-session-${sessionId}`);\n}\n\n/**\n * Get the active todos file path (cross-platform)\n */\nexport function getActiveTodosFile(): string {\n  return path.join(getTempDir(), 'claude-active-todos.json');\n}\n\n/**\n * Get the context tracking state file path for a session (cross-platform)\n */\nexport function getContextTrackingFile(sessionId: string): string {\n  return path.join(getTempDir(), `claude-context-tracking-${sessionId}.json`);\n}\n\n/**\n * Get the read count temp file path (cross-platform)\n */\nexport function getReadCountFile(): string {\n  return path.join(getTempDir(), 'claude-read-count');\n}\n\n/**\n * Normalize a path for consistent comparison\n * Converts backslashes to forward slashes and removes trailing slashes\n */\nexport function normalizePath(p: string): string {\n  return path.normalize(p).replace(/\\\\/g, '/').replace(/\\/$/, '');\n}\n\n/**\n * Check if a path is absolute\n */\nexport function isAbsolutePath(p: string): boolean {\n  return path.isAbsolute(p);\n}\n\n/**\n * Join path segments (cross-platform)\n * Re-export for convenience\n */\nexport const joinPath = path.join;\n\n/**\n * Get path separator for current platform\n */\nexport const pathSeparator = path.sep;\n", "/**\n * Smart Session ID Generator\n * Generates human-readable session IDs when CLAUDE_SESSION_ID is not available.\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * Benefits:\n * - Human-readable at a glance\n * - Contains project context\n * - Contains branch info\n * - Chronologically sortable (date-time)\n * - Short unique suffix prevents collisions\n * - Valid file path characters only\n */\n\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, basename } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Maximum length for project name component */\nconst MAX_PROJECT_LENGTH = 20;\n\n/** Maximum length for branch name component */\nconst MAX_BRANCH_LENGTH = 15;\n\n/** Characters allowed in session ID (safe for file paths) */\nconst SAFE_CHARS = /[^a-z0-9-]/g;\n\n// =============================================================================\n// SESSION ID GENERATION\n// =============================================================================\n\n/**\n * Get project name from directory path\n * Sanitizes to lowercase alphanumeric with dashes\n */\nexport function getProjectName(projectDir?: string): string {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const name = basename(dir);\n  return sanitizeName(name, MAX_PROJECT_LENGTH);\n}\n\n/**\n * Get git branch name (cached for performance)\n * Returns 'nobranch' if git is not available or not in a repo\n */\nexport function getGitBranchForSession(projectDir?: string): string {\n  // Check cache first\n  if (process.env.ORCHESTKIT_SESSION_BRANCH) {\n    return process.env.ORCHESTKIT_SESSION_BRANCH;\n  }\n\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n\n    const sanitized = sanitizeName(branch || 'detached', MAX_BRANCH_LENGTH);\n    process.env.ORCHESTKIT_SESSION_BRANCH = sanitized;\n    return sanitized;\n  } catch {\n    return 'nobranch';\n  }\n}\n\n/**\n * Format current date as MMDD\n */\nexport function formatDateComponent(date?: Date): string {\n  const d = date || new Date();\n  const month = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  return `${month}${day}`;\n}\n\n/**\n * Format current time as HHMM (24-hour)\n */\nexport function formatTimeComponent(date?: Date): string {\n  const d = date || new Date();\n  const hours = String(d.getHours()).padStart(2, '0');\n  const minutes = String(d.getMinutes()).padStart(2, '0');\n  return `${hours}${minutes}`;\n}\n\n/**\n * Generate short hash for uniqueness (4 hex chars)\n * Uses PID + timestamp + random for entropy\n */\nexport function generateShortHash(): string {\n  const entropy = `${process.pid}-${Date.now()}-${Math.random()}`;\n  return createHash('sha256')\n    .update(entropy)\n    .digest('hex')\n    .slice(0, 4);\n}\n\n/**\n * Sanitize a name for use in session ID\n * - Lowercase\n * - Replace non-alphanumeric with dashes\n * - Collapse multiple dashes\n * - Trim dashes from ends\n * - Truncate to max length\n */\nexport function sanitizeName(name: string, maxLength: number): string {\n  return name\n    .toLowerCase()\n    .replace(SAFE_CHARS, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '')\n    .slice(0, maxLength);\n}\n\n/**\n * Generate a smart session ID\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * @param projectDir - Optional project directory (defaults to env or cwd)\n * @param date - Optional date for testing (defaults to now)\n */\nexport function generateSmartSessionId(projectDir?: string, date?: Date): string {\n  const project = getProjectName(projectDir);\n  const branch = getGitBranchForSession(projectDir);\n  const dateStr = formatDateComponent(date);\n  const timeStr = formatTimeComponent(date);\n  const hash = generateShortHash();\n\n  return `${project}-${branch}-${dateStr}-${timeStr}-${hash}`;\n}\n\n// =============================================================================\n// SESSION ID CACHING\n// =============================================================================\n\n/**\n * Get cached session ID from .instance directory\n * Returns undefined if not cached\n */\nexport function getCachedSessionId(projectDir?: string): string | undefined {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const cachePath = join(dir, '.instance', 'session-id.json');\n\n  if (!existsSync(cachePath)) {\n    return undefined;\n  }\n\n  try {\n    const data = JSON.parse(readFileSync(cachePath, 'utf8'));\n    // Validate the cached ID hasn't expired (24 hours)\n    if (data.session_id && data.created_at) {\n      const age = Date.now() - new Date(data.created_at).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n      if (age < maxAge) {\n        return data.session_id;\n      }\n    }\n  } catch {\n    // Ignore read/parse errors\n  }\n\n  return undefined;\n}\n\n/**\n * Cache session ID to .instance directory\n */\nexport function cacheSessionId(sessionId: string, projectDir?: string): void {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const instanceDir = join(dir, '.instance');\n  const cachePath = join(instanceDir, 'session-id.json');\n\n  try {\n    if (!existsSync(instanceDir)) {\n      mkdirSync(instanceDir, { recursive: true });\n    }\n\n    writeFileSync(cachePath, JSON.stringify({\n      session_id: sessionId,\n      created_at: new Date().toISOString(),\n    }, null, 2));\n  } catch {\n    // Ignore write errors - caching is optional\n  }\n}\n\n/**\n * Get or generate session ID with caching\n *\n * Priority:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate new smart session ID (and cache it)\n */\nexport function getOrGenerateSessionId(projectDir?: string): string {\n  // 1. Try CLAUDE_SESSION_ID first (preferred)\n  if (process.env.CLAUDE_SESSION_ID) {\n    return process.env.CLAUDE_SESSION_ID;\n  }\n\n  // 2. Try cached session ID\n  const cached = getCachedSessionId(projectDir);\n  if (cached) {\n    return cached;\n  }\n\n  // 3. Generate new smart session ID\n  const newId = generateSmartSessionId(projectDir);\n  cacheSessionId(newId, projectDir);\n  return newId;\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Auto-Remember Continuity - Stop Hook\n * Prompts Claude to store session context before end\n *\n * Graph-First Architecture (v2.1):\n * - ALWAYS works - knowledge graph requires no configuration\n * - Primary: Store in knowledge graph (mcp__memory__*)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir } from '../lib/common.js';\nimport { basename } from 'node:path';\n\n/**\n * Generate stop prompt for session continuity\n */\nexport function autoRememberContinuity(input: HookInput): HookResult {\n  logHook('auto-remember-continuity', 'Hook triggered');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const projectId = basename(projectDir) || 'project';\n\n  const _promptMsg = `Before ending this session, consider preserving important context in the knowledge graph:\n\n1. **Session Continuity** - If there's unfinished work or next steps:\n   \\`mcp__memory__create_entities\\` with:\n   \\`\\`\\`json\n   {\"entities\": [{\n     \"name\": \"session-${projectId}\",\n     \"entityType\": \"Session\",\n     \"observations\": [\"What was done: [...]\", \"Next steps: [...]\"]\n   }]}\n   \\`\\`\\`\n\n2. **Important Decisions** - If architectural/design decisions were made:\n   \\`mcp__memory__create_entities\\` with:\n   \\`\\`\\`json\n   {\"entities\": [{\n     \"name\": \"decision-[topic]\",\n     \"entityType\": \"Decision\",\n     \"observations\": [\"Decided: [...]\", \"Rationale: [...]\"]\n   }]}\n   \\`\\`\\`\n\n3. **Patterns Learned** - If something worked well or failed:\n   - Use \\`/remember --success \"pattern that worked\"\\`\n   - Use \\`/remember --failed \"pattern that caused issues\"\\`\n\nSkip if this was just a quick question/answer session.`;\n\n  logHook('auto-remember-continuity', 'Outputting memory prompt for session end');\n\n  return {\n    continue: true,\n    suppressOutput: true,\n    // Note: stopPrompt is handled by the CC runtime, we just return continue: true\n  };\n}\n", "/**\n * Auto-Save Context - Saves session context before stop\n * Hook: Stop\n * CC 2.1.6 Compliant - Context Protocol 2.0\n *\n * Ensures state.json always has required fields:\n * - $schema: For schema validation\n * - _meta: For attention positioning and token budgets\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\n\ninterface SessionState {\n  $schema: string;\n  _meta: {\n    position: string;\n    token_budget: number;\n    auto_load: string;\n    compress: string;\n    description: string;\n  };\n  session_id: string | null;\n  started: string | null;\n  last_activity: string;\n  current_task: {\n    description: string;\n    status: string;\n  };\n  next_steps: string[];\n  blockers: string[];\n}\n\n/**\n * Auto-save context on session stop\n */\nexport function autoSaveContext(input: HookInput): HookResult {\n  logHook('auto-save-context', 'Stop hook - auto-saving context (Protocol 2.0)');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionDir = `${projectDir}/.claude/context/session`;\n  const sessionState = `${sessionDir}/state.json`;\n\n  // Ensure session directory exists\n  try {\n    if (!existsSync(sessionDir)) {\n      mkdirSync(sessionDir, { recursive: true });\n    }\n  } catch {\n    // Ignore directory creation errors\n  }\n\n  const timestamp = new Date().toISOString();\n\n  try {\n    if (existsSync(sessionState)) {\n      // Update existing session state\n      const content = readFileSync(sessionState, 'utf-8');\n      const state: Partial<SessionState> = JSON.parse(content);\n\n      // Ensure required fields exist\n      const updated: SessionState = {\n        $schema: state.$schema || 'context://session/v1',\n        _meta: state._meta || {\n          position: 'END',\n          token_budget: 500,\n          auto_load: 'always',\n          compress: 'on_threshold',\n          description: 'Session state and progress - ALWAYS loaded at END of context',\n        },\n        session_id: state.session_id || null,\n        started: state.started || null,\n        last_activity: timestamp,\n        current_task: state.current_task || { description: 'No active task', status: 'pending' },\n        next_steps: state.next_steps || [],\n        blockers: state.blockers || [],\n      };\n\n      writeFileSync(sessionState, JSON.stringify(updated, null, 2));\n      logHook('auto-save-context', 'Updated session state timestamp');\n    } else {\n      // Create new session state\n      const newState: SessionState = {\n        $schema: 'context://session/v1',\n        _meta: {\n          position: 'END',\n          token_budget: 500,\n          auto_load: 'always',\n          compress: 'on_threshold',\n          description: 'Session state and progress - ALWAYS loaded at END of context',\n        },\n        session_id: null,\n        started: timestamp,\n        last_activity: timestamp,\n        current_task: {\n          description: 'No active task',\n          status: 'pending',\n        },\n        next_steps: [],\n        blockers: [],\n      };\n\n      writeFileSync(sessionState, JSON.stringify(newState, null, 2));\n      logHook('auto-save-context', 'Created new session state (Protocol 2.0 compliant)');\n    }\n  } catch (error) {\n    logHook('auto-save-context', `Error saving context: ${error}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Full Test Suite Runner - Stop Hook\n * CC 2.1.3 Compliant - Uses 10-minute hook timeout\n *\n * Runs the complete test suite on conversation stop.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\n\n/**\n * Check if we should run tests\n */\nfunction shouldRunTests(projectDir: string): boolean {\n  const lastRunFile = `${projectDir}/.claude/hooks/logs/.last-test-run`;\n\n  // Always run if no previous run\n  if (!existsSync(lastRunFile)) {\n    return true;\n  }\n\n  // Check if any code files changed since last run\n  try {\n    const result = execSync('git diff --name-only HEAD', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n\n    if (/\\.(py|js|ts|go|rs)$/.test(result)) {\n      return true;\n    }\n  } catch {\n    // On error, run tests anyway\n    return true;\n  }\n\n  logHook('full-test-suite', 'No code changes detected, skipping tests');\n  return false;\n}\n\n/**\n * Detect project type and run appropriate tests\n */\nfunction runTests(projectDir: string, _logFile: string): boolean {\n  let exitCode = 0;\n\n  // Python project (pytest)\n  if (\n    existsSync(`${projectDir}/pytest.ini`) ||\n    existsSync(`${projectDir}/pyproject.toml`) ||\n    (existsSync(`${projectDir}/tests`) && existsSync(`${projectDir}/requirements.txt`))\n  ) {\n    logHook('full-test-suite', 'Detected Python project, running pytest...');\n    try {\n      execSync('pytest --tb=short --timeout=300 -q', {\n        cwd: projectDir,\n        encoding: 'utf8',\n        timeout: 300000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n    } catch {\n      exitCode = 1;\n    }\n  }\n\n  // Node.js project (npm/yarn/pnpm)\n  if (existsSync(`${projectDir}/package.json`)) {\n    logHook('full-test-suite', 'Detected Node.js project...');\n    try {\n      const packageJson = JSON.parse(readFileSync(`${projectDir}/package.json`, 'utf-8'));\n      if (packageJson.scripts?.test) {\n        logHook('full-test-suite', 'Running npm test...');\n\n        // Try different package managers\n        let cmd = 'npm test -- --passWithNoTests --watchAll=false';\n        try {\n          execSync('which pnpm', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n          cmd = 'pnpm test --passWithNoTests';\n        } catch {\n          try {\n            execSync('which yarn', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n            cmd = 'yarn test --passWithNoTests';\n          } catch {\n            // Use npm\n          }\n        }\n\n        execSync(cmd, {\n          cwd: projectDir,\n          encoding: 'utf8',\n          timeout: 300000,\n          stdio: ['pipe', 'pipe', 'pipe'],\n        });\n      }\n    } catch {\n      exitCode = 1;\n    }\n  }\n\n  // Go project\n  if (existsSync(`${projectDir}/go.mod`)) {\n    logHook('full-test-suite', 'Detected Go project, running go test...');\n    try {\n      execSync('go test -v -timeout 5m ./...', {\n        cwd: projectDir,\n        encoding: 'utf8',\n        timeout: 300000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n    } catch {\n      exitCode = 1;\n    }\n  }\n\n  // Rust project\n  if (existsSync(`${projectDir}/Cargo.toml`)) {\n    logHook('full-test-suite', 'Detected Rust project, running cargo test...');\n    try {\n      execSync('cargo test', {\n        cwd: projectDir,\n        encoding: 'utf8',\n        timeout: 300000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n    } catch {\n      exitCode = 1;\n    }\n  }\n\n  return exitCode === 0;\n}\n\n/**\n * Full test suite runner\n */\nexport function fullTestSuite(input: HookInput): HookResult {\n  logHook('full-test-suite', '=== Full Test Suite Started ===');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const logDir = `${projectDir}/.claude/hooks/logs`;\n\n  // Ensure log directory exists\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const logFile = `${logDir}/full-test-suite.log`;\n\n  if (!shouldRunTests(projectDir)) {\n    return outputSilentSuccess();\n  }\n\n  const passed = runTests(projectDir, logFile);\n\n  if (passed) {\n    logHook('full-test-suite', '=== All tests passed ===');\n    // Update last run file\n    try {\n      writeFileSync(`${logDir}/.last-test-run`, String(Date.now()));\n    } catch {\n      // Ignore\n    }\n  } else {\n    logHook('full-test-suite', '=== Some tests failed ===');\n    // Don't block - just log the failure\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Issue Work Summary - Stop Hook\n * Posts consolidated progress comments to GitHub issues\n *\n * CC 2.1.7 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, readFileSync, unlinkSync, rmdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, getSessionId, outputSilentSuccess } from '../lib/common.js';\nimport { getSessionTempDir } from '../lib/paths.js';\nimport { assertSafeIssueNumber } from '../lib/sanitize-shell.js';\n\ninterface IssueProgress {\n  issues: {\n    [issueNum: string]: {\n      branch: string;\n      commits: Array<{ sha: string; message: string }>;\n      tasks_completed: string[];\n    };\n  };\n}\n\n/**\n * Check if gh CLI is available and authenticated\n */\nfunction isGhAvailable(): boolean {\n  try {\n    execSync('which gh', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n    execSync('gh auth status', { encoding: 'utf8', timeout: 5000, stdio: ['pipe', 'pipe', 'pipe'] });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if in a GitHub repository\n */\nfunction isGitHubRepo(projectDir: string): boolean {\n  try {\n    const remote = execSync('git remote get-url origin', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return remote.includes('github');\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Generate markdown comment for an issue\n */\nfunction generateComment(_issueNum: string, data: IssueProgress['issues'][string], sessionId: string): string {\n  const commits = data.commits || [];\n  if (commits.length === 0) {\n    return '';\n  }\n\n  const commitsSection = commits.map((c) => `- \\`${c.sha}\\`: ${c.message}`).join('\\n');\n  const tasksSection =\n    data.tasks_completed?.length > 0\n      ? `### Sub-tasks Completed\\n${data.tasks_completed.map((t) => `- [x] ${t}`).join('\\n')}`\n      : '';\n\n  return `## Claude Code Progress Update\n\n**Session**: \\`${sessionId.slice(0, 8)}...\\`\n**Branch**: \\`${data.branch || 'unknown'}\\`\n\n### Commits (${commits.length})\n${commitsSection}\n\n${tasksSection}\n---\n*Automated by [OrchestKit](https://github.com/yonatangross/orchestkit)*`;\n}\n\n/**\n * Post comment to GitHub issue\n */\nfunction postComment(issueNum: string, comment: string): boolean {\n  try {\n    // Sanitize issueNum to digits only to prevent command injection\n    const safeIssueNum = issueNum.replace(/[^0-9]/g, '');\n    if (!safeIssueNum) return false;\n\n    // Use stdin to pass comment body, avoiding shell escaping issues entirely\n    execSync(`gh issue comment ${safeIssueNum} --body-file -`, {\n      input: comment,\n      encoding: 'utf8',\n      timeout: 30000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Issue work summary hook\n */\nexport function issueWorkSummary(input: HookInput): HookResult {\n  logHook('issue-work-summary', 'Session ending, checking for issue progress to post...');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionId = input.session_id || getSessionId();\n\n  // Sanitize session ID to prevent path traversal\n  const safeSessionId = sessionId.replace(/[^a-zA-Z0-9_-]/g, '');\n  const sessionDir = getSessionTempDir(safeSessionId);\n  const progressFile = `${sessionDir}/issue-progress.json`;\n\n  // Check if progress file exists\n  if (!existsSync(progressFile)) {\n    logHook('issue-work-summary', `No progress file found at ${progressFile}`);\n    return outputSilentSuccess();\n  }\n\n  // Check if gh CLI is available\n  if (!isGhAvailable()) {\n    logHook('issue-work-summary', 'gh CLI not available or not authenticated, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Check if we're in a GitHub repo\n  if (!isGitHubRepo(projectDir)) {\n    logHook('issue-work-summary', 'Not a GitHub repository, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Read progress file\n  let progressJson: IssueProgress;\n  try {\n    progressJson = JSON.parse(readFileSync(progressFile, 'utf-8'));\n  } catch {\n    logHook('issue-work-summary', 'Failed to read progress file');\n    return outputSilentSuccess();\n  }\n\n  const issues = progressJson.issues ? Object.keys(progressJson.issues) : [];\n  if (issues.length === 0) {\n    logHook('issue-work-summary', 'No issues to process');\n    return outputSilentSuccess();\n  }\n\n  // Process each issue\n  let postedCount = 0;\n  for (const issueNum of issues) {\n    const issueData = progressJson.issues[issueNum];\n    const commits = issueData.commits || [];\n\n    if (commits.length === 0) {\n      logHook('issue-work-summary', `No commits for issue #${issueNum}, skipping`);\n      continue;\n    }\n\n    // Verify issue exists\n    try {\n      execSync(`gh issue view ${assertSafeIssueNumber(issueNum)} --json number`, {\n        encoding: 'utf8',\n        timeout: 10000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n    } catch {\n      logHook('issue-work-summary', `Issue #${issueNum} not found or not accessible, skipping`);\n      continue;\n    }\n\n    // Generate and post comment\n    const comment = generateComment(issueNum, issueData, sessionId);\n    if (comment && postComment(issueNum, comment)) {\n      postedCount++;\n      logHook('issue-work-summary', `Successfully posted comment to issue #${issueNum}`);\n    }\n  }\n\n  logHook('issue-work-summary', `Posted progress comments to ${postedCount} issue(s)`);\n\n  // Clean up progress file\n  try {\n    unlinkSync(progressFile);\n    // Remove session dir if empty\n    try {\n      rmdirSync(sessionDir);\n    } catch {\n      // Directory not empty, leave it\n    }\n    logHook('issue-work-summary', 'Cleaned up progress file');\n  } catch {\n    // Ignore cleanup errors\n  }\n\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-23\n\n/**\n * Shell argument sanitization for safe command construction\n *\n * Prevents shell injection by validating arguments against strict allowlists\n * or quoting them safely for shell consumption.\n */\n\n/**\n * Strict allowlist regex for safe shell arguments: alphanumeric, dots, slashes,\n * hyphens, underscores, tildes, equals, colons, at-signs.\n * Rejects anything containing shell metacharacters.\n */\nconst SAFE_ARG_RE = /^[a-zA-Z0-9._/~=:@-]+$/;\n\n/**\n * Validate that a string is safe to interpolate into a shell command.\n * Returns the string unchanged if it matches the allowlist, otherwise throws.\n */\nexport function assertSafeShellArg(arg: string, label = 'argument'): string {\n  if (!arg || !SAFE_ARG_RE.test(arg)) {\n    throw new Error(`Unsafe shell ${label}: ${JSON.stringify(arg)}`);\n  }\n  return arg;\n}\n\n/**\n * Quote a string for safe use in a single-quoted shell argument.\n * Wraps in single quotes with internal single-quote escaping.\n * Safe for arbitrary content including spaces and special characters.\n */\nexport function shellQuote(arg: string): string {\n  return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n}\n\n/**\n * Validate that a string looks like a git ref (branch name, tag, or SHA).\n * Allows: alphanumeric, dots, slashes, hyphens, underscores.\n * Rejects shell metacharacters, spaces, and anything suspicious.\n */\nexport function assertSafeGitRef(ref: string, label = 'git ref'): string {\n  if (!ref || !/^[a-zA-Z0-9._/-]+$/.test(ref)) {\n    throw new Error(`Unsafe ${label}: ${JSON.stringify(ref)}`);\n  }\n  return ref;\n}\n\n/**\n * Validate that a string is a simple command name (no path separators or spaces).\n * For use with `command -v` / `which` checks.\n */\nexport function assertSafeCommandName(cmd: string): string {\n  if (!cmd || !/^[a-zA-Z0-9_-]+$/.test(cmd)) {\n    throw new Error(`Unsafe command name: ${JSON.stringify(cmd)}`);\n  }\n  return cmd;\n}\n\n/**\n * Validate that a string is a safe filename glob pattern.\n * Allows: alphanumeric, dots, underscores, hyphens, asterisks (for globs).\n * For use with `find -name` inside double quotes (shell won't expand globs).\n */\nexport function assertSafeGlobPattern(pattern: string, label = 'glob pattern'): string {\n  if (!pattern || !/^[a-zA-Z0-9._*-]+$/.test(pattern)) {\n    throw new Error(`Unsafe ${label}: ${JSON.stringify(pattern)}`);\n  }\n  return pattern;\n}\n\n/**\n * Validate that a string looks like a GitHub issue number (digits only).\n */\nexport function assertSafeIssueNumber(num: string): string {\n  if (!num || !/^\\d+$/.test(num)) {\n    throw new Error(`Unsafe issue number: ${JSON.stringify(num)}`);\n  }\n  return num;\n}\n", "/**\n * Security Scan Aggregator - Stop Hook\n * CC 2.1.3 Compliant - Uses 10-minute hook timeout\n *\n * Runs multiple security tools in parallel and aggregates results.\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync, readdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\nimport { assertSafeShellArg } from '../lib/sanitize-shell.js';\n\ninterface SecurityResults {\n  npmAudit: { critical: number; high: number } | null;\n  pipAudit: number | null;\n  semgrep: number | null;\n  bandit: number | null;\n  secrets: number;\n}\n\n/**\n * Run npm audit\n */\nfunction runNpmAudit(projectDir: string, resultsDir: string): { critical: number; high: number } | null {\n  if (\n    !existsSync(`${projectDir}/package.json`) ||\n    (!existsSync(`${projectDir}/package-lock.json`) &&\n      !existsSync(`${projectDir}/yarn.lock`) &&\n      !existsSync(`${projectDir}/pnpm-lock.yaml`))\n  ) {\n    return null;\n  }\n\n  logHook('security-scan', 'Running npm audit...');\n  try {\n    execSync('npm audit --json', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 120000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n  } catch (error: any) {\n    // npm audit returns non-zero on vulnerabilities, capture output\n    if (error.stdout) {\n      writeFileSync(`${resultsDir}/npm-audit.json`, error.stdout);\n      try {\n        const result = JSON.parse(error.stdout);\n        return {\n          critical: result.metadata?.vulnerabilities?.critical || 0,\n          high: result.metadata?.vulnerabilities?.high || 0,\n        };\n      } catch {\n        // Ignore parse errors\n      }\n    }\n  }\n  logHook('security-scan', 'npm audit complete');\n  return { critical: 0, high: 0 };\n}\n\n/**\n * Run pip-audit\n */\nfunction runPipAudit(projectDir: string, resultsDir: string): number | null {\n  if (!existsSync(`${projectDir}/requirements.txt`) && !existsSync(`${projectDir}/pyproject.toml`)) {\n    return null;\n  }\n\n  try {\n    execSync('which pip-audit', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n  } catch {\n    logHook('security-scan', 'pip-audit not installed, skipping');\n    return null;\n  }\n\n  logHook('security-scan', 'Running pip-audit...');\n  try {\n    const result = execSync('pip-audit --format json', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 120000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    writeFileSync(`${resultsDir}/pip-audit.json`, result);\n    const parsed = JSON.parse(result);\n    logHook('security-scan', 'pip-audit complete');\n    return Array.isArray(parsed) ? parsed.length : 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Run semgrep\n */\nfunction runSemgrep(projectDir: string, resultsDir: string): number | null {\n  try {\n    execSync('which semgrep', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n  } catch {\n    logHook('security-scan', 'semgrep not installed, skipping');\n    return null;\n  }\n\n  logHook('security-scan', 'Running semgrep...');\n  try {\n    const result = execSync('semgrep --config auto --json --quiet', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 300000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    writeFileSync(`${resultsDir}/semgrep.json`, result);\n    const parsed = JSON.parse(result);\n    const highSeverity = (parsed.results || []).filter((r: any) => r.extra?.severity === 'ERROR').length;\n    logHook('security-scan', 'semgrep complete');\n    return highSeverity;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Run bandit\n */\nfunction runBandit(projectDir: string, resultsDir: string): number | null {\n  // Check for Python files\n  try {\n    const hasPython = execSync('find . -name \"*.py\" -maxdepth 2 | head -1', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    if (!hasPython && !existsSync(`${projectDir}/backend`)) {\n      return null;\n    }\n  } catch {\n    return null;\n  }\n\n  try {\n    execSync('which bandit', { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });\n  } catch {\n    logHook('security-scan', 'bandit not installed, skipping');\n    return null;\n  }\n\n  logHook('security-scan', 'Running bandit...');\n  try {\n    const safeResultsDir = assertSafeShellArg(resultsDir, 'results dir');\n    execSync(`bandit -r . -f json -o ${safeResultsDir}/bandit.json`, {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 120000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    logHook('security-scan', 'bandit complete');\n    return 0;\n  } catch {\n    // Bandit exits non-zero when issues found\n    return 0;\n  }\n}\n\n/**\n * Run secret detection\n */\nfunction runSecretScan(projectDir: string, resultsDir: string): number {\n  logHook('security-scan', 'Running secret detection...');\n\n  const secretPatterns = /(api[_-]?key|secret[_-]?key|password|token)\\s*[=:]\\s*[\"'][^\"']{8,}/i;\n  let secretsFound = 0;\n  const findings: Array<{ file: string; type: string }> = [];\n\n  const extensions = ['.py', '.js', '.ts', '.env'];\n\n  function scanDir(dir: string): void {\n    try {\n      const entries = readdirSync(dir, { withFileTypes: true });\n      for (const entry of entries) {\n        const fullPath = `${dir}/${entry.name}`;\n\n        // Skip node_modules and .git\n        if (entry.isDirectory()) {\n          if (!['node_modules', '.git', 'dist', 'build'].includes(entry.name)) {\n            scanDir(fullPath);\n          }\n          continue;\n        }\n\n        // Check file extension\n        if (!extensions.some((ext) => entry.name.endsWith(ext))) {\n          continue;\n        }\n\n        try {\n          const content = readFileSync(fullPath, 'utf-8');\n          if (secretPatterns.test(content)) {\n            findings.push({ file: fullPath, type: 'potential_secret' });\n            secretsFound++;\n          }\n        } catch {\n          // Ignore read errors\n        }\n      }\n    } catch {\n      // Ignore directory errors\n    }\n  }\n\n  scanDir(projectDir);\n\n  writeFileSync(\n    `${resultsDir}/secrets.json`,\n    JSON.stringify({ findings, count: secretsFound }, null, 2)\n  );\n\n  logHook('security-scan', `Secret detection complete: ${secretsFound} potential issues`);\n  return secretsFound;\n}\n\n/**\n * Aggregate results\n */\nfunction aggregateResults(resultsDir: string, results: SecurityResults): void {\n  logHook('security-scan', 'Aggregating results...');\n\n  let totalCritical = 0;\n  let totalHigh = 0;\n\n  if (results.npmAudit) {\n    totalCritical += results.npmAudit.critical;\n    totalHigh += results.npmAudit.high;\n  }\n  if (results.pipAudit !== null) {\n    totalHigh += results.pipAudit;\n  }\n  if (results.semgrep !== null) {\n    totalHigh += results.semgrep;\n  }\n\n  const scansCompleted = readdirSync(resultsDir)\n    .filter((f) => f.endsWith('.json') && !f.includes('aggregated'))\n    .map((f) => f.replace('.json', ''));\n\n  const report = {\n    timestamp: new Date().toISOString(),\n    summary: {\n      critical: totalCritical,\n      high: totalHigh,\n      medium: 0,\n    },\n    scans_completed: scansCompleted,\n  };\n\n  writeFileSync(`${resultsDir}/aggregated-report.json`, JSON.stringify(report, null, 2));\n\n  logHook('security-scan', '=== Security Scan Complete ===');\n  logHook('security-scan', `Critical: ${totalCritical}, High: ${totalHigh}`);\n\n  if (totalCritical > 0) {\n    console.error(`Security: ${totalCritical} critical, ${totalHigh} high vulnerabilities found`);\n  }\n}\n\n/**\n * Security scan aggregator hook\n */\nexport function securityScanAggregator(input: HookInput): HookResult {\n  logHook('security-scan', '=== Security Scan Started ===');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const resultsDir = `${projectDir}/.claude/hooks/logs/security`;\n\n  mkdirSync(resultsDir, { recursive: true });\n\n  const results: SecurityResults = {\n    npmAudit: null,\n    pipAudit: null,\n    semgrep: null,\n    bandit: null,\n    secrets: 0,\n  };\n\n  // Run scans (sequentially in TS to avoid complexity, but could be parallelized)\n  results.npmAudit = runNpmAudit(projectDir, resultsDir);\n  results.pipAudit = runPipAudit(projectDir, resultsDir);\n  results.semgrep = runSemgrep(projectDir, resultsDir);\n  results.bandit = runBandit(projectDir, resultsDir);\n  results.secrets = runSecretScan(projectDir, resultsDir);\n\n  // Aggregate results\n  aggregateResults(resultsDir, results);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Session Patterns - Unified pattern learning at session end\n * Part of OrchestKit Plugin - Cross-Project Patterns (#48) + Best Practices (#49)\n *\n * This hook processes patterns at session end:\n * 1. Extracts workflow patterns (tool sequences, workflow types, languages)\n * 2. Merges queued patterns into learned-patterns.json\n * 3. Updates workflow profile for session analytics\n *\n * CC 2.1.7 Compliant: Uses suppressOutput for silent operation\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';\nimport { loadSessionEvents } from '../lib/session-tracker.js';\nimport { getToolCategory } from '../lib/tool-categories.js';\nimport { getMetricsFile } from '../lib/paths.js';\n\ninterface WorkflowProfile {\n  version: string;\n  last_updated: string | null;\n  sessions_count: number;\n  workflow_types: Record<string, number>;\n  common_tool_sequences: string[];\n  dominant_languages: Record<string, number>;\n  average_tools_per_session: number;\n  average_session_duration_seconds: number;\n  tool_frequency: Record<string, number>;\n}\n\ninterface LearnedPatterns {\n  version: string;\n  updated: string;\n  patterns: Array<{\n    text: string;\n    outcome: string;\n    category: string;\n    timestamp: string;\n  }>;\n  categories: Record<string, number>;\n  stats: {\n    total: number;\n    successes: number;\n    failures: number;\n  };\n}\n\ninterface SessionMetrics {\n  tools?: Record<string, number>;\n}\n\n/**\n * Extract tool usage sequence from session metrics\n */\nfunction extractToolSequence(metricsFile: string): string {\n  if (!existsSync(metricsFile)) {\n    return '';\n  }\n\n  try {\n    const metrics: SessionMetrics = JSON.parse(readFileSync(metricsFile, 'utf-8'));\n    const tools = metrics.tools || {};\n    const sorted = Object.entries(tools)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([tool]) => tool);\n    return sorted.join(',');\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Get total tool invocations from metrics\n */\nfunction getToolCount(metricsFile: string): number {\n  if (!existsSync(metricsFile)) {\n    return 0;\n  }\n\n  try {\n    const metrics: SessionMetrics = JSON.parse(readFileSync(metricsFile, 'utf-8'));\n    const tools = metrics.tools || {};\n    return Object.values(tools).reduce((sum, count) => sum + count, 0);\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Detect workflow type based on tool usage patterns\n */\nfunction detectWorkflowType(tools: string): string {\n  if (tools.includes('Write') && tools.includes('Bash')) {\n    if (/test|pytest|jest|vitest/i.test(tools)) {\n      return 'test-driven-development';\n    }\n  }\n\n  if (tools.includes('Read') && tools.includes('Grep')) {\n    return 'code-exploration';\n  }\n\n  if (tools.includes('Edit') && !tools.includes('Write')) {\n    return 'refactoring';\n  }\n\n  if (tools.includes('Write') && tools.includes('Read')) {\n    return 'feature-development';\n  }\n\n  if (tools.includes('Bash') && /git|gh/i.test(tools)) {\n    return 'git-operations';\n  }\n\n  return 'general';\n}\n\n/**\n * Detect dominant language from tool sequence (simplified)\n */\nfunction detectDominantLanguage(_tools: string): string {\n  // In a real implementation, this would analyze file extensions from hook logs\n  // For now, return 'unknown' as we don't have file access patterns in TS\n  return 'unknown';\n}\n\n/**\n * Initialize workflow profile if needed\n */\nfunction initWorkflowProfile(profilePath: string): WorkflowProfile {\n  if (existsSync(profilePath)) {\n    try {\n      return JSON.parse(readFileSync(profilePath, 'utf-8'));\n    } catch {\n      // Fall through to create new\n    }\n  }\n\n  return {\n    version: '1.0.0',\n    last_updated: null,\n    sessions_count: 0,\n    workflow_types: {\n      'test-driven-development': 0,\n      'code-exploration': 0,\n      refactoring: 0,\n      'feature-development': 0,\n      'git-operations': 0,\n      general: 0,\n    },\n    common_tool_sequences: [],\n    dominant_languages: {\n      python: 0,\n      typescript: 0,\n      javascript: 0,\n      go: 0,\n      rust: 0,\n      unknown: 0,\n    },\n    average_tools_per_session: 0,\n    average_session_duration_seconds: 0,\n    tool_frequency: {},\n  };\n}\n\n/**\n * Update workflow profile with session data\n */\nfunction updateWorkflowProfile(\n  profilePath: string,\n  workflowType: string,\n  dominantLang: string,\n  toolCount: number,\n  toolSequence: string\n): void {\n  const profile = initWorkflowProfile(profilePath);\n  const timestamp = new Date().toISOString();\n\n  profile.last_updated = timestamp;\n  profile.sessions_count += 1;\n\n  // Update workflow type counts\n  profile.workflow_types[workflowType] = (profile.workflow_types[workflowType] || 0) + 1;\n\n  // Update dominant language counts\n  profile.dominant_languages[dominantLang] = (profile.dominant_languages[dominantLang] || 0) + 1;\n\n  // Update running averages\n  profile.average_tools_per_session =\n    (profile.average_tools_per_session * (profile.sessions_count - 1) + toolCount) / profile.sessions_count;\n\n  // Add tool sequence if meaningful\n  const sequenceTools = toolSequence.split(',').filter(Boolean);\n  if (sequenceTools.length > 2) {\n    const seqSet = new Set([toolSequence, ...profile.common_tool_sequences]);\n    profile.common_tool_sequences = Array.from(seqSet).slice(0, 20);\n  }\n\n  mkdirSync(profilePath.replace(/\\/[^/]+$/, ''), { recursive: true });\n  writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n}\n\n/**\n * Initialize learned patterns file if needed\n */\nfunction initPatternsFile(patternsPath: string): LearnedPatterns {\n  if (existsSync(patternsPath)) {\n    try {\n      return JSON.parse(readFileSync(patternsPath, 'utf-8'));\n    } catch {\n      // Fall through to create new\n    }\n  }\n\n  return {\n    version: '1.0',\n    updated: '',\n    patterns: [],\n    categories: {},\n    stats: {\n      total: 0,\n      successes: 0,\n      failures: 0,\n    },\n  };\n}\n\n/**\n * Aggregate tool usage by category from session events\n * Issue #245 Phase 4: Tool Usage Tracking\n *\n * @returns Object with:\n *   - usageByCategory: { category: { tool: count } }\n *   - preferences: { category: preferredTool }\n */\nfunction aggregateToolPreferences(): {\n  usageByCategory: Record<string, Record<string, number>>;\n  preferences: Record<string, string>;\n} {\n  const usageByCategory: Record<string, Record<string, number>> = {};\n\n  try {\n    const events = loadSessionEvents();\n    const toolEvents = events.filter(e => e.event_type === 'tool_used');\n\n    for (const event of toolEvents) {\n      const toolName = event.payload.name;\n      // Get category from event payload if present, otherwise derive it\n      const category = (event.payload.input as Record<string, unknown>)?.category as string\n        || getToolCategory(toolName);\n\n      if (!usageByCategory[category]) {\n        usageByCategory[category] = {};\n      }\n      usageByCategory[category][toolName] = (usageByCategory[category][toolName] || 0) + 1;\n    }\n  } catch {\n    // Ignore errors, return empty\n  }\n\n  // Calculate preferred tool per category (most used)\n  const preferences: Record<string, string> = {};\n  for (const [category, tools] of Object.entries(usageByCategory)) {\n    const sorted = Object.entries(tools).sort(([, a], [, b]) => b - a);\n    if (sorted.length > 0) {\n      preferences[category] = sorted[0][0];\n    }\n  }\n\n  return { usageByCategory, preferences };\n}\n\n/**\n * Update workflow profile with tool preferences\n */\nfunction updateToolPreferences(projectDir: string): void {\n  const { usageByCategory, preferences } = aggregateToolPreferences();\n\n  if (Object.keys(preferences).length === 0) {\n    logHook('session-patterns', 'No tool usage to aggregate');\n    return;\n  }\n\n  // Store in a separate tool-preferences file for easy access\n  const prefsPath = `${projectDir}/.claude/feedback/tool-preferences.json`;\n\n  let existingPrefs: {\n    version: string;\n    updated: string;\n    usage_by_category: Record<string, Record<string, number>>;\n    preferences: Record<string, string>;\n    sessions_aggregated: number;\n  } = {\n    version: '1.0.0',\n    updated: '',\n    usage_by_category: {},\n    preferences: {},\n    sessions_aggregated: 0,\n  };\n\n  // Load existing if present\n  if (existsSync(prefsPath)) {\n    try {\n      existingPrefs = JSON.parse(readFileSync(prefsPath, 'utf-8'));\n    } catch {\n      // Use default\n    }\n  }\n\n  // Merge category usage (accumulate counts)\n  for (const [category, tools] of Object.entries(usageByCategory)) {\n    if (!existingPrefs.usage_by_category[category]) {\n      existingPrefs.usage_by_category[category] = {};\n    }\n    for (const [tool, count] of Object.entries(tools)) {\n      existingPrefs.usage_by_category[category][tool] =\n        (existingPrefs.usage_by_category[category][tool] || 0) + count;\n    }\n  }\n\n  // Recalculate preferences from accumulated data\n  for (const [category, tools] of Object.entries(existingPrefs.usage_by_category)) {\n    const sorted = Object.entries(tools).sort(([, a], [, b]) => b - a);\n    if (sorted.length > 0) {\n      existingPrefs.preferences[category] = sorted[0][0];\n    }\n  }\n\n  existingPrefs.updated = new Date().toISOString();\n  existingPrefs.sessions_aggregated += 1;\n\n  mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n  writeFileSync(prefsPath, JSON.stringify(existingPrefs, null, 2));\n\n  const prefCount = Object.keys(existingPrefs.preferences).length;\n  logHook('session-patterns', `Updated tool preferences: ${prefCount} categories`);\n}\n\n/**\n * Merge queued patterns into learned patterns file\n */\nfunction mergePatterns(projectDir: string): void {\n  const queuePath = `${projectDir}/.claude/feedback/patterns-queue.json`;\n  const patternsPath = `${projectDir}/.claude/feedback/learned-patterns.json`;\n\n  if (!existsSync(queuePath)) {\n    logHook('session-patterns', 'No patterns queue found');\n    return;\n  }\n\n  let queue: { patterns: LearnedPatterns['patterns'] };\n  try {\n    queue = JSON.parse(readFileSync(queuePath, 'utf-8'));\n  } catch {\n    logHook('session-patterns', 'Failed to parse patterns queue');\n    return;\n  }\n\n  const queueCount = queue.patterns?.length || 0;\n  if (queueCount === 0) {\n    logHook('session-patterns', 'Patterns queue is empty');\n    return;\n  }\n\n  logHook('session-patterns', `Processing ${queueCount} queued patterns...`);\n\n  const existing = initPatternsFile(patternsPath);\n  const now = new Date().toISOString();\n\n  // Merge and deduplicate patterns by text (keep most recent)\n  const allPatterns = [...existing.patterns, ...queue.patterns];\n  const patternMap = new Map<string, (typeof allPatterns)[0]>();\n  for (const p of allPatterns) {\n    patternMap.set(p.text, p);\n  }\n  const mergedPatterns = Array.from(patternMap.values());\n\n  // Calculate stats\n  const successes = mergedPatterns.filter((p) => p.outcome === 'success').length;\n  const failures = mergedPatterns.filter((p) => p.outcome === 'failed').length;\n\n  // Group by category\n  const categories: Record<string, number> = {};\n  for (const p of mergedPatterns) {\n    categories[p.category] = (categories[p.category] || 0) + 1;\n  }\n\n  const updated: LearnedPatterns = {\n    version: '1.0',\n    updated: now,\n    patterns: mergedPatterns,\n    categories,\n    stats: {\n      total: mergedPatterns.length,\n      successes,\n      failures,\n    },\n  };\n\n  mkdirSync(patternsPath.replace(/\\/[^/]+$/, ''), { recursive: true });\n  writeFileSync(patternsPath, JSON.stringify(updated, null, 2));\n  logHook('session-patterns', 'Merged patterns successfully');\n\n  // Clear the queue\n  writeFileSync(queuePath, JSON.stringify({ patterns: [] }));\n}\n\n/**\n * Session patterns hook\n */\nexport function sessionPatterns(input: HookInput): HookResult {\n  logHook('session-patterns', 'Session ending, processing patterns...');\n\n  const projectDir = input.project_dir || getProjectDir();\n  const metricsFile = getMetricsFile();\n  const workflowProfile = `${projectDir}/.claude/feedback/workflow-patterns.json`;\n\n  // Ensure directories exist\n  mkdirSync(`${projectDir}/.claude/feedback`, { recursive: true });\n  mkdirSync(`${projectDir}/.claude/logs`, { recursive: true });\n\n  // 1. Process workflow patterns\n  const toolCount = getToolCount(metricsFile);\n\n  if (toolCount >= 5) {\n    const toolSequence = extractToolSequence(metricsFile);\n    const workflowType = detectWorkflowType(toolSequence);\n    const dominantLang = detectDominantLanguage(toolSequence);\n\n    updateWorkflowProfile(workflowProfile, workflowType, dominantLang, toolCount, toolSequence);\n\n    logHook('session-patterns', `Workflow analyzed: type=${workflowType} lang=${dominantLang} tools=${toolCount}`);\n  } else {\n    logHook('session-patterns', `Session too short for workflow analysis (tools: ${toolCount})`);\n  }\n\n  // 2. Aggregate tool preferences by category (Phase 4)\n  updateToolPreferences(projectDir);\n\n  // 3. Merge queued patterns\n  mergePatterns(projectDir);\n\n  logHook('session-patterns', 'Pattern processing complete');\n\n  return outputSilentSuccess();\n}\n", "/**\n * Session Event Tracker\n * Logs all session events (skills, agents, hooks, decisions) with user identity.\n *\n * Events are stored per-session in JSONL format for later aggregation.\n * This enables learning user patterns across sessions.\n *\n * Storage: .claude/memory/sessions/{session_id}/events.jsonl\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport { getIdentityContext, type IdentityContext } from './user-identity.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Event types that can be tracked\n */\nexport type SessionEventType =\n  | 'skill_invoked'\n  | 'agent_spawned'\n  | 'hook_triggered'\n  | 'decision_made'\n  | 'preference_stated'\n  | 'problem_reported'\n  | 'solution_found'\n  | 'tool_used'\n  | 'session_start'\n  | 'session_end'\n  | 'communication_style_detected';\n\n/**\n * A single session event\n */\nexport interface SessionEvent {\n  /** Unique event ID */\n  event_id: string;\n  /** Event type */\n  event_type: SessionEventType;\n  /** Identity context (user, session, machine) */\n  identity: IdentityContext;\n  /** Event-specific payload */\n  payload: {\n    /** Name of skill/agent/hook/tool */\n    name: string;\n    /** Input data (optional, may be truncated for privacy) */\n    input?: Record<string, unknown>;\n    /** Output/result (optional, may be truncated) */\n    output?: Record<string, unknown>;\n    /** Duration in milliseconds */\n    duration_ms?: number;\n    /** Whether the event succeeded */\n    success: boolean;\n    /** Additional context */\n    context?: string;\n    /** Confidence score (for decisions) */\n    confidence?: number;\n  };\n}\n\n/**\n * Session summary (aggregated at session end)\n */\nexport interface SessionSummary {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  start_time?: string;\n  end_time?: string;\n  duration_ms?: number;\n  event_counts: Record<SessionEventType, number>;\n  skills_used: string[];\n  agents_spawned: string[];\n  hooks_triggered: string[];\n  decisions_made: number;\n  problems_reported: number;\n  solutions_found: number;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/** Session ID validation regex - alphanumeric, dashes, underscores only (SEC-002) */\nconst SESSION_ID_PATTERN = /^[a-zA-Z0-9_-]{1,128}$/;\n\n/**\n * Validate session ID to prevent path traversal attacks.\n * Defense-in-depth: trusted sources, but we validate at boundary anyway.\n */\nfunction isValidSessionId(sessionId: string): boolean {\n  return SESSION_ID_PATTERN.test(sessionId);\n}\n\n/**\n * Get session storage directory\n * @param sessionId - Optional session ID (defaults to env var)\n * @param projectDir - Optional project directory (defaults to env var)\n */\nfunction getSessionDir(sessionId?: string, projectDir?: string): string {\n  const sid = sessionId || getSessionId();\n  const pDir = projectDir || getProjectDir();\n  // Validate session ID to prevent path traversal (SEC-002)\n  if (!isValidSessionId(sid)) {\n    throw new Error(`Invalid session ID format`);\n  }\n  return `${pDir}/.claude/memory/sessions/${sid}`;\n}\n\n/**\n * Get events file path for a session\n */\nfunction getEventsPath(sessionId?: string, projectDir?: string): string {\n  return `${getSessionDir(sessionId, projectDir)}/events.jsonl`;\n}\n\n/**\n * Ensure session directory exists\n */\nfunction ensureSessionDir(sessionId?: string, projectDir?: string): void {\n  const dir = getSessionDir(sessionId, projectDir);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n// =============================================================================\n// EVENT GENERATION (Persistent Counter - Issue #245)\n// =============================================================================\n\n/** In-memory event counter */\nlet eventCounter = 0;\n\n/** Counter persistence state */\nlet counterLoaded = false;\nlet counterDirty = false;\nlet lastPersistTime = 0;\n\n/** Batch persist interval (ms) - write at most every 5 seconds */\nconst PERSIST_INTERVAL = 5000;\n\n/**\n * Get counter file path for current session\n */\nfunction getCounterPath(sessionId?: string, projectDir?: string): string {\n  const dir = getSessionDir(sessionId, projectDir);\n  return `${dir}/counter.json`;\n}\n\n/**\n * Load persisted counter value\n * Called once at first event generation\n */\nfunction loadPersistedCounter(sessionId?: string, projectDir?: string): void {\n  if (counterLoaded) return;\n  counterLoaded = true;\n\n  try {\n    const counterPath = getCounterPath(sessionId, projectDir);\n    if (existsSync(counterPath)) {\n      const data = JSON.parse(readFileSync(counterPath, 'utf8'));\n      if (typeof data.counter === 'number' && data.counter > 0) {\n        eventCounter = data.counter;\n        logHook('session-tracker', `Loaded event counter: ${eventCounter}`, 'debug');\n      }\n    }\n  } catch {\n    // Ignore load errors - start fresh\n  }\n}\n\n/**\n * Persist counter to disk (batched)\n * Only writes if counter changed and interval elapsed\n */\nfunction persistCounter(sessionId?: string, projectDir?: string): void {\n  if (!counterDirty) return;\n\n  const now = Date.now();\n  if (now - lastPersistTime < PERSIST_INTERVAL) return;\n\n  try {\n    ensureSessionDir(sessionId, projectDir);\n    const counterPath = getCounterPath(sessionId, projectDir);\n    writeFileSync(counterPath, JSON.stringify({\n      counter: eventCounter,\n      updated_at: new Date().toISOString(),\n    }));\n    counterDirty = false;\n    lastPersistTime = now;\n  } catch {\n    // Ignore persist errors - non-critical\n  }\n}\n\n/**\n * Generate unique event ID with persistent counter\n *\n * Format: evt-{timestamp}-{counter}\n * Counter persists across process restarts to prevent ID collisions.\n */\nfunction generateEventId(): string {\n  // Load persisted counter on first call\n  loadPersistedCounter();\n\n  eventCounter++;\n  counterDirty = true;\n\n  // Attempt batched persist\n  persistCounter();\n\n  return `evt-${Date.now()}-${eventCounter}`;\n}\n\n/**\n * Force persist counter (call at session end)\n * Exported for use by stop hooks\n */\nexport function flushEventCounter(): void {\n  if (counterDirty) {\n    try {\n      ensureSessionDir();\n      const counterPath = getCounterPath();\n      writeFileSync(counterPath, JSON.stringify({\n        counter: eventCounter,\n        updated_at: new Date().toISOString(),\n      }));\n      counterDirty = false;\n      logHook('session-tracker', `Flushed event counter: ${eventCounter}`, 'debug');\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Reset counter state (for testing only)\n */\nexport function resetEventCounter(): void {\n  eventCounter = 0;\n  counterLoaded = false;\n  counterDirty = false;\n  lastPersistTime = 0;\n}\n\n// =============================================================================\n// EVENT TRACKING\n// =============================================================================\n\n/**\n * Track a session event\n *\n * @param eventType - Type of event\n * @param name - Name of skill/agent/hook/tool\n * @param options - Additional event options\n */\nexport function trackEvent(\n  eventType: SessionEventType,\n  name: string,\n  options: {\n    input?: Record<string, unknown>;\n    output?: Record<string, unknown>;\n    duration_ms?: number;\n    success?: boolean;\n    context?: string;\n    confidence?: number;\n  } = {}\n): void {\n  try {\n    const event: SessionEvent = {\n      event_id: generateEventId(),\n      event_type: eventType,\n      identity: getIdentityContext(),\n      payload: {\n        name,\n        input: sanitizeForStorage(options.input),\n        output: sanitizeForStorage(options.output),\n        duration_ms: options.duration_ms,\n        success: options.success ?? true,\n        context: options.context ? truncate(options.context, 500) : undefined,\n        confidence: options.confidence,\n      },\n    };\n\n    ensureSessionDir();\n    const eventsPath = getEventsPath();\n    bufferWrite(eventsPath, `${JSON.stringify(event)}\\n`);\n\n    logHook('session-tracker', `Tracked ${eventType}: ${name}`, 'debug');\n  } catch (error) {\n    logHook('session-tracker', `Failed to track event: ${error}`, 'warn');\n  }\n}\n\n/**\n * Track skill invocation\n */\nexport function trackSkillInvoked(\n  skillName: string,\n  args?: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('skill_invoked', skillName, {\n    input: args ? { args } : undefined,\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track agent spawn\n */\nexport function trackAgentSpawned(\n  agentType: string,\n  prompt?: string,\n  success: boolean = true\n): void {\n  trackEvent('agent_spawned', agentType, {\n    input: prompt ? { prompt: truncate(prompt, 200) } : undefined,\n    success,\n  });\n}\n\n/**\n * Track hook triggered\n */\nexport function trackHookTriggered(\n  hookName: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('hook_triggered', hookName, {\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track decision made\n */\nexport function trackDecisionMade(\n  decision: string,\n  rationale?: string,\n  confidence?: number\n): void {\n  trackEvent('decision_made', 'decision', {\n    context: decision,\n    input: rationale ? { rationale } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track preference stated\n */\nexport function trackPreferenceStated(\n  preference: string,\n  confidence?: number\n): void {\n  trackEvent('preference_stated', 'preference', {\n    context: preference,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track problem reported\n */\nexport function trackProblemReported(problem: string): void {\n  trackEvent('problem_reported', 'problem', {\n    context: problem,\n    success: true,\n  });\n}\n\n/**\n * Track solution found\n */\nexport function trackSolutionFound(\n  solution: string,\n  problemId?: string,\n  confidence?: number\n): void {\n  trackEvent('solution_found', 'solution', {\n    context: solution,\n    input: problemId ? { problem_id: problemId } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track tool usage\n *\n * @param toolName - Name of the tool (e.g., 'Grep', 'Read')\n * @param success - Whether the tool call succeeded\n * @param durationMs - Duration of the tool call in milliseconds\n * @param category - Tool category (e.g., 'search', 'file_read') for preference tracking\n */\nexport function trackToolUsed(\n  toolName: string,\n  success: boolean = true,\n  durationMs?: number,\n  category?: string\n): void {\n  trackEvent('tool_used', toolName, {\n    success,\n    duration_ms: durationMs,\n    input: category ? { category } : undefined,\n  });\n}\n\n/**\n * Session context captured at session start\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport interface SessionContext {\n  /** Project directory path */\n  project_dir?: string;\n  /** Current git branch */\n  git_branch?: string;\n  /** Time of day category */\n  time_of_day?: 'morning' | 'afternoon' | 'evening' | 'night';\n  /** CC 2.1.47: Number of /add-dir directories active */\n  added_dirs_count?: number;\n  /** Timestamp */\n  started_at: string;\n}\n\n/**\n * Get time of day category from hour\n */\nfunction getTimeOfDay(hour: number): 'morning' | 'afternoon' | 'evening' | 'night' {\n  if (hour >= 5 && hour < 12) return 'morning';\n  if (hour >= 12 && hour < 17) return 'afternoon';\n  if (hour >= 17 && hour < 21) return 'evening';\n  return 'night';\n}\n\n/**\n * Track session start with context\n * Issue #245 Phase 5: Session Lifecycle Tracking\n *\n * @param context - Optional session context (project, branch, time)\n */\nexport function trackSessionStart(context?: Partial<SessionContext>): void {\n  const now = new Date();\n  const sessionContext: SessionContext = {\n    project_dir: context?.project_dir,\n    git_branch: context?.git_branch,\n    time_of_day: context?.time_of_day || getTimeOfDay(now.getHours()),\n    started_at: now.toISOString(),\n  };\n\n  trackEvent('session_start', 'session', {\n    success: true,\n    input: sessionContext as unknown as Record<string, unknown>,\n  });\n}\n\n/**\n * Track session end with timestamp\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport function trackSessionEnd(): void {\n  trackEvent('session_end', 'session', {\n    success: true,\n    input: { ended_at: new Date().toISOString() },\n  });\n}\n\n/**\n * Track user communication style\n */\nexport function trackCommunicationStyle(\n  style: {\n    verbosity: 'terse' | 'moderate' | 'detailed';\n    interaction_type: 'question' | 'command' | 'discussion';\n    technical_level: 'beginner' | 'intermediate' | 'expert';\n  }\n): void {\n  trackEvent('communication_style_detected', 'communication', {\n    input: style as unknown as Record<string, unknown>,\n    success: true,\n  });\n}\n\n\n// =============================================================================\n// SESSION SUMMARY\n// =============================================================================\n\n/**\n * Load all events for a session\n */\nexport function loadSessionEvents(sessionId?: string): SessionEvent[] {\n  const eventsPath = getEventsPath(sessionId);\n\n  if (!existsSync(eventsPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(eventsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    return lines.map(line => JSON.parse(line));\n  } catch (error) {\n    logHook('session-tracker', `Failed to load session events: ${error}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Generate session summary from events\n */\nexport function generateSessionSummary(sessionId?: string): SessionSummary {\n  const events = loadSessionEvents(sessionId);\n  const identity = getIdentityContext();\n\n  const eventCounts: Record<SessionEventType, number> = {\n    skill_invoked: 0,\n    agent_spawned: 0,\n    hook_triggered: 0,\n    decision_made: 0,\n    preference_stated: 0,\n    problem_reported: 0,\n    solution_found: 0,\n    tool_used: 0,\n    session_start: 0,\n    session_end: 0,\n    communication_style_detected: 0,\n  };\n\n  const skillsUsed = new Set<string>();\n  const agentsSpawned = new Set<string>();\n  const hooksTriggered = new Set<string>();\n\n  let startTime: string | undefined;\n  let endTime: string | undefined;\n\n  for (const event of events) {\n    eventCounts[event.event_type]++;\n\n    switch (event.event_type) {\n      case 'skill_invoked':\n        skillsUsed.add(event.payload.name);\n        break;\n      case 'agent_spawned':\n        agentsSpawned.add(event.payload.name);\n        break;\n      case 'hook_triggered':\n        hooksTriggered.add(event.payload.name);\n        break;\n      case 'session_start':\n        startTime = event.identity.timestamp;\n        break;\n      case 'session_end':\n        endTime = event.identity.timestamp;\n        break;\n    }\n  }\n\n  const durationMs =\n    startTime && endTime\n      ? new Date(endTime).getTime() - new Date(startTime).getTime()\n      : undefined;\n\n  return {\n    session_id: sessionId || identity.session_id,\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    start_time: startTime,\n    end_time: endTime,\n    duration_ms: durationMs,\n    event_counts: eventCounts,\n    skills_used: [...skillsUsed],\n    agents_spawned: [...agentsSpawned],\n    hooks_triggered: [...hooksTriggered],\n    decisions_made: eventCounts.decision_made,\n    problems_reported: eventCounts.problem_reported,\n    solutions_found: eventCounts.solution_found,\n  };\n}\n\n// =============================================================================\n// CROSS-SESSION QUERIES\n// =============================================================================\n// GAP-008/009 FIX: Removed listSessionIds() and getRecentUserSessions()\n// These functions were exported but never called by production code.\n// Cross-session queries should be handled by profile-injector if needed.\n// =============================================================================\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Truncate string to max length\n */\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return `${str.slice(0, maxLen - 3)}...`;\n}\n\n/**\n * Sanitize object for storage (remove sensitive data, truncate)\n */\nfunction sanitizeForStorage(\n  obj: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!obj) return undefined;\n\n  const sanitized: Record<string, unknown> = {};\n  const sensitiveKeys = ['password', 'secret', 'token', 'key', 'credential', 'auth'];\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip sensitive keys\n    if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {\n      sanitized[key] = '[REDACTED]';\n      continue;\n    }\n\n    // Truncate long strings\n    if (typeof value === 'string' && value.length > 500) {\n      sanitized[key] = truncate(value, 500);\n      continue;\n    }\n\n    // Recursively sanitize objects\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      sanitized[key] = sanitizeForStorage(value as Record<string, unknown>);\n      continue;\n    }\n\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n}\n", "/**\n * User Identity System\n * Resolves and manages user identity across sessions for multi-user decision capture.\n *\n * Identity Resolution Order:\n * 1. Explicit config (.claude/.user_identity.json)\n * 2. Git config (user.email, user.name)\n * 3. Environment variables (USER, USERNAME)\n * 4. Anonymous (machine-based hash)\n *\n * Privacy: User controls what gets shared via privacy settings.\n * Storage: User profiles stored locally in .claude/memory/users/\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { basename } from 'node:path';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport * as os from 'node:os';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * User identity source - where the identity was resolved from\n */\nexport type IdentitySource = 'config' | 'git' | 'env' | 'anonymous';\n\n/**\n * Resolved user identity\n */\nexport interface UserIdentity {\n  /** Unique user identifier (email, username, or anonymous hash) */\n  user_id: string;\n  /** Human-readable display name */\n  display_name: string;\n  /** Optional team/org identifier */\n  team_id?: string;\n  /** Machine identifier (hostname) */\n  machine_id: string;\n  /** How the identity was resolved */\n  source: IdentitySource;\n  /** Anonymous hash for global sharing (privacy-preserving) */\n  anonymous_id: string;\n  /** Email if available */\n  email?: string;\n}\n\n/**\n * User privacy settings - controls what gets shared\n */\nexport interface PrivacySettings {\n  /** Share patterns with team (same project) */\n  share_with_team: boolean;\n  /** Share patterns globally (anonymized) */\n  share_globally: boolean;\n  /** Share decisions */\n  share_decisions: boolean;\n  /** Share preferences */\n  share_preferences: boolean;\n  /** Share skill usage statistics */\n  share_skill_usage: boolean;\n  /** Share prompt content (usually false for privacy) */\n  share_prompts: boolean;\n  /** Anonymize user_id when sharing globally */\n  anonymize_globally: boolean;\n}\n\n/**\n * User identity configuration file format\n */\nexport interface UserIdentityConfig {\n  /** Explicit user ID */\n  user_id?: string;\n  /** Display name */\n  display_name?: string;\n  /** Team identifier */\n  team_id?: string;\n  /** Privacy settings */\n  privacy?: Partial<PrivacySettings>;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst IDENTITY_CONFIG_FILE = '.claude/.user_identity.json';\nconst SALT = 'orchestkit-user-identity-v1';\n\n/** Default privacy settings (conservative) */\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  share_with_team: true,\n  share_globally: false, // Opt-in\n  share_decisions: true,\n  share_preferences: true,\n  share_skill_usage: false, // Might reveal workflow\n  share_prompts: false, // Privacy sensitive\n  anonymize_globally: true,\n};\n\n// =============================================================================\n// CACHING\n// =============================================================================\n\nlet cachedIdentity: UserIdentity | null = null;\nlet cachedPrivacy: PrivacySettings | null = null;\n\n/**\n * Clear cached identity (for testing)\n */\nexport function clearIdentityCache(): void {\n  cachedIdentity = null;\n  cachedPrivacy = null;\n}\n\n// =============================================================================\n// IDENTITY RESOLUTION\n// =============================================================================\n\n/**\n * Generate anonymous hash from input\n */\nfunction generateAnonymousId(input: string): string {\n  // Use 32 hex chars (128 bits) for proper collision resistance\n  return createHash('sha256')\n    .update(input + SALT)\n    .digest('hex')\n    .slice(0, 32);\n}\n\n/**\n * Get machine identifier\n */\nfunction getMachineId(): string {\n  try {\n    return os.hostname();\n  } catch {\n    return 'unknown-machine';\n  }\n}\n\n/**\n * Try to read explicit user config\n */\nfunction readUserConfig(projectDir: string): UserIdentityConfig | null {\n  const configPath = `${projectDir}/${IDENTITY_CONFIG_FILE}`;\n\n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    logHook('user-identity', `Failed to read user config: ${error}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Try to get identity from git config\n */\nfunction getGitIdentity(projectDir: string): { email?: string; name?: string } {\n  const result: { email?: string; name?: string } = {};\n\n  try {\n    result.email = execSync('git config user.email', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git email not configured\n  }\n\n  try {\n    result.name = execSync('git config user.name', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git name not configured\n  }\n\n  return result;\n}\n\n/**\n * Get identity from environment variables\n */\nfunction getEnvIdentity(): { username?: string } {\n  const username = process.env.USER || process.env.USERNAME || process.env.LOGNAME;\n  return { username };\n}\n\n/**\n * Resolve user identity using fallback chain\n *\n * Resolution order:\n * 1. Explicit config file\n * 2. Git config\n * 3. Environment username\n * 4. Anonymous (machine-based)\n */\nexport function resolveUserIdentity(projectDir?: string): UserIdentity {\n  // Return cached if available\n  if (cachedIdentity) {\n    return cachedIdentity;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const machineId = getMachineId();\n\n  // 1. Try explicit config\n  const config = readUserConfig(dir);\n  if (config?.user_id) {\n    cachedIdentity = {\n      user_id: config.user_id,\n      display_name: config.display_name || config.user_id,\n      team_id: config.team_id,\n      machine_id: machineId,\n      source: 'config',\n      anonymous_id: generateAnonymousId(config.user_id),\n      email: config.user_id.includes('@') ? config.user_id : undefined,\n    };\n    logHook('user-identity', `Resolved from config: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 2. Try git config\n  const git = getGitIdentity(dir);\n  if (git.email) {\n    cachedIdentity = {\n      user_id: git.email,\n      display_name: git.name || git.email.split('@')[0],\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'git',\n      anonymous_id: generateAnonymousId(git.email),\n      email: git.email,\n    };\n    logHook('user-identity', `Resolved from git: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 3. Try environment\n  const env = getEnvIdentity();\n  if (env.username) {\n    const userId = `${env.username}@${machineId}`;\n    cachedIdentity = {\n      user_id: userId,\n      display_name: env.username,\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'env',\n      anonymous_id: generateAnonymousId(userId),\n    };\n    logHook('user-identity', `Resolved from env: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 4. Anonymous fallback\n  const anonId = generateAnonymousId(machineId + process.pid);\n  cachedIdentity = {\n    user_id: `anon-${anonId.slice(0, 8)}`,\n    display_name: 'Anonymous',\n    team_id: config?.team_id,\n    machine_id: machineId,\n    source: 'anonymous',\n    anonymous_id: anonId,\n  };\n  logHook('user-identity', `Resolved as anonymous: ${cachedIdentity.anonymous_id}`, 'debug');\n  return cachedIdentity;\n}\n\n// =============================================================================\n// PRIVACY SETTINGS\n// =============================================================================\n\n/**\n * Get user's privacy settings\n */\nexport function getPrivacySettings(projectDir?: string): PrivacySettings {\n  if (cachedPrivacy) {\n    return cachedPrivacy;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const config = readUserConfig(dir);\n\n  cachedPrivacy = {\n    ...DEFAULT_PRIVACY,\n    ...config?.privacy,\n  };\n\n  return cachedPrivacy;\n}\n\n/**\n * Check if user allows sharing a specific type of data\n */\nexport function canShare(\n  dataType: 'decisions' | 'preferences' | 'skill_usage' | 'prompts',\n  scope: 'team' | 'global'\n): boolean {\n  const privacy = getPrivacySettings();\n\n  // Check scope permission first\n  if (scope === 'team' && !privacy.share_with_team) return false;\n  if (scope === 'global' && !privacy.share_globally) return false;\n\n  // Check data type permission\n  switch (dataType) {\n    case 'decisions':\n      return privacy.share_decisions;\n    case 'preferences':\n      return privacy.share_preferences;\n    case 'skill_usage':\n      return privacy.share_skill_usage;\n    case 'prompts':\n      return privacy.share_prompts;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get user ID for sharing (applies anonymization if needed)\n */\nexport function getUserIdForScope(scope: 'local' | 'team' | 'global'): string {\n  const identity = resolveUserIdentity();\n  const privacy = getPrivacySettings();\n\n  if (scope === 'global' && privacy.anonymize_globally) {\n    return identity.anonymous_id;\n  }\n\n  return identity.user_id;\n}\n\n// =============================================================================\n// IDENTITY PERSISTENCE\n// =============================================================================\n\n/**\n * Save user identity config (creates or updates)\n */\nexport function saveUserIdentityConfig(\n  config: UserIdentityConfig,\n  projectDir?: string\n): boolean {\n  const dir = projectDir || getProjectDir();\n  const configPath = `${dir}/${IDENTITY_CONFIG_FILE}`;\n  const configDir = `${dir}/.claude`;\n\n  try {\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n    // Clear cache to pick up new config\n    clearIdentityCache();\n\n    logHook('user-identity', `Saved identity config to ${configPath}`, 'info');\n    return true;\n  } catch (error) {\n    logHook('user-identity', `Failed to save identity config: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// CONTEXT HELPERS\n// =============================================================================\n\n/**\n * Get full identity context for session events\n */\nexport interface IdentityContext {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  machine_id: string;\n  identity_source: IdentitySource;\n  timestamp: string;\n}\n\n/**\n * Get identity context for tagging events\n */\nexport function getIdentityContext(): IdentityContext {\n  const identity = resolveUserIdentity();\n\n  return {\n    session_id: getSessionId(),\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    machine_id: identity.machine_id,\n    identity_source: identity.source,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Get project-scoped user ID for memory storage\n * Format: {project}-{scope} (e.g., \"my-app-decisions\")\n */\nexport function getProjectUserId(scope: string): string {\n  const projectDir = getProjectDir();\n  // Use path.basename for cross-platform compatibility (Windows uses \\ not /)\n  const projectName = basename(projectDir) || 'unknown';\n  const sanitized = projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  return `${sanitized}-${scope}`;\n}\n\n/**\n * Get user-scoped ID for memory storage\n * Format: {user_id}-{scope} (e.g., \"alice@company.com-preferences\")\n */\nexport function getUserScopedId(scope: string): string {\n  const identity = resolveUserIdentity();\n  const sanitizedUserId = identity.user_id.toLowerCase().replace(/[^a-z0-9@.-]/g, '-');\n  return `${sanitizedUserId}-${scope}`;\n}\n\n/**\n * Get global scope ID (for cross-project best practices)\n */\nexport function getGlobalScopeId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n", "/**\n * Tool Categories\n * Issue #245 Phase 4: Tool Usage Tracking\n *\n * Maps Claude Code tools to semantic categories for:\n * - Usage pattern analysis\n * - Tool preference learning\n * - Workflow detection\n *\n * Categories align with user workflow intentions, not implementation details.\n */\n\n/**\n * Tool category types\n */\nexport type ToolCategory =\n  | 'search'        // Finding files/content: Grep, Glob, WebSearch\n  | 'file_read'     // Reading files: Read\n  | 'file_write'    // Creating files: Write\n  | 'file_edit'     // Modifying files: Edit, MultiEdit, NotebookEdit\n  | 'execution'     // Running commands: Bash\n  | 'agent'         // Spawning agents: Task\n  | 'skill'         // Invoking skills: Skill\n  | 'web'           // Web access: WebFetch, WebSearch\n  | 'interaction'   // User interaction: AskUserQuestion\n  | 'task_mgmt'     // Task management: TaskCreate, TaskUpdate, TaskList, TaskGet\n  | 'other';        // Unknown/uncategorized\n\n/**\n * Static tool \u2192 category mapping\n *\n * This mapping covers all known Claude Code tools as of CC 2.1.22.\n * Unknown tools default to 'other'.\n */\nexport const TOOL_CATEGORIES: Record<string, ToolCategory> = {\n  // Search tools - finding files and content\n  Grep: 'search',\n  Glob: 'search',\n  WebSearch: 'web',\n\n  // File reading\n  Read: 'file_read',\n\n  // File writing (creation)\n  Write: 'file_write',\n\n  // File editing (modification)\n  Edit: 'file_edit',\n  MultiEdit: 'file_edit',\n  NotebookEdit: 'file_edit',\n\n  // Execution\n  Bash: 'execution',\n\n  // Agent/skill invocation\n  Task: 'agent',\n  Skill: 'skill',\n\n  // Web access\n  WebFetch: 'web',\n\n  // User interaction\n  AskUserQuestion: 'interaction',\n\n  // Task management (CC 2.1.16)\n  TaskCreate: 'task_mgmt',\n  TaskUpdate: 'task_mgmt',\n  TaskList: 'task_mgmt',\n  TaskGet: 'task_mgmt',\n  TaskOutput: 'task_mgmt',\n  TaskStop: 'task_mgmt',\n\n  // Planning\n  EnterPlanMode: 'interaction',\n  ExitPlanMode: 'interaction',\n};\n\n/**\n * Get the category for a tool\n *\n * @param toolName - The name of the tool (e.g., 'Grep', 'Read')\n * @returns The tool's category, or 'other' if unknown\n *\n * @example\n * getToolCategory('Grep')  // 'search'\n * getToolCategory('Read')  // 'file_read'\n * getToolCategory('CustomTool')  // 'other'\n */\nexport function getToolCategory(toolName: string): ToolCategory {\n  return TOOL_CATEGORIES[toolName] || 'other';\n}\n\n/**\n * Get all tools in a category\n *\n * @param category - The category to look up\n * @returns Array of tool names in that category\n *\n * @example\n * getToolsInCategory('search')  // ['Grep', 'Glob']\n */\nexport function getToolsInCategory(category: ToolCategory): string[] {\n  return Object.entries(TOOL_CATEGORIES)\n    .filter(([, cat]) => cat === category)\n    .map(([tool]) => tool);\n}\n\n/**\n * Check if two tools are in the same category\n *\n * @param tool1 - First tool name\n * @param tool2 - Second tool name\n * @returns true if both tools are in the same category\n *\n * @example\n * areSameCategory('Grep', 'Glob')  // true (both 'search')\n * areSameCategory('Read', 'Write') // false\n */\nexport function areSameCategory(tool1: string, tool2: string): boolean {\n  return getToolCategory(tool1) === getToolCategory(tool2);\n}\n\n/**\n * Get a human-readable description of a category\n *\n * @param category - The category\n * @returns Description of what tools in this category do\n */\nexport function getCategoryDescription(category: ToolCategory): string {\n  const descriptions: Record<ToolCategory, string> = {\n    search: 'Finding files and content',\n    file_read: 'Reading file contents',\n    file_write: 'Creating new files',\n    file_edit: 'Modifying existing files',\n    execution: 'Running shell commands',\n    agent: 'Spawning specialized agents',\n    skill: 'Invoking skills',\n    web: 'Accessing web resources',\n    interaction: 'User interaction',\n    task_mgmt: 'Managing tasks',\n    other: 'Other operations',\n  };\n  return descriptions[category];\n}\n", "/**\n * Task Completion Check - Verifies tasks are properly completed before stop\n * Hook: Stop\n * CC 2.1.20: Orphan detection and deletion support\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, getProjectDir, getSessionId, outputSilentSuccess, outputWithContext } from '../lib/common.js';\nimport { getOrphanedTasks, formatTaskDeleteForClaude } from '../lib/task-integration.js';\nimport { getActiveTodosFile } from '../lib/paths.js';\n\ninterface TodoItem {\n  status: string;\n  description?: string;\n}\n\n/**\n * Task completion check hook\n */\nexport function taskCompletionCheck(input: HookInput): HookResult {\n  logHook('task-completion-check', 'Stop hook - checking task completion');\n\n  const warnings: string[] = [];\n\n  // CC 2.1.20: Check orchestration registry for in_progress tasks\n  const projectDir = input.project_dir || getProjectDir();\n  const sessionId = input.session_id || getSessionId();\n  const registryFile = `${projectDir}/.claude/orchestration/task-registry-${sessionId}.json`;\n\n  if (existsSync(registryFile)) {\n    try {\n      const registry = JSON.parse(readFileSync(registryFile, 'utf-8'));\n      const inProgress = (registry.tasks || []).filter(\n        (t: { status: string }) => t.status === 'in_progress'\n      );\n      if (inProgress.length > 0) {\n        logHook('task-completion-check', `WARNING: ${inProgress.length} orchestration tasks still in progress`);\n        warnings.push(`${inProgress.length} orchestration task(s) still in progress at session stop`);\n      }\n    } catch (error) {\n      logHook('task-completion-check', `Error reading registry: ${error}`);\n    }\n  }\n\n  // CC 2.1.20: Check for orphaned tasks and generate deletion instructions\n  const orphans = getOrphanedTasks();\n  let orphanInstructions = '';\n  if (orphans.length > 0) {\n    logHook('task-completion-check', `Found ${orphans.length} orphaned tasks`);\n    orphanInstructions = '\\n\\n## Orphaned Tasks\\n\\nThe following tasks are orphaned (all blockers failed) and should be deleted:\\n';\n    for (const orphan of orphans) {\n      orphanInstructions += `\\n${formatTaskDeleteForClaude(orphan.taskId, 'All blocking tasks have failed')}`;\n    }\n  }\n\n  // Legacy fallback: check platform-appropriate temp dir\n  const todosFile = getActiveTodosFile();\n  if (existsSync(todosFile)) {\n    try {\n      const todos: TodoItem[] = JSON.parse(readFileSync(todosFile, 'utf-8'));\n      const inProgress = todos.filter((t) => t.status === 'in_progress');\n      if (inProgress.length > 0) {\n        logHook('task-completion-check', `WARNING: ${inProgress.length} legacy tasks in progress at stop`);\n        warnings.push(`${inProgress.length} legacy task(s) still in progress`);\n      }\n    } catch (error) {\n      logHook('task-completion-check', `Error reading legacy todos: ${error}`);\n    }\n  }\n\n  if (warnings.length > 0 || orphanInstructions) {\n    let context = `## Task Completion Warning\\n\\n${warnings.map(w => `- ${w}`).join('\\n')}`;\n    if (orphanInstructions) {\n      context += orphanInstructions;\n    }\n    return outputWithContext(context);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n  blockedBy?: string[];\n  blocks?: string[];\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Get action-specific activeForm based on agent type\n */\nfunction getActiveFormForAgent(agent: string, description: string): string {\n  const actionMap: Record<string, string> = {\n    'backend-system-architect': 'Designing',\n    'frontend-ui-developer': 'Building',\n    'test-generator': 'Writing tests for',\n    'security-auditor': 'Auditing',\n    'workflow-architect': 'Architecting',\n    'database-engineer': 'Implementing database for',\n    'llm-integrator': 'Integrating LLM for',\n    'code-quality-reviewer': 'Reviewing',\n    'ux-researcher': 'Researching UX for',\n    'product-strategist': 'Strategizing',\n    'debug-investigator': 'Investigating',\n    'frontend-performance-engineer': 'Optimizing',\n    'accessibility-specialist': 'Auditing accessibility for',\n    'infrastructure-architect': 'Designing infrastructure for',\n    'data-pipeline-engineer': 'Building pipeline for',\n  };\n\n  const action = actionMap[agent] || 'Working on';\n  const shortDesc = description.slice(0, 40).toLowerCase();\n  return `${action} ${shortDesc}`;\n}\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: getActiveFormForAgent(agent, description),\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'deleted',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Generate TaskUpdate instruction for task deletion (CC 2.1.20)\n */\nexport function generateTaskDeleteInstruction(\n  taskId: string,\n  _reason: string\n): TaskUpdateInstruction {\n  return {\n    taskId,\n    status: 'deleted',\n  };\n}\n\n/**\n * Format TaskDelete instruction as markdown for Claude (CC 2.1.20)\n */\nexport function formatTaskDeleteForClaude(taskId: string, reason: string): string {\n  return `### Delete Orphaned Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${taskId}\"\n  status: \"deleted\"\n\\`\\`\\`\n\n**Reason**: ${reason}`;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number,\n  blockedBy?: string[],\n  blocks?: string[]\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n    blockedBy,\n    blocks,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get pending tasks blocked by a specific failed task (CC 2.1.20)\n */\nexport function getTasksBlockedBy(failedTaskId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks.filter(\n    t =>\n      t.status === 'pending' &&\n      t.blockedBy &&\n      t.blockedBy.includes(failedTaskId)\n  );\n}\n\n/**\n * Get orphaned tasks - pending tasks where all blockers have failed (CC 2.1.20)\n */\nexport function getOrphanedTasks(): TaskEntry[] {\n  const registry = loadRegistry();\n  const failedIds = new Set(\n    registry.tasks.filter(t => t.status === 'failed').map(t => t.taskId)\n  );\n\n  if (failedIds.size === 0) return [];\n\n  return registry.tasks.filter(t => {\n    if (t.status !== 'pending' || !t.blockedBy || t.blockedBy.length === 0) {\n      return false;\n    }\n    // Orphaned if ALL blockers are failed\n    return t.blockedBy.every(id => failedIds.has(id));\n  });\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 1200,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Calibration Persist - Stop Hook for Persisting Calibration Data\n * Issue #197: Agent Orchestration Layer\n *\n * End-of-session calibration operations:\n * - Applies decay to old adjustments\n * - Cleans up expired records\n * - Saves final calibration state\n *\n * CC 2.1.7 Compliant: Silent hook that persists in background\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport {\n  loadCalibrationData,\n  saveCalibrationData,\n  applyDecay,\n} from '../lib/calibration-engine.js';\nimport { loadConfig, clearSessionState, cleanupOldStates } from '../lib/orchestration-state.js';\nimport { cleanupOldTasks } from '../lib/task-integration.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum age for calibration records (30 days) */\nconst MAX_RECORD_AGE_MS = 30 * 24 * 60 * 60 * 1000;\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up old calibration records\n */\nfunction cleanupOldRecords(data: ReturnType<typeof loadCalibrationData>): void {\n  const cutoff = Date.now() - MAX_RECORD_AGE_MS;\n\n  const before = data.records.length;\n  data.records = data.records.filter(r => {\n    const recordTime = new Date(r.timestamp).getTime();\n    return recordTime > cutoff;\n  });\n  const after = data.records.length;\n\n  if (before !== after) {\n    logHook('calibration-persist', `Cleaned up ${before - after} old records`);\n  }\n}\n\n/**\n * Generate calibration summary for logging\n */\nfunction generateSummary(data: ReturnType<typeof loadCalibrationData>): string {\n  const stats = data.stats;\n  const topAgents = stats.topAgents\n    .slice(0, 3)\n    .map(a => `${a.agent}(${Math.round(a.successRate * 100)}%)`)\n    .join(', ');\n\n  return `Calibration summary: ${stats.totalDispatches} dispatches, ` +\n    `${Math.round(stats.successRate * 100)}% success rate, ` +\n    `${data.adjustments.length} adjustments active. ` +\n    `Top agents: ${topAgents || 'none'}`;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Calibration persist hook\n *\n * Runs at session end to:\n * 1. Apply decay to old adjustments\n * 2. Clean up expired records\n * 3. Save final calibration state\n * 4. Clean up session-specific state\n */\nexport function calibrationPersist(_input: HookInput): HookResult {\n  // Check if calibration is enabled\n  const config = loadConfig();\n  if (!config.enableCalibration) {\n    // Still do cleanup even if calibration disabled\n    clearSessionState();\n    cleanupOldStates();\n    return outputSilentSuccess();\n  }\n\n  logHook('calibration-persist', 'Running end-of-session calibration persistence...');\n\n  try {\n    // Load current calibration data\n    const data = loadCalibrationData();\n\n    // Apply decay to old adjustments\n    applyDecay(data);\n\n    // Clean up old records\n    cleanupOldRecords(data);\n\n    // Save updated calibration data\n    saveCalibrationData(data);\n\n    // Log summary\n    const summary = generateSummary(data);\n    logHook('calibration-persist', summary);\n\n  } catch (err) {\n    logHook('calibration-persist', `Error during calibration persist: ${err}`);\n  }\n\n  // Clean up session state\n  try {\n    clearSessionState();\n    cleanupOldStates();\n    cleanupOldTasks();\n    logHook('calibration-persist', 'Cleaned up session state');\n  } catch (err) {\n    logHook('calibration-persist', `Error during state cleanup: ${err}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * User Profile Management\n * Aggregates session data into user profiles for learning patterns across sessions.\n *\n * Profiles track:\n * - Skill usage patterns\n * - Agent preferences\n * - Decision history\n * - Workflow patterns\n * - Tool preferences\n *\n * Storage: ~/.claude/orchestkit/users/{user_id}/profile.json (cross-project)\n *\n * Migration: Profiles are migrated from old project-local path on first access\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\nimport { getProjectDir, logHook } from './common.js';\nimport { getHomeDir as getHomeDirFromPaths } from './paths.js';\nimport { resolveUserIdentity } from './user-identity.js';\nimport { generateSessionSummary, type SessionSummary } from './session-tracker.js';\nimport { analyzeDecisionFlow, type WorkflowPattern as FlowWorkflowPattern } from './decision-flow-tracker.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Usage statistics for a skill/agent/tool\n */\nexport interface UsageStats {\n  /** Total times used */\n  count: number;\n  /** Success rate (0-1) */\n  success_rate: number;\n  /** Average duration in ms */\n  avg_duration_ms?: number;\n  /** First used timestamp */\n  first_used: string;\n  /** Last used timestamp */\n  last_used: string;\n}\n\n/**\n * Recorded decision\n */\nexport interface RecordedDecision {\n  /** What was decided */\n  what: string;\n  /** Alternatives considered */\n  alternatives?: string[];\n  /** Rationale provided */\n  rationale?: string;\n  /** Confidence score */\n  confidence: number;\n  /** When decided */\n  timestamp: string;\n  /** Project where decision was made */\n  project?: string;\n}\n\n/**\n * Recorded preference\n */\nexport interface RecordedPreference {\n  /** Category (e.g., \"file_search\", \"testing\", \"language\") */\n  category: string;\n  /** What is preferred */\n  preference: string;\n  /** Confidence score */\n  confidence: number;\n  /** When recorded */\n  timestamp: string;\n  /** How many times this preference was observed */\n  observation_count: number;\n}\n\n/**\n * Detected workflow pattern\n */\nexport interface WorkflowPattern {\n  /** Pattern name */\n  name: string;\n  /** Pattern description */\n  description: string;\n  /** How often this pattern is observed (0-1) */\n  frequency: number;\n  /** Tool sequences that indicate this pattern */\n  tool_sequences: string[][];\n}\n\n/**\n * Descriptions for workflow pattern names\n */\nconst WORKFLOW_PATTERN_DESCRIPTIONS: Record<FlowWorkflowPattern, string> = {\n  'test-first': 'Writes tests before implementation (TDD)',\n  'explore-first': 'Reads existing code before making changes',\n  'iterate-fast': 'Makes quick write \u2192 test iterations',\n  'big-bang': 'Writes multiple files then tests',\n  'agent-delegate': 'Delegates tasks to specialized agents',\n  'mixed': 'Varies approach by task',\n};\n\n/**\n * Convert decision-flow-tracker pattern to user-profile WorkflowPattern\n */\nfunction convertFlowPattern(flowPattern: FlowWorkflowPattern, existingPatterns: WorkflowPattern[]): WorkflowPattern {\n  const existing = existingPatterns.find(p => p.name === flowPattern);\n  const frequency = existing ? Math.min(1, existing.frequency + 0.1) : 0.1;\n\n  return {\n    name: flowPattern,\n    description: WORKFLOW_PATTERN_DESCRIPTIONS[flowPattern],\n    frequency,\n    tool_sequences: [], // Populated by detailed analysis if needed\n  };\n}\n\n/**\n * Complete user profile\n */\nexport interface UserProfile {\n  /** User identifier */\n  user_id: string;\n  /** Anonymous identifier for global sharing */\n  anonymous_id: string;\n  /** Display name */\n  display_name: string;\n  /** Team/org if known */\n  team_id?: string;\n  /** Total sessions analyzed */\n  sessions_count: number;\n  /** First seen timestamp */\n  first_seen: string;\n  /** Last seen timestamp */\n  last_seen: string;\n  /** Profile version for migrations */\n  version: number;\n\n  /** Skill usage statistics */\n  skill_usage: Record<string, UsageStats>;\n  /** Agent usage statistics */\n  agent_usage: Record<string, UsageStats>;\n  /** Tool usage statistics */\n  tool_usage: Record<string, UsageStats>;\n\n  /** Tool preferences by category (Phase 4: Tool Usage Tracking)\n   * Maps category \u2192 preferred tool name based on usage frequency\n   * e.g., { search: 'Grep', file_read: 'Read' }\n   */\n  tool_preferences?: Record<string, string>;\n\n  /** Tool usage by category (Phase 4: Tool Usage Tracking)\n   * Maps category \u2192 { tool \u2192 count }\n   * e.g., { search: { Grep: 10, Glob: 3 } }\n   */\n  tool_usage_by_category?: Record<string, Record<string, number>>;\n\n  /** Recorded decisions */\n  decisions: RecordedDecision[];\n  /** Recorded preferences */\n  preferences: RecordedPreference[];\n\n  /** Detected workflow patterns */\n  workflow_patterns: WorkflowPattern[];\n\n  /** Session IDs that have been aggregated */\n  aggregated_sessions: string[];\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/**\n * Current profile schema version.\n * Increment this when making breaking changes to UserProfile structure.\n *\n * Version History:\n * - v1 (Initial): Base profile structure\n * - v2 (Issue #245): Added tool_preferences, tool_usage_by_category\n */\nconst PROFILE_VERSION = 2;\nconst MAX_DECISIONS = 100;\nconst MAX_PREFERENCES = 50;\n\n// =============================================================================\n// SCHEMA MIGRATIONS (Issue #245 Phase 4)\n// =============================================================================\n\n/**\n * Migration function type\n */\ntype MigrationFn = (profile: Record<string, unknown>) => Record<string, unknown>;\n\n/**\n * Registry of migrations: version -> migration function\n * Each migration upgrades from version N to N+1\n */\nconst MIGRATIONS: Record<number, MigrationFn> = {\n  // v1 -> v2: Add tool_preferences and tool_usage_by_category\n  1: (profile) => {\n    return {\n      ...profile,\n      version: 2,\n      tool_preferences: profile.tool_preferences || {},\n      tool_usage_by_category: profile.tool_usage_by_category || {},\n    };\n  },\n  // Add future migrations here:\n  // 2: (profile) => { ... version: 3 ... }\n};\n\n/**\n * Apply all necessary migrations to bring profile to current version\n */\nfunction migrateProfileSchema(profile: Record<string, unknown>): UserProfile {\n  let currentVersion = (profile.version as number) || 1;\n\n  // Apply migrations sequentially\n  while (currentVersion < PROFILE_VERSION) {\n    const migrationFn = MIGRATIONS[currentVersion];\n    if (!migrationFn) {\n      logHook('user-profile', `Missing migration for version ${currentVersion}`, 'warn');\n      break;\n    }\n\n    profile = migrationFn(profile);\n    currentVersion = profile.version as number;\n    logHook('user-profile', `Migrated profile to version ${currentVersion}`, 'info');\n  }\n\n  return profile as unknown as UserProfile;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/**\n * Get the home directory for cross-project storage (cross-platform)\n * Delegates to paths.ts which uses os.homedir() for proper cross-platform support\n */\nfunction getHomeDir(): string {\n  return getHomeDirFromPaths();\n}\n\n/**\n * Get the cross-project OrchestKit directory\n */\nfunction getOrchestKitDir(): string {\n  return join(getHomeDir(), '.claude', 'orchestkit');\n}\n\n/**\n * Get user profile directory (cross-project, in home directory)\n */\nfunction getUserProfileDir(userId: string): string {\n  const sanitizedUserId = userId.replace(/[^a-zA-Z0-9@._-]/g, '_');\n  return join(getOrchestKitDir(), 'users', sanitizedUserId);\n}\n\n/**\n * Get user profile file path\n */\nfunction getUserProfilePath(userId: string): string {\n  return join(getUserProfileDir(userId), 'profile.json');\n}\n\n/**\n * Get the OLD project-local profile path (for migration)\n */\nfunction getLegacyProfilePath(userId: string): string {\n  const sanitizedUserId = userId.replace(/[^a-zA-Z0-9@._-]/g, '_');\n  return join(getProjectDir(), '.claude', 'memory', 'users', sanitizedUserId, 'profile.json');\n}\n\n/**\n * Migrate profile from old project-local path to new cross-project path\n * Returns true if migration occurred\n */\nfunction migrateProfileIfNeeded(userId: string): boolean {\n  const legacyPath = getLegacyProfilePath(userId);\n  const newPath = getUserProfilePath(userId);\n\n  // If new path exists, no migration needed\n  if (existsSync(newPath)) {\n    return false;\n  }\n\n  // If legacy path exists, migrate it\n  if (existsSync(legacyPath)) {\n    try {\n      const newDir = dirname(newPath);\n      if (!existsSync(newDir)) {\n        mkdirSync(newDir, { recursive: true });\n      }\n\n      // Read legacy profile\n      const content = readFileSync(legacyPath, 'utf8');\n      const profile = JSON.parse(content);\n\n      // Write to new location\n      writeFileSync(newPath, JSON.stringify(profile, null, 2));\n\n      // Log with sanitized user ID to avoid PII in logs\n      const sanitizedId = userId.replace(/@.*$/, '@***');\n      logHook('user-profile', `Migrated profile for ${sanitizedId} to cross-project storage`, 'info');\n      return true;\n    } catch (error) {\n      logHook('user-profile', `Failed to migrate profile: ${error}`, 'warn');\n      return false;\n    }\n  }\n\n  return false;\n}\n\n// =============================================================================\n// PROFILE LOADING/SAVING\n// =============================================================================\n\n/**\n * Create empty profile for a user\n */\nfunction createEmptyProfile(userId: string): UserProfile {\n  const identity = resolveUserIdentity();\n  const now = new Date().toISOString();\n\n  return {\n    user_id: userId,\n    anonymous_id: identity.anonymous_id,\n    display_name: identity.display_name,\n    team_id: identity.team_id,\n    sessions_count: 0,\n    first_seen: now,\n    last_seen: now,\n    version: PROFILE_VERSION,\n    skill_usage: {},\n    agent_usage: {},\n    tool_usage: {},\n    decisions: [],\n    preferences: [],\n    workflow_patterns: [],\n    aggregated_sessions: [],\n  };\n}\n\n/**\n * Load user profile from disk\n * Automatically applies schema migrations if profile is outdated (Issue #245 Phase 4)\n */\nexport function loadUserProfile(userId?: string): UserProfile {\n  // Attempt migration from legacy project-local path\n  const uid = userId || resolveUserIdentity().user_id;\n  migrateProfileIfNeeded(uid);\n\n  const profilePath = getUserProfilePath(uid);\n\n  if (!existsSync(profilePath)) {\n    return createEmptyProfile(uid);\n  }\n\n  try {\n    const content = readFileSync(profilePath, 'utf8');\n    const rawProfile = JSON.parse(content) as Record<string, unknown>;\n\n    // Apply schema migrations if needed (Issue #245 Phase 4)\n    const profile = migrateProfileSchema(rawProfile);\n\n    // Auto-save if migration occurred\n    if ((rawProfile.version as number || 1) < PROFILE_VERSION) {\n      saveUserProfile(profile);\n      logHook('user-profile', `Auto-saved migrated profile (v${PROFILE_VERSION})`, 'info');\n    }\n\n    return profile;\n  } catch (error) {\n    logHook('user-profile', `Failed to load profile: ${error}`, 'warn');\n    return createEmptyProfile(uid);\n  }\n}\n\n/**\n * Save user profile to disk\n */\nexport function saveUserProfile(profile: UserProfile): boolean {\n  const profileDir = getUserProfileDir(profile.user_id);\n  const profilePath = getUserProfilePath(profile.user_id);\n\n  try {\n    if (!existsSync(profileDir)) {\n      mkdirSync(profileDir, { recursive: true });\n    }\n\n    profile.last_seen = new Date().toISOString();\n    writeFileSync(profilePath, JSON.stringify(profile, null, 2));\n\n    // Log with anonymous_id to avoid PII in logs\n    logHook('user-profile', `Saved profile for ${profile.anonymous_id}`, 'debug');\n    return true;\n  } catch (error) {\n    logHook('user-profile', `Failed to save profile: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// PROFILE AGGREGATION\n// =============================================================================\n\n/**\n * Update usage stats with new data\n */\nfunction updateUsageStats(\n  existing: UsageStats | undefined,\n  success: boolean,\n  durationMs?: number\n): UsageStats {\n  const now = new Date().toISOString();\n\n  if (!existing) {\n    return {\n      count: 1,\n      success_rate: success ? 1 : 0,\n      avg_duration_ms: durationMs,\n      first_used: now,\n      last_used: now,\n    };\n  }\n\n  const newCount = existing.count + 1;\n  const successCount = Math.round(existing.success_rate * existing.count) + (success ? 1 : 0);\n  const newSuccessRate = successCount / newCount;\n\n  let newAvgDuration = existing.avg_duration_ms;\n  if (durationMs !== undefined) {\n    if (existing.avg_duration_ms !== undefined) {\n      newAvgDuration =\n        (existing.avg_duration_ms * existing.count + durationMs) / newCount;\n    } else {\n      newAvgDuration = durationMs;\n    }\n  }\n\n  return {\n    count: newCount,\n    success_rate: newSuccessRate,\n    avg_duration_ms: newAvgDuration,\n    first_used: existing.first_used,\n    last_used: now,\n  };\n}\n\n/**\n * Aggregate a session into the user profile\n */\nexport function aggregateSession(\n  profile: UserProfile,\n  summary: SessionSummary\n): UserProfile {\n  // Skip if already aggregated\n  if (profile.aggregated_sessions.includes(summary.session_id)) {\n    logHook('user-profile', `Session ${summary.session_id} already aggregated`, 'debug');\n    return profile;\n  }\n\n  // Update session count\n  profile.sessions_count++;\n  profile.aggregated_sessions.push(summary.session_id);\n\n  // Aggregate skill usage\n  for (const skill of summary.skills_used) {\n    profile.skill_usage[skill] = updateUsageStats(\n      profile.skill_usage[skill],\n      true // We don't have per-skill success in summary\n    );\n  }\n\n  // Aggregate agent usage\n  for (const agent of summary.agents_spawned) {\n    profile.agent_usage[agent] = updateUsageStats(\n      profile.agent_usage[agent],\n      true\n    );\n  }\n\n  // Aggregate workflow pattern from decision flow (Issue #245 Phase 4)\n  try {\n    const flow = analyzeDecisionFlow(summary.session_id);\n    if (flow?.inferred_pattern && flow.inferred_pattern !== 'mixed') {\n      // Convert to WorkflowPattern interface and add to profile\n      const patternName = flow.inferred_pattern;\n      const existingIndex = profile.workflow_patterns.findIndex(p => p.name === patternName);\n\n      if (existingIndex !== -1) {\n        // Update existing pattern: increase frequency and move to front\n        const existing = profile.workflow_patterns[existingIndex];\n        existing.frequency = Math.min(1, existing.frequency + 0.1);\n        profile.workflow_patterns.splice(existingIndex, 1);\n        profile.workflow_patterns.unshift(existing);\n      } else {\n        // Add new pattern\n        const newPattern = convertFlowPattern(patternName, profile.workflow_patterns);\n        profile.workflow_patterns.unshift(newPattern);\n      }\n\n      // Keep only last 10 workflow patterns\n      if (profile.workflow_patterns.length > 10) {\n        profile.workflow_patterns = profile.workflow_patterns.slice(0, 10);\n      }\n      logHook('user-profile', `Aggregated workflow pattern: ${patternName}`, 'debug');\n    }\n  } catch (error) {\n    // Non-blocking: workflow pattern aggregation failure shouldn't stop profile aggregation\n    logHook('user-profile', `Failed to aggregate workflow pattern: ${error}`, 'debug');\n  }\n\n  // Keep only last N sessions to prevent unbounded growth\n  const MAX_AGGREGATED_SESSIONS = 100;\n  if (profile.aggregated_sessions.length > MAX_AGGREGATED_SESSIONS) {\n    profile.aggregated_sessions = profile.aggregated_sessions.slice(\n      -MAX_AGGREGATED_SESSIONS\n    );\n  }\n\n  return profile;\n}\n\n/**\n * Aggregate current session and save profile\n */\nexport function aggregateCurrentSession(): UserProfile {\n  const identity = resolveUserIdentity();\n  const profile = loadUserProfile(identity.user_id);\n  const summary = generateSessionSummary();\n\n  const updatedProfile = aggregateSession(profile, summary);\n  saveUserProfile(updatedProfile);\n\n  return updatedProfile;\n}\n\n// =============================================================================\n// DECISION/PREFERENCE RECORDING\n// =============================================================================\n\n/**\n * Add a decision to user profile\n */\nexport function addDecision(\n  profile: UserProfile,\n  decision: Omit<RecordedDecision, 'timestamp'>\n): UserProfile {\n  const newDecision: RecordedDecision = {\n    ...decision,\n    timestamp: new Date().toISOString(),\n  };\n\n  profile.decisions.unshift(newDecision);\n\n  // Keep only last N decisions\n  if (profile.decisions.length > MAX_DECISIONS) {\n    profile.decisions = profile.decisions.slice(0, MAX_DECISIONS);\n  }\n\n  return profile;\n}\n\n/**\n * Add or update a preference\n */\nexport function addPreference(\n  profile: UserProfile,\n  category: string,\n  preference: string,\n  confidence: number\n): UserProfile {\n  // Check if preference already exists\n  const existingIdx = profile.preferences.findIndex(\n    p => p.category === category && p.preference === preference\n  );\n\n  if (existingIdx >= 0) {\n    // Update existing\n    const existing = profile.preferences[existingIdx];\n    existing.observation_count++;\n    existing.confidence = Math.max(existing.confidence, confidence);\n    existing.timestamp = new Date().toISOString();\n  } else {\n    // Add new\n    profile.preferences.push({\n      category,\n      preference,\n      confidence,\n      timestamp: new Date().toISOString(),\n      observation_count: 1,\n    });\n\n    // Keep only top N preferences\n    if (profile.preferences.length > MAX_PREFERENCES) {\n      profile.preferences.sort((a, b) => b.observation_count - a.observation_count);\n      profile.preferences = profile.preferences.slice(0, MAX_PREFERENCES);\n    }\n  }\n\n  return profile;\n}\n\n// =============================================================================\n// PROFILE QUERIES\n// =============================================================================\n\n/**\n * Get top N used skills for a user\n */\nexport function getTopSkills(profile: UserProfile, limit: number = 5): Array<{\n  skill: string;\n  stats: UsageStats;\n}> {\n  return Object.entries(profile.skill_usage)\n    .map(([skill, stats]) => ({ skill, stats }))\n    .sort((a, b) => b.stats.count - a.stats.count)\n    .slice(0, limit);\n}\n\n/**\n * Get top N used agents for a user\n */\nexport function getTopAgents(profile: UserProfile, limit: number = 5): Array<{\n  agent: string;\n  stats: UsageStats;\n}> {\n  return Object.entries(profile.agent_usage)\n    .map(([agent, stats]) => ({ agent, stats }))\n    .sort((a, b) => b.stats.count - a.stats.count)\n    .slice(0, limit);\n}\n\n/**\n * Get user's preferred tool for a category\n */\nexport function getPreferredTool(\n  profile: UserProfile,\n  category: string\n): string | undefined {\n  const pref = profile.preferences.find(p => p.category === category);\n  return pref?.preference;\n}\n\n/**\n * Get recent decisions for a user\n */\nexport function getRecentDecisions(\n  profile: UserProfile,\n  limit: number = 10\n): RecordedDecision[] {\n  return profile.decisions.slice(0, limit);\n}\n\n/**\n * Check if user has made a specific type of decision before\n */\nexport function hasDecisionAbout(\n  profile: UserProfile,\n  keyword: string\n): RecordedDecision | undefined {\n  const lower = keyword.toLowerCase();\n  return profile.decisions.find(\n    d =>\n      d.what.toLowerCase().includes(lower) ||\n      d.rationale?.toLowerCase().includes(lower)\n  );\n}\n\n// =============================================================================\n// PROFILE EXPORT (for sharing)\n// =============================================================================\n\n/**\n * Export profile for team sharing (respects privacy settings)\n */\nexport function exportForTeam(profile: UserProfile): Partial<UserProfile> {\n  return {\n    user_id: profile.user_id,\n    display_name: profile.display_name,\n    team_id: profile.team_id,\n    skill_usage: profile.skill_usage,\n    agent_usage: profile.agent_usage,\n    decisions: profile.decisions,\n    preferences: profile.preferences,\n  };\n}\n\n/**\n * Export profile for global sharing (anonymized)\n */\nexport function exportForGlobal(profile: UserProfile): {\n  anonymous_id: string;\n  decisions: Array<Omit<RecordedDecision, 'project'>>;\n  preferences: RecordedPreference[];\n} {\n  // Remove project info from decisions for privacy\n  const anonDecisions = profile.decisions.map(d => {\n    const { project, ...rest } = d;\n    return rest;\n  });\n\n  return {\n    anonymous_id: profile.anonymous_id,\n    decisions: anonDecisions,\n    preferences: profile.preferences,\n  };\n}\n", "/**\n * Decision Flow Tracker - Cross-tool correlation for understanding decision patterns\n *\n * Part of Intelligent Decision Capture System\n *\n * Purpose:\n * - Track sequence of tool actions within a session\n * - Infer workflow patterns (TDD, explore-first, iterate-fast)\n * - Detect when a decision flow completes\n * - Enable understanding of how decisions are made across multiple tools\n *\n * CC 2.1.16 Compliant\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { join, dirname, basename } from 'node:path';\nimport { getProjectDir, logHook } from './common.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * A single tool action in the decision flow\n */\nexport interface ToolAction {\n  /** Tool name (Bash, Read, Write, etc.) */\n  tool: string;\n  /** File involved if applicable */\n  file?: string;\n  /** When the action occurred */\n  timestamp: string;\n  /** Brief summary of what was done */\n  summary: string;\n  /** Result of the action */\n  result: 'success' | 'failure' | 'partial';\n  /** Exit code for Bash */\n  exit_code?: number;\n  /** Action category */\n  category: ActionCategory;\n}\n\n/**\n * Categories for tool actions\n */\nexport type ActionCategory =\n  | 'exploration'  // Read, Glob, Grep\n  | 'modification' // Write, Edit\n  | 'execution'    // Bash\n  | 'testing'      // Bash with test commands\n  | 'building'     // Bash with build commands\n  | 'git'          // Git operations\n  | 'agent'        // Task (subagent spawn)\n  | 'other';\n\n/**\n * Detected workflow pattern\n */\nexport type WorkflowPattern =\n  | 'test-first'      // Tests before implementation (TDD)\n  | 'explore-first'   // Read multiple files before writing\n  | 'iterate-fast'    // Write \u2192 Execute \u2192 Write cycles\n  | 'big-bang'        // Multiple writes then one test\n  | 'agent-delegate'  // Heavy use of Task tool\n  | 'mixed';          // No clear pattern\n\n/**\n * Complete decision flow for a session\n */\nexport interface DecisionFlow {\n  /** Session ID */\n  session_id: string;\n  /** Sequence of actions */\n  actions: ToolAction[];\n  /** Detected workflow pattern */\n  inferred_pattern?: WorkflowPattern;\n  /** When the flow started */\n  started_at: string;\n  /** Last action timestamp */\n  last_action_at: string;\n  /** Summary statistics */\n  stats: FlowStats;\n}\n\n/**\n * Statistics about the decision flow\n */\nexport interface FlowStats {\n  total_actions: number;\n  reads: number;\n  writes: number;\n  tests: number;\n  builds: number;\n  agent_spawns: number;\n  success_rate: number;\n}\n\n// =============================================================================\n// PATTERN DETECTION\n// =============================================================================\n\n/**\n * Patterns for categorizing actions\n */\nconst TEST_COMMAND_PATTERNS = [\n  /\\b(pytest|jest|vitest|npm\\s+test|yarn\\s+test|bun\\s+test|go\\s+test)\\b/i,\n  /\\b(test|tests|spec)\\b.*\\b(run|execute)\\b/i,\n];\n\nconst BUILD_COMMAND_PATTERNS = [\n  /\\b(npm\\s+run\\s+build|yarn\\s+build|make|cargo\\s+build|docker\\s+build|tsc)\\b/i,\n  /\\b(build|compile)\\b/i,\n];\n\nconst GIT_COMMAND_PATTERNS = [\n  /\\bgit\\s+(commit|push|pull|merge|rebase|checkout|branch|status|diff|log)\\b/i,\n  /\\bgh\\s+(pr|issue)\\b/i,\n];\n\n// =============================================================================\n// FILE OPERATIONS\n// =============================================================================\n\n/**\n * Get path to session flow file\n */\nfunction getFlowFilePath(sessionId: string): string {\n  return join(getProjectDir(), '.claude', 'memory', 'flows', `${sessionId}.json`);\n}\n\n/**\n * Get path to completed flows archive\n */\nfunction getCompletedFlowsPath(): string {\n  return join(getProjectDir(), '.claude', 'memory', 'completed-flows.jsonl');\n}\n\n/**\n * Load decision flow for a session\n */\nexport function loadDecisionFlow(sessionId: string): DecisionFlow | null {\n  const filePath = getFlowFilePath(sessionId);\n\n  if (!existsSync(filePath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as DecisionFlow;\n  } catch (err) {\n    logHook('decision-flow-tracker', `Failed to load flow for ${sessionId}: ${err}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Save decision flow for a session\n */\nfunction saveDecisionFlow(flow: DecisionFlow): boolean {\n  const filePath = getFlowFilePath(flow.session_id);\n\n  try {\n    const dir = dirname(filePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    writeFileSync(filePath, JSON.stringify(flow, null, 2));\n    return true;\n  } catch (err) {\n    logHook('decision-flow-tracker', `Failed to save flow: ${err}`, 'warn');\n    return false;\n  }\n}\n\n/**\n * Archive a completed flow\n */\nfunction archiveFlow(flow: DecisionFlow): boolean {\n  const archivePath = getCompletedFlowsPath();\n\n  try {\n    const dir = dirname(archivePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    const line = `${JSON.stringify(flow)}\\n`;\n    bufferWrite(archivePath, line);\n    return true;\n  } catch (err) {\n    logHook('decision-flow-tracker', `Failed to archive flow: ${err}`, 'warn');\n    return false;\n  }\n}\n\n// =============================================================================\n// ACTION CATEGORIZATION\n// =============================================================================\n\n/**\n * Categorize a tool action\n */\nexport function categorizeAction(\n  tool: string,\n  command?: string,\n  _file?: string\n): ActionCategory {\n  // Check for specific tool types\n  if (tool === 'Read' || tool === 'Glob' || tool === 'Grep') {\n    return 'exploration';\n  }\n\n  if (tool === 'Write' || tool === 'Edit' || tool === 'MultiEdit' || tool === 'NotebookEdit') {\n    return 'modification';\n  }\n\n  if (tool === 'Task') {\n    return 'agent';\n  }\n\n  // For Bash, check command patterns\n  if (tool === 'Bash' && command) {\n    if (TEST_COMMAND_PATTERNS.some(p => p.test(command))) {\n      return 'testing';\n    }\n    if (BUILD_COMMAND_PATTERNS.some(p => p.test(command))) {\n      return 'building';\n    }\n    if (GIT_COMMAND_PATTERNS.some(p => p.test(command))) {\n      return 'git';\n    }\n    return 'execution';\n  }\n\n  return 'other';\n}\n\n/**\n * Summarize a tool action\n */\nexport function summarizeAction(\n  tool: string,\n  command?: string,\n  file?: string,\n  result?: 'success' | 'failure' | 'partial'\n): string {\n  const resultStr = result === 'success' ? '\u2713' : result === 'failure' ? '\u2717' : '~';\n\n  if (tool === 'Read') {\n    return `${resultStr} Read ${basename(file ?? '') || 'file'}`;\n  }\n  if (tool === 'Write') {\n    return `${resultStr} Write ${basename(file ?? '') || 'file'}`;\n  }\n  if (tool === 'Edit') {\n    return `${resultStr} Edit ${basename(file ?? '') || 'file'}`;\n  }\n  if (tool === 'Glob') {\n    return `${resultStr} Search files`;\n  }\n  if (tool === 'Grep') {\n    return `${resultStr} Search content`;\n  }\n  if (tool === 'Task') {\n    return `${resultStr} Spawn agent`;\n  }\n\n  if (tool === 'Bash' && command) {\n    // Extract meaningful part of command\n    const cmd = command.split('\\n')[0].slice(0, 50);\n    return `${resultStr} ${cmd}${command.length > 50 ? '...' : ''}`;\n  }\n\n  return `${resultStr} ${tool}`;\n}\n\n// =============================================================================\n// PATTERN INFERENCE\n// =============================================================================\n\n/**\n * Infer workflow pattern from action sequence\n */\nexport function inferWorkflowPattern(actions: ToolAction[]): WorkflowPattern {\n  if (actions.length < 3) {\n    return 'mixed';\n  }\n\n  // Count categories\n  const counts = {\n    exploration: 0,\n    modification: 0,\n    testing: 0,\n    building: 0,\n    agent: 0,\n    execution: 0,\n    git: 0,\n    other: 0,\n  };\n\n  for (const action of actions) {\n    counts[action.category]++;\n  }\n\n  // Check for test-first pattern\n  // Pattern: test \u2192 write \u2192 test\n  if (counts.testing >= 2) {\n    const testIndices = actions\n      .map((a, i) => (a.category === 'testing' ? i : -1))\n      .filter(i => i >= 0);\n    const writeIndices = actions\n      .map((a, i) => (a.category === 'modification' ? i : -1))\n      .filter(i => i >= 0);\n\n    if (testIndices.length >= 2 && writeIndices.length > 0) {\n      // Check if first test comes before first write\n      if (testIndices[0] < writeIndices[0]) {\n        return 'test-first';\n      }\n    }\n  }\n\n  // Check for explore-first pattern\n  // Pattern: read \u2192 read \u2192 read \u2192 write\n  if (counts.exploration >= 3 && counts.modification > 0) {\n    const exploreRun = findConsecutiveRun(actions, 'exploration');\n    if (exploreRun >= 3) {\n      return 'explore-first';\n    }\n  }\n\n  // Check for iterate-fast pattern\n  // Pattern: write \u2192 execute \u2192 write \u2192 execute\n  if (counts.modification >= 2 && (counts.execution + counts.testing) >= 2) {\n    const alternating = countAlternations(actions, 'modification', ['execution', 'testing']);\n    if (alternating >= 2) {\n      return 'iterate-fast';\n    }\n  }\n\n  // Check for agent-delegate pattern\n  if (counts.agent >= 3 || counts.agent / actions.length > 0.3) {\n    return 'agent-delegate';\n  }\n\n  // Check for big-bang pattern\n  // Pattern: write \u2192 write \u2192 write \u2192 test\n  if (counts.modification >= 3 && counts.testing === 1) {\n    const lastTest = actions.map((a, i) => (a.category === 'testing' ? i : -1)).filter(i => i >= 0).pop();\n    if (lastTest && lastTest > actions.length - 3) {\n      return 'big-bang';\n    }\n  }\n\n  return 'mixed';\n}\n\n/**\n * Find longest consecutive run of a category\n */\nfunction findConsecutiveRun(actions: ToolAction[], category: ActionCategory): number {\n  let maxRun = 0;\n  let currentRun = 0;\n\n  for (const action of actions) {\n    if (action.category === category) {\n      currentRun++;\n      maxRun = Math.max(maxRun, currentRun);\n    } else {\n      currentRun = 0;\n    }\n  }\n\n  return maxRun;\n}\n\n/**\n * Count alternations between category A and categories B\n */\nfunction countAlternations(\n  actions: ToolAction[],\n  categoryA: ActionCategory,\n  categoriesB: ActionCategory[]\n): number {\n  let alternations = 0;\n  let lastWasA = false;\n\n  for (const action of actions) {\n    const isA = action.category === categoryA;\n    const isB = categoriesB.includes(action.category);\n\n    if (isA && !lastWasA) {\n      lastWasA = true;\n    } else if (isB && lastWasA) {\n      alternations++;\n      lastWasA = false;\n    }\n  }\n\n  return alternations;\n}\n\n// =============================================================================\n// FLOW MANAGEMENT\n// =============================================================================\n\n/**\n * Calculate flow statistics\n */\nfunction calculateStats(actions: ToolAction[]): FlowStats {\n  const successes = actions.filter(a => a.result === 'success').length;\n\n  return {\n    total_actions: actions.length,\n    reads: actions.filter(a => a.category === 'exploration').length,\n    writes: actions.filter(a => a.category === 'modification').length,\n    tests: actions.filter(a => a.category === 'testing').length,\n    builds: actions.filter(a => a.category === 'building').length,\n    agent_spawns: actions.filter(a => a.category === 'agent').length,\n    success_rate: actions.length > 0 ? successes / actions.length : 0,\n  };\n}\n\n/**\n * Track a tool action in the decision flow\n */\nexport function trackToolAction(\n  sessionId: string,\n  tool: string,\n  command: string | undefined,\n  file: string | undefined,\n  exitCode: number | undefined\n): DecisionFlow {\n  const timestamp = new Date().toISOString();\n\n  // Determine result from exit code\n  let result: 'success' | 'failure' | 'partial' = 'success';\n  if (exitCode !== undefined) {\n    result = exitCode === 0 ? 'success' : 'failure';\n  }\n\n  // Categorize and summarize the action\n  const category = categorizeAction(tool, command, file);\n  const summary = summarizeAction(tool, command, file, result);\n\n  const action: ToolAction = {\n    tool,\n    file,\n    timestamp,\n    summary,\n    result,\n    exit_code: exitCode,\n    category,\n  };\n\n  // Load or create flow\n  let flow = loadDecisionFlow(sessionId);\n\n  if (!flow) {\n    flow = {\n      session_id: sessionId,\n      actions: [],\n      started_at: timestamp,\n      last_action_at: timestamp,\n      stats: calculateStats([]),\n    };\n  }\n\n  // Add action (limit to last 100 actions to prevent unbounded growth)\n  flow.actions.push(action);\n  if (flow.actions.length > 100) {\n    flow.actions = flow.actions.slice(-100);\n  }\n\n  // Update metadata\n  flow.last_action_at = timestamp;\n  flow.inferred_pattern = inferWorkflowPattern(flow.actions);\n  flow.stats = calculateStats(flow.actions);\n\n  // Save\n  saveDecisionFlow(flow);\n\n  return flow;\n}\n\n/**\n * Analyze the decision flow for a session\n */\nexport function analyzeDecisionFlow(sessionId: string): DecisionFlow | null {\n  const flow = loadDecisionFlow(sessionId);\n\n  if (!flow) {\n    return null;\n  }\n\n  // Ensure pattern is up to date\n  flow.inferred_pattern = inferWorkflowPattern(flow.actions);\n  flow.stats = calculateStats(flow.actions);\n\n  return flow;\n}\n\n/**\n * Complete and archive a decision flow (called on session end)\n */\nexport function completeDecisionFlow(sessionId: string): boolean {\n  const flow = loadDecisionFlow(sessionId);\n\n  if (!flow) {\n    return false;\n  }\n\n  // Update final analysis\n  flow.inferred_pattern = inferWorkflowPattern(flow.actions);\n  flow.stats = calculateStats(flow.actions);\n\n  // Archive\n  const archived = archiveFlow(flow);\n\n  if (archived) {\n    logHook(\n      'decision-flow-tracker',\n      `Completed flow for ${sessionId}: ${flow.actions.length} actions, pattern: ${flow.inferred_pattern}`,\n      'info'\n    );\n  }\n\n  return archived;\n}\n\n// =============================================================================\n// GAP-010 FIX: Removed getRecentFlows()\n// Function was exported but never called by production code.\n// Cross-session flow analysis should be added to workflow-preference-learner if needed.\n// =============================================================================\n", "/**\n * Session Profile Aggregator - Aggregate session data into user profile at session end\n *\n * Part of Intelligent Decision Capture System\n *\n * This hook runs at session end to:\n * 1. Generate session summary from events\n * 2. Aggregate into user profile (skills, agents, decisions)\n * 3. Save updated profile to disk\n * 4. Export generalizable decisions for global sharing (if enabled)\n *\n * CC 2.1.7 Compliant: Uses outputSilentSuccess for silent operation\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { logHook, outputSilentSuccess } from '../lib/common.js';\nimport { resolveUserIdentity, canShare, getPrivacySettings } from '../lib/user-identity.js';\n// GAP-012: Removed trackSessionEnd import - handled by session-end-tracking.ts\nimport { generateSessionSummary } from '../lib/session-tracker.js';\nimport {\n  loadUserProfile,\n  saveUserProfile,\n  aggregateSession,\n  exportForGlobal,\n} from '../lib/user-profile.js';\n\n/**\n * Aggregate session data into user profile\n */\nexport function sessionProfileAggregator(_input: HookInput): HookResult {\n  try {\n    // GAP-012: trackSessionEnd() removed - handled by session-end-tracking.ts hook\n    // Both hooks run in Stop dispatcher, avoiding duplicate session_end events\n\n    // Get user identity\n    const identity = resolveUserIdentity();\n    logHook('session-profile-aggregator', `Aggregating session for ${identity.user_id}`, 'debug');\n\n    // Generate session summary\n    const summary = generateSessionSummary();\n\n    // Skip if no meaningful activity\n    if (\n      summary.skills_used.length === 0 &&\n      summary.agents_spawned.length === 0 &&\n      summary.decisions_made === 0\n    ) {\n      logHook('session-profile-aggregator', 'No meaningful activity to aggregate', 'debug');\n      return outputSilentSuccess();\n    }\n\n    // Load and update user profile\n    const profile = loadUserProfile(identity.user_id);\n    const updatedProfile = aggregateSession(profile, summary);\n\n    // Save updated profile\n    const saved = saveUserProfile(updatedProfile);\n    if (!saved) {\n      logHook('session-profile-aggregator', 'Failed to save profile', 'warn');\n      return outputSilentSuccess();\n    }\n\n    logHook(\n      'session-profile-aggregator',\n      `Aggregated session: ${summary.skills_used.length} skills, ${summary.agents_spawned.length} agents, ${summary.decisions_made} decisions`,\n      'info'\n    );\n\n    // Export for global sharing if privacy allows\n    const privacy = getPrivacySettings();\n    if (privacy.share_globally && canShare('decisions', 'global')) {\n      const globalExport = exportForGlobal(updatedProfile);\n\n      // Only export if there are decisions worth sharing\n      const generalizableDecisions = globalExport.decisions.filter(\n        d => d.confidence >= 0.8 && d.rationale\n      );\n\n      if (generalizableDecisions.length > 0) {\n        logHook(\n          'session-profile-aggregator',\n          `${generalizableDecisions.length} decisions eligible for global sharing`,\n          'info'\n        );\n      }\n    }\n\n    return outputSilentSuccess();\n  } catch (error) {\n    logHook('session-profile-aggregator', `Error aggregating session: ${error}`, 'error');\n    return outputSilentSuccess();\n  }\n}\n", "/**\n * Session End Tracking Hook\n * Issue #245: Multi-User Intelligent Decision Capture System\n *\n * Tracks session end event to finalize session in user profile.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport { trackSessionEnd } from '../lib/session-tracker.js';\n\n/**\n * Track session end event\n */\nexport function sessionEndTracking(_input: HookInput): HookResult {\n  try {\n    trackSessionEnd();\n    logHook('session-end-tracking', 'Tracked session end', 'debug');\n    return outputSilentSuccess();\n  } catch (error) {\n    logHook('session-end-tracking', `Error: ${error}`, 'warn');\n    return outputSilentSuccess();\n  }\n}\n", "/**\n * Workflow Preference Learner Hook - Learn user's development workflow patterns\n *\n * Part of Intelligent Decision Capture System\n * Hook: Stop\n *\n * Purpose:\n * - Analyze the session's decision flow on completion\n * - Detect workflow patterns (TDD, explore-first, iterate-fast)\n * - Track patterns across sessions for learning\n * - Store workflow preferences\n *\n * Patterns Detected:\n * - test-first: TDD workflow (tests before implementation)\n * - explore-first: Read files before writing\n * - iterate-fast: Quick write \u2192 test cycles\n * - big-bang: Multiple writes then test\n * - agent-delegate: Heavy use of subagents\n *\n * CC 2.1.16 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  getProjectDir,\n  getSessionId,\n  logHook,\n} from '../lib/common.js';\nimport {\n  analyzeDecisionFlow,\n  completeDecisionFlow,\n  type WorkflowPattern,\n  type DecisionFlow,\n} from '../lib/decision-flow-tracker.js';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, dirname } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst HOOK_NAME = 'workflow-preference-learner';\nconst MIN_ACTIONS_FOR_PATTERN = 5; // Need at least 5 actions to detect pattern\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Workflow preference with statistics\n */\nexport interface WorkflowPreference {\n  /** The workflow pattern */\n  pattern: WorkflowPattern;\n  /** How often this pattern is used (0-1) */\n  frequency: number;\n  /** Number of sessions with this pattern */\n  count: number;\n  /** Total sessions analyzed */\n  total_sessions: number;\n  /** Average success rate for this pattern */\n  avg_success_rate: number;\n  /** Last updated timestamp */\n  updated_at: string;\n}\n\n/**\n * All workflow preferences data\n */\ninterface WorkflowPreferencesData {\n  /** Count of each pattern */\n  pattern_counts: Record<WorkflowPattern, number>;\n  /** Success rates for each pattern */\n  pattern_success_rates: Record<WorkflowPattern, number[]>;\n  /** Total sessions analyzed */\n  total_sessions: number;\n  /** Derived preferences */\n  preferences: WorkflowPreference[];\n  /** Last update timestamp */\n  updated_at: string;\n}\n\n// =============================================================================\n// FILE OPERATIONS\n// =============================================================================\n\n/**\n * Get path to workflow preferences file\n */\nfunction getWorkflowPreferencesPath(): string {\n  return join(getProjectDir(), '.claude', 'memory', 'workflow-preferences.json');\n}\n\n/**\n * Load workflow preferences data\n */\nfunction loadWorkflowPreferences(): WorkflowPreferencesData {\n  const filePath = getWorkflowPreferencesPath();\n\n  if (!existsSync(filePath)) {\n    return createEmptyWorkflowPreferences();\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf-8');\n    return JSON.parse(content) as WorkflowPreferencesData;\n  } catch {\n    return createEmptyWorkflowPreferences();\n  }\n}\n\n/**\n * Save workflow preferences data\n */\nfunction saveWorkflowPreferences(data: WorkflowPreferencesData): boolean {\n  const filePath = getWorkflowPreferencesPath();\n\n  try {\n    const dir = dirname(filePath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n\n    writeFileSync(filePath, JSON.stringify(data, null, 2));\n    return true;\n  } catch (err) {\n    logHook(HOOK_NAME, `Failed to save workflow preferences: ${err}`, 'warn');\n    return false;\n  }\n}\n\n/**\n * Create empty workflow preferences structure\n */\nfunction createEmptyWorkflowPreferences(): WorkflowPreferencesData {\n  const patterns: WorkflowPattern[] = [\n    'test-first', 'explore-first', 'iterate-fast', 'big-bang', 'agent-delegate', 'mixed',\n  ];\n\n  const pattern_counts: Record<WorkflowPattern, number> = {} as Record<WorkflowPattern, number>;\n  const pattern_success_rates: Record<WorkflowPattern, number[]> = {} as Record<WorkflowPattern, number[]>;\n\n  for (const pattern of patterns) {\n    pattern_counts[pattern] = 0;\n    pattern_success_rates[pattern] = [];\n  }\n\n  return {\n    pattern_counts,\n    pattern_success_rates,\n    total_sessions: 0,\n    preferences: [],\n    updated_at: new Date().toISOString(),\n  };\n}\n\n// =============================================================================\n// PREFERENCE CALCULATION\n// =============================================================================\n\n/**\n * Calculate preferences from pattern data\n */\nfunction calculateWorkflowPreferences(data: WorkflowPreferencesData): WorkflowPreference[] {\n  const preferences: WorkflowPreference[] = [];\n  const timestamp = new Date().toISOString();\n\n  for (const [pattern, count] of Object.entries(data.pattern_counts)) {\n    if (count === 0) continue;\n\n    const successRates = data.pattern_success_rates[pattern as WorkflowPattern] || [];\n    const avgSuccessRate = successRates.length > 0\n      ? successRates.reduce((a, b) => a + b, 0) / successRates.length\n      : 0;\n\n    preferences.push({\n      pattern: pattern as WorkflowPattern,\n      frequency: data.total_sessions > 0 ? count / data.total_sessions : 0,\n      count,\n      total_sessions: data.total_sessions,\n      avg_success_rate: avgSuccessRate,\n      updated_at: timestamp,\n    });\n  }\n\n  // Sort by frequency descending\n  preferences.sort((a, b) => b.frequency - a.frequency);\n\n  return preferences;\n}\n\n/**\n * Update workflow preferences with a new session's pattern\n */\nfunction updateWorkflowPreferences(\n  data: WorkflowPreferencesData,\n  flow: DecisionFlow\n): void {\n  if (!flow.inferred_pattern) return;\n\n  const pattern = flow.inferred_pattern;\n  const successRate = flow.stats.success_rate;\n\n  // Update counts\n  data.pattern_counts[pattern] = (data.pattern_counts[pattern] || 0) + 1;\n  data.total_sessions++;\n\n  // Update success rates (keep last 20 per pattern)\n  if (!data.pattern_success_rates[pattern]) {\n    data.pattern_success_rates[pattern] = [];\n  }\n  data.pattern_success_rates[pattern].push(successRate);\n  if (data.pattern_success_rates[pattern].length > 20) {\n    data.pattern_success_rates[pattern] = data.pattern_success_rates[pattern].slice(-20);\n  }\n\n  // Recalculate preferences\n  data.preferences = calculateWorkflowPreferences(data);\n  data.updated_at = new Date().toISOString();\n}\n\n// =============================================================================\n// MAIN HOOK\n// =============================================================================\n\n/**\n * Learn workflow preferences from completed session\n */\nexport function workflowPreferenceLearner(input: HookInput): HookResult {\n  const sessionId = input.session_id || getSessionId();\n\n  // Analyze the decision flow\n  const flow = analyzeDecisionFlow(sessionId);\n\n  if (!flow) {\n    logHook(HOOK_NAME, `No decision flow found for session ${sessionId}`, 'debug');\n    return outputSilentSuccess();\n  }\n\n  // Need minimum actions to detect meaningful pattern\n  if (flow.actions.length < MIN_ACTIONS_FOR_PATTERN) {\n    logHook(HOOK_NAME, `Too few actions (${flow.actions.length}) for pattern detection`, 'debug');\n    return outputSilentSuccess();\n  }\n\n  // Complete and archive the flow\n  completeDecisionFlow(sessionId);\n\n  // Skip 'mixed' patterns as they don't provide learning value\n  if (flow.inferred_pattern === 'mixed') {\n    return outputSilentSuccess();\n  }\n\n  // Load and update preferences\n  const data = loadWorkflowPreferences();\n  updateWorkflowPreferences(data, flow);\n  saveWorkflowPreferences(data);\n\n  // Log the detected pattern\n  logHook(\n    HOOK_NAME,\n    `Session pattern: ${flow.inferred_pattern} (${flow.actions.length} actions, ${(flow.stats.success_rate * 100).toFixed(0)}% success)`,\n    'info'\n  );\n\n  // Check for strong preference emergence\n  const topPref = data.preferences[0];\n  if (topPref && topPref.frequency > 0.6 && topPref.count >= 5) {\n    logHook(\n      HOOK_NAME,\n      `Strong workflow preference: ${topPref.pattern} (${(topPref.frequency * 100).toFixed(0)}% of sessions)`,\n      'info'\n    );\n  }\n\n  return outputSilentSuccess();\n}\n\n// =============================================================================\n// EXPORTS FOR OTHER HOOKS\n// =============================================================================\n\n/**\n * Get the user's primary workflow preference\n */\nexport function getPrimaryWorkflowPreference(): WorkflowPreference | null {\n  const data = loadWorkflowPreferences();\n  return data.preferences[0] || null;\n}\n\n/**\n * Get all workflow preferences\n */\nexport function getAllWorkflowPreferences(): WorkflowPreference[] {\n  const data = loadWorkflowPreferences();\n  return data.preferences;\n}\n\n/**\n * Get workflow pattern summary for context injection\n */\nexport function getWorkflowSummary(): string | null {\n  const data = loadWorkflowPreferences();\n\n  if (data.total_sessions < 3) {\n    return null; // Not enough data\n  }\n\n  const primary = data.preferences[0];\n  if (!primary || primary.frequency < 0.4) {\n    return null; // No clear preference\n  }\n\n  const patternDescriptions: Record<WorkflowPattern, string> = {\n    'test-first': 'writes tests before implementation (TDD)',\n    'explore-first': 'reads existing code before making changes',\n    'iterate-fast': 'makes quick write \u2192 test iterations',\n    'big-bang': 'writes multiple files then tests',\n    'agent-delegate': 'delegates tasks to specialized agents',\n    'mixed': 'varies approach by task',\n  };\n\n  return `User typically ${patternDescriptions[primary.pattern]} (${(primary.frequency * 100).toFixed(0)}% of sessions, ${(primary.avg_success_rate * 100).toFixed(0)}% success rate)`;\n}\n", "/**\n * Coverage Check Hook\n * Runs on Stop for testing skills - checks if coverage threshold is met\n * CC 2.1.7 Compliant - Silent operation\n */\n\nimport { existsSync, mkdirSync, } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir, getProjectDir } from '../lib/common.js';\n\n/**\n * Check coverage threshold on stop\n */\nexport function coverageCheck(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const logDir = getLogDir();\n  const logFile = `${logDir}/coverage-check.log`;\n  const threshold = parseInt(process.env.COVERAGE_THRESHOLD || '80', 10);\n\n  // Ensure log directory exists\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const logLines: string[] = [];\n  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n  logLines.push(`[${timestamp}] Coverage Check`);\n\n  // Check Python coverage\n  const coverageFile = `${projectDir}/.coverage`;\n  const coverageXml = `${projectDir}/coverage.xml`;\n\n  if (existsSync(coverageFile) || existsSync(coverageXml)) {\n    try {\n      const result = execSync('coverage report --fail-under=0', {\n        cwd: projectDir,\n        encoding: 'utf8',\n        timeout: 30000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n\n      const totalLine = result.split('\\n').find((line) => line.includes('TOTAL'));\n      if (totalLine) {\n        const match = totalLine.match(/(\\d+)%/);\n        if (match) {\n          const coverage = parseInt(match[1], 10);\n          logLines.push(`Python coverage: ${coverage}%`);\n          if (coverage < threshold) {\n            logLines.push(`WARNING: Coverage ${coverage}% is below threshold ${threshold}%`);\n          } else {\n            logLines.push('Coverage meets threshold');\n          }\n        }\n      }\n    } catch {\n      // coverage command not available or failed\n    }\n  }\n\n  // Check JS/TS coverage\n  const coverageDir = `${projectDir}/coverage`;\n  if (existsSync(coverageDir)) {\n    const summaryFile = `${coverageDir}/coverage-summary.json`;\n    if (existsSync(summaryFile)) {\n      logLines.push('');\n      logLines.push('JavaScript/TypeScript coverage report found');\n      logLines.push('Check coverage/lcov-report/index.html for details');\n    }\n  }\n\n  // Write to log file\n  try {\n    bufferWrite(logFile, `${logLines.join('\\n')}\\n`);\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Evidence Collector Hook\n * Runs on Stop for evidence-verification skill\n * Collects verification evidence - silent operation\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync, mkdirSync, readdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir, getProjectDir } from '../lib/common.js';\n\n/**\n * Collect verification evidence on session stop\n */\nexport function evidenceCollector(_input: HookInput): HookResult {\n  const logDir = getLogDir();\n  const projectDir = getProjectDir();\n  const logFile = `${logDir}/evidence-collector.log`;\n\n  // Ensure log directory exists\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n  const logLines: string[] = [];\n\n  logLines.push(`[${timestamp}] Evidence Collection`);\n\n  // Collect exit codes from recent commands\n  logLines.push('Recent command results:');\n  const lastExitCode = process.env.CC_LAST_EXIT_CODE;\n  if (lastExitCode) {\n    logLines.push(`  Last exit code: ${lastExitCode}`);\n  }\n\n  // Check for test results\n  if (existsSync(`${projectDir}/pytest.xml`) || existsSync(`${projectDir}/junit.xml`)) {\n    logLines.push('  Test results: Found (XML format)');\n  }\n\n  const testResultsDir = `${projectDir}/test-results`;\n  if (existsSync(testResultsDir)) {\n    logLines.push('  Test results directory: Found');\n    try {\n      const files = readdirSync(testResultsDir).slice(0, 5);\n      for (const file of files) {\n        logLines.push(`    ${file}`);\n      }\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Check for coverage\n  if (existsSync(`${projectDir}/.coverage`) || existsSync(`${projectDir}/coverage`)) {\n    logLines.push('  Coverage data: Found');\n  }\n\n  // Check for lint results\n  if (existsSync(`${projectDir}/lint-results.json`) || existsSync(`${projectDir}/eslint-report.json`)) {\n    logLines.push('  Lint results: Found');\n  }\n\n  logLines.push('Evidence verification complete.');\n\n  // Write to log file (silent operation)\n  try {\n    bufferWrite(logFile, `${logLines.join('\\n')}\\n`);\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Coverage Threshold Gate Hook\n * BLOCKING: Coverage must meet threshold after implementation\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputBlock, getProjectDir } from '../lib/common.js';\n\nconst COVERAGE_PATHS = [\n  // JavaScript/TypeScript (Jest, Vitest, c8)\n  'coverage/coverage-summary.json',\n  'coverage/coverage-final.json',\n  '.vitest/coverage/coverage-summary.json',\n  // Python (coverage.py, pytest-cov)\n  'coverage.json',\n  '.coverage.json',\n  'htmlcov/status.json',\n];\n\n/**\n * Parse coverage from various file formats\n */\nfunction parseCoverage(filePath: string, content: string): number | null {\n  try {\n    const data = JSON.parse(content);\n\n    // Jest/Vitest coverage-summary.json format\n    if (filePath.includes('coverage-summary.json')) {\n      return data?.total?.lines?.pct ?? data?.total?.statements?.pct ?? null;\n    }\n\n    // coverage.py JSON format\n    if (filePath.includes('coverage.json')) {\n      return data?.totals?.percent_covered ?? null;\n    }\n\n    // Try generic pct field\n    if (data?.total?.pct !== undefined) {\n      return data.total.pct;\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check coverage threshold gate\n */\nexport function coverageThresholdGate(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const threshold = parseInt(process.env.COVERAGE_THRESHOLD || '80', 10);\n\n  // Find coverage file\n  let coverageFile = '';\n  let coverageContent = '';\n\n  for (const path of COVERAGE_PATHS) {\n    const fullPath = `${projectDir}/${path}`;\n    if (existsSync(fullPath)) {\n      coverageFile = fullPath;\n      try {\n        coverageContent = readFileSync(fullPath, 'utf8');\n      } catch {\n        continue;\n      }\n      break;\n    }\n  }\n\n  // No coverage file = skip (coverage might not be configured yet)\n  if (!coverageFile || !coverageContent) {\n    return outputSilentSuccess();\n  }\n\n  // Parse coverage\n  const coverage = parseCoverage(coverageFile, coverageContent);\n  if (coverage === null) {\n    return outputSilentSuccess();\n  }\n\n  // Check threshold\n  const coverageInt = Math.floor(coverage);\n  if (coverageInt < threshold) {\n    const reason = `BLOCKED: Coverage ${coverage}% is below threshold ${threshold}%\n\nCoverage report: ${coverageFile}\n\nActions required:\n  1. Identify uncovered code paths\n  2. Add tests for critical business logic\n  3. Re-run tests with coverage:\n\n     TypeScript: npm test -- --coverage\n     Python:     pytest --cov=app --cov-report=term-missing\n\n  4. Ensure coverage >= ${threshold}% before proceeding\n\nTip: Focus on testing:\n  - Business logic (services, utils)\n  - Edge cases and error handling\n  - Critical user flows`;\n\n    return outputBlock(reason);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Cross-Instance Test Validator Hook\n * BLOCKING: Ensure test coverage when code is split across instances\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync, readFileSync, } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  outputBlock,\n  outputWithContext,\n} from '../lib/common.js';\nimport { basename, dirname } from 'node:path';\n\n/**\n * Check if file is a test file\n */\nfunction isTestFile(filePath: string): boolean {\n  return (\n    /\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath) ||\n    /test_[^/.]{0,200}\\.py$/.test(filePath) ||\n    /_test\\.py$/.test(filePath)\n  );\n}\n\n/**\n * Find corresponding test file for an implementation\n */\nfunction findTestFile(implFile: string): string | null {\n  if (/\\.(ts|tsx|js|jsx)$/.test(implFile)) {\n    const base = implFile.replace(/\\.[^.]+$/, '');\n    const ext = implFile.split('.').pop() || 'ts';\n\n    // Check common patterns\n    const patterns = [\n      `${base}.test.${ext}`,\n      `${base}.spec.${ext}`,\n      `${base}.test.ts`,\n      `${base}.test.tsx`,\n    ];\n\n    for (const pattern of patterns) {\n      if (existsSync(pattern)) return pattern;\n    }\n\n    // Check __tests__ directory\n    const dir = dirname(implFile);\n    const filename = basename(implFile);\n    const baseFilename = filename.replace(/\\.[^.]+$/, '');\n\n    const testDirPatterns = [\n      `${dir}/__tests__/${baseFilename}.test.${ext}`,\n      `${dir}/__tests__/${baseFilename}.spec.${ext}`,\n    ];\n\n    for (const pattern of testDirPatterns) {\n      if (existsSync(pattern)) return pattern;\n    }\n  } else if (implFile.endsWith('.py')) {\n    const dir = dirname(implFile);\n    const filename = basename(implFile);\n    const testFilename = `test_${filename}`;\n\n    // Try same directory\n    if (existsSync(`${dir}/${testFilename}`)) {\n      return `${dir}/${testFilename}`;\n    }\n\n    // Try tests/ directory\n    const parentDir = dirname(dir);\n    if (existsSync(`${parentDir}/tests/${testFilename}`)) {\n      return `${parentDir}/tests/${testFilename}`;\n    }\n    if (existsSync(`${dir}/tests/${testFilename}`)) {\n      return `${dir}/tests/${testFilename}`;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Extract testable units from content\n */\nfunction extractTestableUnits(content: string, filePath: string): string[] {\n  const units: string[] = [];\n\n  if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // TypeScript/JavaScript: Extract exported functions and classes\n    const matches = content.match(/export (function|class|const|async function)\\s+([A-Za-z_][A-Za-z0-9_]*)/g);\n    if (matches) {\n      for (const match of matches) {\n        const name = match.split(/\\s+/).pop();\n        if (name) units.push(name);\n      }\n    }\n  } else if (filePath.endsWith('.py')) {\n    // Python: Extract public functions and classes\n    const lines = content.split('\\n');\n    for (const line of lines) {\n      const match = line.match(/^(def|class)\\s+([A-Za-z][A-Za-z0-9_]*)/);\n      if (match?.[2]) {\n        units.push(match[2]);\n      }\n    }\n  }\n\n  return [...new Set(units)];\n}\n\n/**\n * Validate test coverage for cross-instance code\n */\nexport function crossInstanceTestValidator(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || '';\n  const content = input.tool_input?.content || (input as any).tool_result || '';\n\n  if (!filePath || !content) return outputSilentSuccess();\n\n  // Only validate implementation files (not tests)\n  if (isTestFile(filePath)) return outputSilentSuccess();\n\n  // Skip non-code files\n  if (!/\\.(ts|tsx|js|jsx|py)$/.test(filePath)) {\n    return outputSilentSuccess();\n  }\n\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Find corresponding test file\n  const testFile = findTestFile(filePath);\n\n  // Extract testable units\n  const testableUnits = extractTestableUnits(content, filePath);\n\n  if (testableUnits.length > 0) {\n    if (!testFile) {\n      errors.push('TEST COVERAGE: No test file found for implementation');\n      errors.push(`  Implementation: ${filePath}`);\n      errors.push('  Expected test file:');\n\n      if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n        const base = filePath.replace(/\\.[^.]+$/, '');\n        const ext = filePath.split('.').pop() || 'ts';\n        const dir = dirname(filePath);\n        const fname = basename(filePath);\n        errors.push(`    - ${base}.test.${ext}`);\n        errors.push(`    - ${dir}/__tests__/${fname}`);\n      } else if (filePath.endsWith('.py')) {\n        const fname = basename(filePath);\n        const dir = dirname(filePath);\n        errors.push(`    - ${dir}/test_${fname}`);\n        errors.push(`    - ${dirname(dir)}/tests/test_${fname}`);\n      }\n\n      errors.push('');\n      errors.push(`  Found ${testableUnits.length} testable units:`);\n      for (const unit of testableUnits.slice(0, 5)) {\n        errors.push(`    - ${unit}`);\n      }\n    } else {\n      // Test file exists - check if new units are tested\n      try {\n        const testContent = readFileSync(testFile, 'utf8');\n        const untestedUnits: string[] = [];\n\n        for (const unit of testableUnits) {\n          // Use word boundary check\n          const regex = new RegExp(`\\\\b${unit.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`);\n          if (!regex.test(testContent)) {\n            untestedUnits.push(unit);\n          }\n        }\n\n        if (untestedUnits.length > 0) {\n          warnings.push('TEST COVERAGE: New units without tests');\n          warnings.push(`  Implementation: ${filePath}`);\n          warnings.push(`  Test file: ${testFile}`);\n          warnings.push('');\n          warnings.push(`  Untested units (${untestedUnits.length}/${testableUnits.length}):`);\n          for (const unit of untestedUnits.slice(0, 5)) {\n            warnings.push(`    - ${unit}`);\n          }\n          warnings.push('');\n          warnings.push('  Add tests before committing');\n        }\n      } catch {\n        // Ignore file read errors\n      }\n    }\n  }\n\n  // Block on missing tests for new code\n  if (errors.length > 0) {\n    return outputBlock(`Missing test coverage for new code: ${errors[0]}`);\n  }\n\n  // Warn about test gaps\n  if (warnings.length > 0) {\n    const warningContext = warnings.join('\\n');\n    return outputWithContext(`Test coverage warnings detected:\\n\\n${warningContext}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * DI Pattern Enforcer Hook\n * BLOCKING: Enforce dependency injection patterns in FastAPI\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport { basename } from 'node:path';\n\n/**\n * Enforce dependency injection patterns in FastAPI routers\n */\nexport function diPatternEnforcer(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || '';\n  const content = input.tool_input?.content || (input as any).tool_result || '';\n\n  if (!filePath || !content) return outputSilentSuccess();\n\n  // Only validate Python files in routers/\n  if (!(filePath.includes('/routers/') && filePath.endsWith('.py'))) {\n    return outputSilentSuccess();\n  }\n\n  // Skip deps.py and dependencies.py (these define the DI functions)\n  const filename = basename(filePath);\n  if (/^(deps|dependencies|__init__)\\.py$/.test(filename)) {\n    return outputSilentSuccess();\n  }\n\n  const errors: string[] = [];\n\n  // Rule: No direct service/repository instantiation\n  if (content.includes('Service()') && /=\\s*[A-Z]/.test(content)) {\n    // Extract class name: find \"XxxService()\" pattern without regex backtracking\n    const serviceIdx = content.indexOf('Service()');\n    let className = 'Service()';\n    if (serviceIdx > 0) {\n      const before = content.substring(Math.max(0, serviceIdx - 50), serviceIdx + 9);\n      const parts = before.split(/[^A-Za-z]/);\n      const last = parts.filter((p: string) => p.endsWith('Service')).pop();\n      if (last) className = `${last}()`;\n    }\n    errors.push('INSTANTIATION: Direct service instantiation not allowed');\n    errors.push(`  Found: ${className}`);\n    errors.push('  ');\n    errors.push('  Use dependency injection:');\n    errors.push('    service: MyService = Depends(get_my_service)');\n  }\n\n  if ((content.includes('Repository()') || content.includes('Repo()')) && /=\\s*[A-Z]/.test(content)) {\n    // Extract class name without regex backtracking\n    const repoIdx = content.indexOf('Repository()') !== -1 ? content.indexOf('Repository()') : content.indexOf('Repo()');\n    let className = 'Repository()';\n    if (repoIdx > 0) {\n      const before = content.substring(Math.max(0, repoIdx - 50), repoIdx + 15);\n      const parts = before.split(/[^A-Za-z]/);\n      const last = parts.filter((p: string) => p.endsWith('Repository') || p.endsWith('Repo')).pop();\n      if (last) className = `${last}()`;\n    }\n    errors.push('INSTANTIATION: Direct repository instantiation not allowed');\n    errors.push(`  Found: ${className}`);\n    errors.push('  ');\n    errors.push('  Use dependency injection:');\n    errors.push('    repo: MyRepository = Depends(get_my_repository)');\n  }\n\n  // Rule: No global service/repository instances\n  if ((content.includes('Service(') || content.includes('Repository(') || content.includes('Repo(')) &&\n      /^[a-z_]+\\s*=\\s*[A-Z]/m.test(content)) {\n    errors.push('GLOBAL: Global service/repository instance not allowed');\n    errors.push('  ');\n    errors.push('  Global instances cause:');\n    errors.push('    - Shared state between requests');\n    errors.push('    - Difficult testing');\n    errors.push('    - Connection pool issues');\n    errors.push('  ');\n    errors.push('  Use Depends() for request-scoped instances');\n  }\n\n  // Rule: Database session must use Depends()\n  if ((content.includes('Session') || content.includes('AsyncSession')) && content.includes(')')) {\n    if (!/:\\s*(Async)?Session\\s*=\\s*Depends/.test(content)) {\n      errors.push('DI: Database session must use Depends()');\n      errors.push('  ');\n      errors.push('  BAD:  async def get_users(db: AsyncSession):');\n      errors.push('  GOOD: async def get_users(db: AsyncSession = Depends(get_db)):');\n    }\n  }\n\n  // Rule: Route handlers should use Depends for typed dependencies\n  if (/@router\\.(get|post|put|patch|delete)/.test(content)) {\n    if ((content.includes('Service') || content.includes('Repository') || content.includes('Repo')) &&\n        /:\\s*[A-Z]/.test(content)) {\n      if (!content.includes('= Depends')) {\n        errors.push('DI: Service/Repository parameters must use Depends()');\n        errors.push('  ');\n        errors.push('  BAD:  async def create_user(user_service: UserService):');\n        errors.push('  GOOD: async def create_user(user_service: UserService = Depends(get_user_service)):');\n      }\n    }\n  }\n\n  // Rule: No sync DB calls in async functions\n  if (/async def/.test(content)) {\n    // Check for db.query() - sync SQLAlchemy 1.x pattern\n    if (/db\\.query\\(/.test(content)) {\n      if (!(content.includes('await') && content.includes('db.query('))) {\n        errors.push('ASYNC: Sync database call in async function');\n        errors.push('  Found: db.query() (sync pattern)');\n        errors.push('  ');\n        errors.push('  Use async SQLAlchemy 2.0 patterns:');\n        errors.push('    result = await db.execute(select(User))');\n        errors.push('    users = result.scalars().all()');\n      }\n    }\n\n    // Check for session methods that should be awaited\n    const syncPattern = /db\\.(add|delete|commit|flush|rollback|refresh)\\(/;\n    if (syncPattern.test(content)) {\n      if (/AsyncSession/.test(content)) {\n        // Check if await is used with these methods\n        const lines = content.split('\\n');\n        for (const line of lines) {\n          if (syncPattern.test(line) && !line.includes('await')) {\n            errors.push('ASYNC: Missing await for async database operation');\n            errors.push('  ');\n            errors.push('  With AsyncSession, use await:');\n            errors.push('    await db.commit()');\n            errors.push('    await db.refresh(user)');\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // Report errors and block\n  if (errors.length > 0) {\n    logHook('di-pattern-enforcer', `BLOCKED: DI violation in ${filePath}`);\n    const ctx = `Dependency injection violation in ${filePath}. See stderr for details.`;\n    return outputWithContext(ctx);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Duplicate Code Detector Hook\n * BLOCKING: Detect duplicate/redundant code across worktrees\n * CC 2.1.7 Compliant\n */\n\nimport { readFileSync, readdirSync, } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, getProjectDir } from '../lib/common.js';\nimport { getRepoRoot } from '../lib/git.js';\n\n/**\n * Extract function/class signatures from content\n */\nfunction extractSignatures(content: string, filePath: string): string[] {\n  const signatures: string[] = [];\n\n  if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // TypeScript/JavaScript\n    const matches = content.match(/(function|class|const|export function|export class)\\s+[A-Za-z_][A-Za-z0-9_]*/g);\n    if (matches) {\n      signatures.push(...matches);\n    }\n  } else if (filePath.endsWith('.py')) {\n    // Python\n    const lines = content.split('\\n');\n    for (const line of lines) {\n      const match = line.match(/^(def|class)\\s+[A-Za-z_][A-Za-z0-9_]*/);\n      if (match) signatures.push(match[0]);\n    }\n  }\n\n  return [...new Set(signatures)];\n}\n\n/**\n * Find code files in directory (excluding common ignored paths)\n */\nfunction findCodeFiles(dir: string, pattern: RegExp): string[] {\n  const files: string[] = [];\n  const ignoreDirs = ['node_modules', '.venv', 'venv', '__pycache__', 'dist', 'build', '.next', '.git'];\n\n  function walk(currentDir: string): void {\n    try {\n      const entries = readdirSync(currentDir, { withFileTypes: true });\n      for (const entry of entries) {\n        const fullPath = `${currentDir}/${entry.name}`;\n        if (entry.isDirectory()) {\n          if (!ignoreDirs.includes(entry.name)) {\n            walk(fullPath);\n          }\n        } else if (entry.isFile() && pattern.test(entry.name)) {\n          files.push(fullPath);\n        }\n      }\n    } catch {\n      // Ignore access errors\n    }\n  }\n\n  walk(dir);\n  return files;\n}\n\n/**\n * Check for copy-paste patterns in content\n */\nfunction checkCopyPastePatterns(content: string): string[] {\n  const warnings: string[] = [];\n  const lines = content.split('\\n');\n  let prev = '';\n  let count = 0;\n  let startLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (line && line === prev) {\n      count++;\n      if (count >= 3) {\n        warnings.push(`Line ${startLine}: ${prev.substring(0, 50)}`);\n      }\n    } else {\n      prev = line;\n      count = 1;\n      startLine = i + 1;\n    }\n  }\n\n  return warnings;\n}\n\n/**\n * Check for utility patterns that should be centralized\n */\nfunction checkUtilityPatterns(content: string, filePath: string): { errors: string[]; warnings: string[] } {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // Check for date formatting\n    if (content.includes('new Date') && content.includes('toLocaleDateString')) {\n      errors.push('UTILITY: Direct date formatting detected');\n      errors.push(\"  Use centralized date utilities: import { formatDate } from '@/lib/dates'\");\n    }\n\n    // Check for multiple fetch calls\n    const fetchCount = (content.match(/fetch\\s*\\(\\s*['\"]/g) || []).length;\n    if (fetchCount > 2) {\n      warnings.push(`UTILITY: Multiple fetch calls detected (${fetchCount})`);\n      warnings.push('  Consider using centralized API client or custom hook');\n    }\n\n    // Check for multiple inline validations\n    const validationCount = content.split('\\n').filter(line => line.includes('.test(') && /if\\s*\\(/.test(line)).length;\n    if (validationCount > 3) {\n      warnings.push(`UTILITY: Multiple inline validations detected (${validationCount})`);\n      warnings.push('  Use Zod schemas: const schema = z.object({...})');\n    }\n  }\n\n  if (filePath.endsWith('.py')) {\n    // Check for multiple json.loads\n    const jsonCount = (content.match(/json\\.loads/g) || []).length;\n    if (jsonCount > 3) {\n      warnings.push(`UTILITY: Multiple json.loads detected (${jsonCount})`);\n      warnings.push('  Consider centralized JSON handling with error recovery');\n    }\n\n    // Check for multiple environment variable access\n    const envCount = (content.match(/os\\.getenv|os\\.environ/g) || []).length;\n    if (envCount > 5) {\n      warnings.push(`UTILITY: Multiple environment variable accesses (${envCount})`);\n      warnings.push('  Use Settings/Config class with Pydantic validation');\n    }\n  }\n\n  return { errors, warnings };\n}\n\n/**\n * Detect duplicate/redundant code across worktrees\n */\nexport function duplicateCodeDetector(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || '';\n  const content = input.tool_input?.content || (input as any).tool_result || '';\n\n  if (!filePath || !content) return outputSilentSuccess();\n\n  // Only validate code files\n  if (!/\\.(ts|tsx|js|jsx|py)$/.test(filePath)) {\n    return outputSilentSuccess();\n  }\n\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // 1. Extract signatures and check for duplicates in main repo\n  const signatures = extractSignatures(content, filePath);\n  if (signatures.length > 0) {\n    const projectRoot = getRepoRoot() || getProjectDir();\n    const codeFiles = findCodeFiles(projectRoot, /\\.(ts|tsx|js|jsx|py)$/);\n\n    for (const signature of signatures) {\n      const name = signature.split(/\\s+/).pop() || '';\n      if (!name) continue;\n\n      // Search for duplicates\n      for (const codeFile of codeFiles) {\n        if (codeFile === filePath) continue;\n\n        try {\n          const fileContent = readFileSync(codeFile, 'utf8');\n          // Word boundary check\n          const regex = new RegExp(`\\\\b${name.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\\\b`);\n          if (regex.test(fileContent)) {\n            // Check for exact signature match\n            if (fileContent.includes(signature)) {\n              const relPath = codeFile.replace(`${projectRoot}/`, '');\n              warnings.push(`DUPLICATE: '${name}' already exists in:`);\n              warnings.push(`  - ${relPath}`);\n              warnings.push('  Consider:');\n              warnings.push('    1. Reusing existing implementation');\n              warnings.push('    2. Extracting to shared utility');\n              warnings.push('    3. Using different name if intentionally different');\n              break;\n            }\n          }\n        } catch {\n          // Ignore file read errors\n        }\n      }\n    }\n  }\n\n  // 2. Check for copy-paste patterns\n  const copyPasteWarnings = checkCopyPastePatterns(content);\n  if (copyPasteWarnings.length > 0) {\n    warnings.push('COPY-PASTE: Repeated code blocks detected:');\n    for (const w of copyPasteWarnings.slice(0, 5)) {\n      warnings.push(`  ${w}`);\n    }\n    warnings.push('  Refactor repeated logic into functions');\n  }\n\n  // 3. Check for utility patterns\n  const utilityCheck = checkUtilityPatterns(content, filePath);\n  errors.push(...utilityCheck.errors);\n  warnings.push(...utilityCheck.warnings);\n\n  // Block on critical errors\n  if (errors.length > 0) {\n    const ctx = `Duplicate code violation in ${filePath}. See stderr for details.`;\n    return outputWithContext(ctx);\n  }\n\n  // Warn but don't block\n  if (warnings.length > 0) {\n    const ctx = `Potential code duplication detected in ${filePath}. Review warnings on stderr.`;\n    return outputWithContext(ctx);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Git utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh git functions\n */\n\nimport { execSync } from 'node:child_process';\nimport { getProjectDir } from './common.js';\n\n/**\n * Get the current git branch\n */\nexport function getCurrentBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Check if on a protected branch (dev, main, master)\n */\nexport function isProtectedBranch(branch?: string): boolean {\n  const currentBranch = branch || getCurrentBranch();\n  return ['dev', 'main', 'master'].includes(currentBranch);\n}\n\n/**\n * Get the repository root directory\n */\nexport function getRepoRoot(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git rev-parse --show-toplevel', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return dir;\n  }\n}\n\n/**\n * Check if path is inside a git repository\n */\nexport function isGitRepo(projectDir?: string): boolean {\n  const dir = projectDir || getProjectDir();\n  try {\n    execSync('git rev-parse --git-dir', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get git status (short format)\n */\nexport function getGitStatus(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    return execSync('git status --short', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Check if there are uncommitted changes\n */\nexport function hasUncommittedChanges(projectDir?: string): boolean {\n  return getGitStatus(projectDir).length > 0;\n}\n\n/**\n * Get the default branch (main or master)\n */\nexport function getDefaultBranch(projectDir?: string): string {\n  const dir = projectDir || getProjectDir();\n  try {\n    // Check if 'main' exists\n    execSync('git rev-parse --verify main', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n    return 'main';\n  } catch {\n    try {\n      // Check if 'master' exists\n      execSync('git rev-parse --verify master', {\n        cwd: dir,\n        encoding: 'utf8',\n        timeout: 5000,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      });\n      return 'master';\n    } catch {\n      return 'main'; // Default to main\n    }\n  }\n}\n\n/**\n * Extract issue number from branch name\n * Supports patterns like: issue/123-description, feature/123, fix-123\n */\nexport function extractIssueNumber(branch: string): number | null {\n  // Match common patterns\n  const patterns = [\n    /issue\\/(\\d+)/i,\n    /feature\\/(\\d+)/i,\n    /fix\\/(\\d+)/i,\n    /bug\\/(\\d+)/i,\n    /feat\\/(\\d+)/i,\n    /^(\\d+)-/,\n    /-(\\d+)$/,\n    /#(\\d+)/,\n  ];\n\n  for (const pattern of patterns) {\n    const match = branch.match(pattern);\n    if (match) {\n      return parseInt(match[1], 10);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get list of staged files (ready to be committed)\n * Returns array of file paths\n */\nexport function getStagedFiles(projectDir?: string): string[] {\n  const dir = projectDir || getProjectDir();\n  try {\n    const output = execSync('git diff --cached --name-only', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    return output ? output.split('\\n').filter((f) => f.trim()) : [];\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Analyze staged files for atomicity\n * Returns an object describing the change characteristics\n */\nexport function analyzeStagedChanges(projectDir?: string): {\n  files: string[];\n  directories: Set<string>;\n  extensions: Set<string>;\n  hasTests: boolean;\n  hasConfig: boolean;\n  hasDocs: boolean;\n  hasSource: boolean;\n} {\n  const files = getStagedFiles(projectDir);\n  const directories = new Set<string>();\n  const extensions = new Set<string>();\n  let hasTests = false;\n  let hasConfig = false;\n  let hasDocs = false;\n  let hasSource = false;\n\n  for (const file of files) {\n    // Extract top-level directory\n    const parts = file.split('/');\n    if (parts.length > 1) {\n      directories.add(parts[0]);\n      // Also track second-level for deeper analysis\n      if (parts.length > 2) {\n        directories.add(`${parts[0]}/${parts[1]}`);\n      }\n    }\n\n    // Extension\n    const ext = file.split('.').pop() || '';\n    extensions.add(ext);\n\n    // Classify file type\n    if (/\\.(test|spec)\\.\\w+$/.test(file) || /^tests?\\//.test(file) || /__tests__\\//.test(file)) {\n      hasTests = true;\n    } else if (/\\.(md|mdx|txt|rst)$/.test(file) || /^docs?\\//.test(file) || file === 'README.md') {\n      hasDocs = true;\n    } else if (\n      /\\.(json|ya?ml|toml|ini|cfg|env)$/.test(file) ||\n      /config/i.test(file) ||\n      file === 'package.json' ||\n      file === 'tsconfig.json'\n    ) {\n      hasConfig = true;\n    } else {\n      hasSource = true;\n    }\n  }\n\n  return { files, directories, extensions, hasTests, hasConfig, hasDocs, hasSource };\n}\n\n/**\n * Validate branch name format\n * Returns error message if invalid, null if valid\n */\nexport function validateBranchName(branch: string): string | null {\n  // Skip validation for protected branches\n  if (isProtectedBranch(branch)) {\n    return null;\n  }\n\n  // Valid prefixes\n  const validPrefixes = [\n    'issue/',\n    'feature/',\n    'fix/',\n    'bug/',\n    'feat/',\n    'chore/',\n    'docs/',\n    'refactor/',\n    'test/',\n    'ci/',\n    'perf/',\n    'style/',\n    'release/',\n    'hotfix/',\n  ];\n\n  const hasValidPrefix = validPrefixes.some((prefix) => branch.startsWith(prefix));\n  if (!hasValidPrefix) {\n    return `Branch name should start with a valid prefix: ${validPrefixes.join(', ')}`;\n  }\n\n  // Check for issue number in issue/ branches\n  if (branch.startsWith('issue/') && !extractIssueNumber(branch)) {\n    return 'issue/ branches should include an issue number (e.g., issue/123-description)';\n  }\n\n  return null;\n}\n", "/**\n * Eval Metrics Collector Hook\n * Runs on Stop for llm-evaluation skill\n * Collects and summarizes evaluation metrics\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\n\n/**\n * Collect and summarize LLM evaluation metrics\n */\nexport function evalMetricsCollector(_input: HookInput): HookResult {\n  const projectDir = getProjectDir();\n  const messages: string[] = [];\n\n  messages.push('::group::LLM Evaluation Summary');\n\n  // Check for evaluation results\n  const evalResultsPath = `${projectDir}/eval_results.json`;\n  if (existsSync(evalResultsPath)) {\n    messages.push('Evaluation results found:');\n    try {\n      const content = readFileSync(evalResultsPath, 'utf8');\n      const data = JSON.parse(content);\n\n      if (typeof data === 'object' && data !== null) {\n        for (const [key, value] of Object.entries(data)) {\n          if (typeof value === 'number') {\n            const formatted = Number.isInteger(value) ? value.toString() : value.toFixed(2);\n            messages.push(`  ${key}: ${formatted}`);\n          }\n        }\n      }\n    } catch {\n      // If JSON parsing fails, show first 20 lines\n      try {\n        const content = readFileSync(evalResultsPath, 'utf8');\n        const lines = content.split('\\n').slice(0, 20);\n        messages.push(...lines);\n      } catch {\n        messages.push('  (Unable to read file)');\n      }\n    }\n  }\n\n  // Check for DeepEval results\n  const deepevalDir = `${projectDir}/.deepeval`;\n  if (existsSync(deepevalDir)) {\n    messages.push('');\n    messages.push('DeepEval results directory found');\n    try {\n      const files = readdirSync(deepevalDir).slice(0, 5);\n      for (const file of files) {\n        messages.push(`  ${file}`);\n      }\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Check for RAGAS results\n  const ragasPath = `${projectDir}/ragas_results.json`;\n  if (existsSync(ragasPath)) {\n    messages.push('');\n    messages.push('RAGAS evaluation results found');\n  }\n\n  messages.push('');\n  messages.push('Evaluation complete - review metrics above');\n  messages.push('::endgroup::');\n\n  // Log to stderr for visibility during development\n  for (const msg of messages) {\n    process.stderr.write(`${msg}\\n`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Migration Validator Hook\n * Runs after Write for database-patterns skill\n * Validates alembic migration files\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync, readFileSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport { basename } from 'node:path';\n\n/**\n * Validate alembic migration files\n */\nexport function migrationValidator(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || process.env.CC_TOOL_FILE_PATH || '';\n\n  if (!filePath) return outputSilentSuccess();\n\n  // Only check migration files\n  if (!filePath.includes('alembic/versions') || !filePath.endsWith('.py')) {\n    return outputSilentSuccess();\n  }\n\n  if (!existsSync(filePath)) {\n    return outputSilentSuccess();\n  }\n\n  process.stderr.write(`::group::Migration Validation: ${basename(filePath)}\\n`);\n\n  const errors: string[] = [];\n  let content: string;\n\n  try {\n    content = readFileSync(filePath, 'utf8');\n  } catch {\n    errors.push('Cannot read migration file');\n    return outputWithContext(`Migration validation failed for ${filePath}`);\n  }\n\n  // Check for required functions\n  if (!content.includes('def upgrade')) {\n    errors.push('Missing upgrade() function in migration');\n  }\n\n  if (!content.includes('def downgrade')) {\n    errors.push('Missing downgrade() function in migration');\n  }\n\n  // Check for revision ID\n  if (!/^revision = /m.test(content)) {\n    errors.push('Missing revision ID in migration');\n  }\n\n  // Validate syntax\n  try {\n    execSync(`python3 -m py_compile \"${filePath}\"`, {\n      encoding: 'utf8',\n      timeout: 10000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    });\n  } catch {\n    errors.push('Python syntax error in migration');\n  }\n\n  // Report errors\n  if (errors.length > 0) {\n    process.stderr.write('::error::Migration validation failed\\n');\n    for (const error of errors) {\n      process.stderr.write(`  - ${error}\\n`);\n    }\n    process.stderr.write('::endgroup::\\n');\n\n    logHook('migration-validator', `BLOCKED: ${errors[0]}`);\n    const ctx = `Migration validation failed for ${filePath}. See stderr for details.`;\n    return outputWithContext(ctx);\n  }\n\n  process.stderr.write('Migration file is valid\\n');\n  process.stderr.write('::endgroup::\\n');\n\n  return outputSilentSuccess();\n}\n", "/**\n * Review Summary Generator Hook\n * Runs on Stop for code-review-playbook skill\n * Generates review summary - silent operation, logs to file\n * CC 2.1.7 Compliant\n */\n\nimport { mkdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir } from '../lib/common.js';\n\n/**\n * Generate code review summary on session stop\n */\nexport function reviewSummaryGenerator(_input: HookInput): HookResult {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/review-summary.log`;\n\n  // Ensure log directory exists\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n  const logContent = `[${timestamp}] Code Review Summary\nReview checklist:\n  [ ] All blocking issues addressed\n  [ ] Non-blocking suggestions noted\n  [ ] Tests pass\n  [ ] No security concerns\n  [ ] Documentation updated if needed\n\nConventional comment prefixes used:\n  - blocking: Must fix before merge\n  - suggestion: Consider this improvement\n  - nitpick: Minor style issue\n  - question: Needs clarification\n  - praise: Good work!\n`;\n\n  // Write to log file (silent operation)\n  try {\n    bufferWrite(logFile, `${logContent}\\n`);\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Security Summary Hook\n * Runs on Stop for security-scanning skill\n * Generates a summary of security scan completion - silent operation\n * CC 2.1.7 Compliant\n */\n\nimport { mkdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getLogDir } from '../lib/common.js';\n\n/**\n * Generate security scan summary on session stop\n */\nexport function securitySummary(_input: HookInput): HookResult {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/security-summary.log`;\n\n  // Ensure log directory exists\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n  const logContent = `[${timestamp}] Security Scan Complete\nReview findings for:\n  - Critical/High vulnerabilities (fix immediately)\n  - Dependency CVEs (update packages)\n  - Hardcoded secrets (move to env vars)\n  - OWASP Top 10 violations\n\nNext steps:\n  1. Triage findings by severity\n  2. Create issues for critical/high\n  3. Update dependencies with CVEs\n`;\n\n  // Write to log file (silent operation)\n  try {\n    bufferWrite(logFile, `${logContent}\\n`);\n  } catch {\n    // Ignore logging errors\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Test Pattern Validator Hook\n * BLOCKING: Tests must follow AAA pattern and naming conventions\n * CC 2.1.7 Compliant\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputBlock, logHook } from '../lib/common.js';\n\n/**\n * Check if file is a test file\n */\nfunction isTestFile(filePath: string): boolean {\n  if (/\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath)) return true;\n  if (/(^|\\/)test_[^/]*\\.py$/.test(filePath)) return true;\n  if (/_test\\.py$/.test(filePath)) return true;\n  return false;\n}\n\n/**\n * Validate test patterns and conventions\n */\nexport function testPatternValidator(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || '';\n  const content = input.tool_input?.content || (input as any).tool_result || '';\n\n  if (!filePath || !content) return outputSilentSuccess();\n\n  // Only validate test files\n  if (!isTestFile(filePath)) return outputSilentSuccess();\n\n  const errors: string[] = [];\n\n  // TypeScript/JavaScript test validation\n  if (/\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    // Rule: Test names must be descriptive (not too short)\n    const shortTests = content.match(/(test|it)\\(['\"][^'\"]{1,10}['\"]/g);\n    if (shortTests) {\n      if (shortTests.some((t: string) => /test[0-9]|works|^test$/i.test(t))) {\n        errors.push('Test names too short or generic. Use descriptive names:');\n        errors.push(\"  BAD:  test('test1'), test('works')\");\n        errors.push(\"  GOOD: test('should return user when ID exists')\");\n      }\n    }\n\n    // Rule: No shared mutable state without beforeEach reset\n    if (/^let [a-zA-Z_][a-zA-Z0-9_]* =/m.test(content)) {\n      if (!/beforeEach\\s*\\(\\s*(async\\s*)?\\(\\s*\\)\\s*=>/.test(content)) {\n        errors.push('Shared mutable state detected without beforeEach reset:');\n        errors.push('  Add beforeEach(() => { /* reset state */ }) to ensure test isolation');\n      }\n    }\n\n    // Rule: Avoid too many expects in single test\n    const totalExpects = (content.match(/expect\\(/g) || []).length;\n    const totalTests = (content.match(/(test|it)\\s*\\(/g) || []).length || 1;\n    const avgExpects = Math.floor(totalExpects / totalTests);\n\n    if (avgExpects > 5) {\n      errors.push(`High assertion count (avg ${avgExpects} per test):`);\n      errors.push('  Consider splitting into focused tests with 1-3 assertions each');\n      errors.push('  Or add AAA comments (// Arrange, // Act, // Assert)');\n    }\n\n    // Rule: No console.log in tests\n    if (/console\\.(log|warn|error)\\(/.test(content)) {\n      errors.push('console.log found in test file:');\n      errors.push('  Remove debugging statements before committing');\n      errors.push('  Use proper assertions instead');\n    }\n\n    // Rule: No .only() left in tests\n    if (/(test|it|describe)\\.only\\(/.test(content)) {\n      errors.push('.only() found - this skips other tests:');\n      errors.push('  Remove .only() before committing');\n    }\n\n    // Rule: No .skip() without explanation\n    if (/(test|it|describe)\\.skip\\(/.test(content)) {\n      if (!/TODO|FIXME|temporarily/i.test(content) && !(content.includes('skip') && /because/i.test(content))) {\n        errors.push('.skip() found without explanation:');\n        errors.push('  Add a comment explaining why the test is skipped');\n        errors.push(\"  Example: test.skip('reason: waiting for API fix')\");\n      }\n    }\n  }\n\n  // Python test validation\n  if (filePath.endsWith('.py')) {\n    // Rule: Test function naming must use snake_case\n    if (/def test[A-Z]/.test(content)) {\n      errors.push('Test names must use snake_case, not camelCase:');\n      errors.push('  BAD:  def testUserCreation()');\n      errors.push('  GOOD: def test_user_creation()');\n    }\n\n    // Rule: Use pytest fixtures, not unittest setUp/tearDown\n    if (/def (setUp|tearDown|setUpClass|tearDownClass)\\s*\\(/.test(content)) {\n      errors.push('Use pytest fixtures instead of unittest setUp/tearDown:');\n      errors.push('  BAD:  def setUp(self): ...');\n      errors.push('  GOOD: @pytest.fixture\\\\n        def setup_data(): ...');\n    }\n\n    // Rule: No class-level mutable defaults\n    if (content.includes('class Test') && content.includes(':')) {\n      if (/^\\s+[a-z_]+ = \\[\\]/m.test(content) || /^\\s+[a-z_]+ = \\{\\}/m.test(content)) {\n        errors.push('Class-level mutable defaults can cause test pollution:');\n        errors.push('  BAD:  class TestUser:\\\\n            items = []');\n        errors.push('  GOOD: Use @pytest.fixture to create fresh instances');\n      }\n    }\n\n    // Rule: No print statements in tests\n    if (/^\\s+print\\(/m.test(content)) {\n      errors.push('print() found in test file:');\n      errors.push('  Remove debugging statements before committing');\n      errors.push(\"  Use proper assertions or pytest's capfd fixture\");\n    }\n\n    // Rule: No @pytest.mark.skip without reason\n    if (/@pytest\\.mark\\.skip\\s*$/.test(content) || /@pytest\\.mark\\.skip\\(\\s*\\)/.test(content)) {\n      errors.push('@pytest.mark.skip without reason:');\n      errors.push(\"  Add reason: @pytest.mark.skip(reason='waiting for fix')\");\n    }\n\n    // Rule: Async tests should use pytest-asyncio\n    if (/async def test_/.test(content)) {\n      if (!/@pytest\\.mark\\.asyncio/.test(content)) {\n        errors.push('Async test found without @pytest.mark.asyncio:');\n        errors.push('  Add: @pytest.mark.asyncio');\n        errors.push('  Or set asyncio_mode = auto in pytest.ini');\n      }\n    }\n  }\n\n  // Report errors and block\n  if (errors.length > 0) {\n    logHook('test-pattern-validator', `BLOCKED: ${errors[0]}`);\n    return outputBlock(`Test pattern violations detected in ${filePath}`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Test Runner Hook\n * Runs after Write in testing skills\n * Auto-runs the test file that was just created/modified\n * CC 2.1.7 Compliant\n */\n\nimport { existsSync } from 'node:fs';\nimport { execSync, execFileSync } from 'node:child_process';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess } from '../lib/common.js';\nimport { basename, dirname } from 'node:path';\n\n/**\n * Find project root by looking for package.json\n */\nfunction findProjectRoot(startDir: string): string | null {\n  let dir = startDir;\n  while (dir && dir !== '/' && dir.length > 0) {\n    if (existsSync(`${dir}/package.json`)) {\n      return dir;\n    }\n    const parent = dirname(dir);\n    if (parent === dir) break; // reached filesystem root\n    dir = parent;\n  }\n  return null;\n}\n\n/**\n * Validate file path contains only safe characters (no shell metacharacters)\n */\nfunction isSafeFilePath(p: string): boolean {\n  // Allow alphanumeric, slashes, dots, hyphens, underscores, spaces (quoted)\n  return /^[\\w./ -]+$/.test(p);\n}\n\n/**\n * Auto-run test file that was just created/modified\n */\nexport function testRunner(input: HookInput): HookResult {\n  const filePath = input.tool_input?.file_path || process.env.CC_TOOL_FILE_PATH || '';\n\n  // Early exit if no file path or path contains shell metacharacters\n  if (!filePath || !isSafeFilePath(filePath)) return outputSilentSuccess();\n\n  // Python test files\n  if ((filePath.endsWith('.py') && /(?:^|\\/)test[^/.]*\\.py$/.test(filePath)) || /_test\\.py$/.test(filePath)) {\n    process.stderr.write(`::group::Auto-running Python test: ${basename(filePath)}\\n`);\n\n    const dir = dirname(filePath);\n\n    try {\n      // Check for poetry\n      if (existsSync(`${dir}/pyproject.toml`)) {\n        try {\n          execSync('command -v poetry', { stdio: ['pipe', 'pipe', 'pipe'] });\n          const result = execFileSync('poetry', ['run', 'pytest', filePath, '-v', '--tb=short'], {\n            cwd: dir,\n            encoding: 'utf8',\n            timeout: 60000,\n            stdio: ['pipe', 'pipe', 'pipe'],\n          });\n          const lines = result.split('\\n').slice(-30);\n          process.stderr.write(`${lines.join('\\n')}\\n`);\n        } catch {\n          // Poetry not available, try pytest directly\n        }\n      }\n\n      // Try pytest directly\n      try {\n        execSync('command -v pytest', { stdio: ['pipe', 'pipe', 'pipe'] });\n        const result = execFileSync('pytest', [filePath, '-v', '--tb=short'], {\n          cwd: dir,\n          encoding: 'utf8',\n          timeout: 60000,\n          stdio: ['pipe', 'pipe', 'pipe'],\n        });\n        const lines = result.split('\\n').slice(-30);\n        process.stderr.write(`${lines.join('\\n')}\\n`);\n      } catch {\n        process.stderr.write('pytest not found - skipping auto-run\\n');\n      }\n    } catch (error) {\n      // Test execution errors are logged but don't block\n      if (error instanceof Error) {\n        process.stderr.write(`Test execution error: ${error.message}\\n`);\n      }\n    }\n\n    process.stderr.write('::endgroup::\\n');\n  }\n\n  // TypeScript/JavaScript test files\n  if (/\\.(test|spec)\\.(ts|tsx|js|jsx)$/.test(filePath)) {\n    process.stderr.write(`::group::Auto-running TypeScript test: ${basename(filePath)}\\n`);\n\n    // Find project root\n    const projectRoot = findProjectRoot(dirname(filePath));\n\n    if (projectRoot) {\n      try {\n        const testPattern = basename(filePath)\n          .replace(/\\.[^.]+$/, '')\n          .replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n        const result = execFileSync('npm', ['test', '--', `--testPathPattern=${testPattern}`], {\n          cwd: projectRoot,\n          encoding: 'utf8',\n          timeout: 60000,\n          stdio: ['pipe', 'pipe', 'pipe'],\n        });\n        const lines = result.split('\\n').slice(-30);\n        process.stderr.write(`${lines.join('\\n')}\\n`);\n      } catch (error) {\n        // Test execution errors are logged but don't block\n        if (error instanceof Error) {\n          process.stderr.write(`Test execution error: ${error.message}\\n`);\n        }\n      }\n    }\n\n    process.stderr.write('::endgroup::\\n');\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Unified Stop Dispatcher\n * Issue #235: Hook Architecture Refactor\n *\n * Consolidates 4 async Stop hooks into a single dispatcher.\n * Reduces \"Async hook Stop completed\" messages from 4 to 1.\n *\n * CC 2.1.19 Compliant: Single async hook with internal routing\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\n\n// Import individual stop hook implementations\nimport { autoSaveContext } from './auto-save-context.js';\nimport { sessionPatterns } from './session-patterns.js';\nimport { issueWorkSummary } from './issue-work-summary.js';\nimport { calibrationPersist } from './calibration-persist.js';\nimport { sessionProfileAggregator } from './session-profile-aggregator.js';\nimport { sessionEndTracking } from './session-end-tracking.js';\n// Issue #245: GAP-002 - Wire missing tracking hooks\nimport { workflowPreferenceLearner } from './workflow-preference-learner.js';\n// Issue #243: Additional stop hooks previously run separately\nimport { taskCompletionCheck } from './task-completion-check.js';\nimport { autoRememberContinuity } from './auto-remember-continuity.js';\nimport { fullTestSuite } from './full-test-suite.js';\nimport { securityScanAggregator } from './security-scan-aggregator.js';\n\n// Import skill hooks that run at stop time\nimport { coverageCheck } from '../skill/coverage-check.js';\nimport { evidenceCollector } from '../skill/evidence-collector.js';\nimport { coverageThresholdGate } from '../skill/coverage-threshold-gate.js';\nimport { crossInstanceTestValidator } from '../skill/cross-instance-test-validator.js';\nimport { diPatternEnforcer } from '../skill/di-pattern-enforcer.js';\nimport { duplicateCodeDetector } from '../skill/duplicate-code-detector.js';\nimport { evalMetricsCollector } from '../skill/eval-metrics-collector.js';\nimport { migrationValidator } from '../skill/migration-validator.js';\nimport { reviewSummaryGenerator } from '../skill/review-summary-generator.js';\nimport { securitySummary } from '../skill/security-summary.js';\nimport { testPatternValidator } from '../skill/test-pattern-validator.js';\nimport { testRunner } from '../skill/test-runner.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult | Promise<HookResult>;\n\ninterface HookConfig {\n  name: string;\n  fn: HookFn;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Registry\n// -----------------------------------------------------------------------------\n\n/**\n * Registry of all Stop hooks consolidated into dispatcher\n * Issue #243: Fire-and-forget pattern - all 21 hooks run in background\n * Issue #245: Added graph-queue-sync (GAP-001) and workflow-preference-learner (GAP-002)\n */\nconst HOOKS: HookConfig[] = [\n  // --- Core session hooks ---\n  { name: 'auto-save-context', fn: autoSaveContext },\n  { name: 'session-patterns', fn: sessionPatterns },\n  { name: 'issue-work-summary', fn: issueWorkSummary },\n  { name: 'calibration-persist', fn: calibrationPersist },\n  { name: 'session-profile-aggregator', fn: sessionProfileAggregator },\n  { name: 'session-end-tracking', fn: sessionEndTracking },\n\n  // --- Memory sync hooks ---\n  { name: 'workflow-preference-learner', fn: workflowPreferenceLearner },\n\n  // --- Instance management hooks ---\n  { name: 'task-completion-check', fn: taskCompletionCheck },\n\n  // --- Analysis hooks ---\n  { name: 'auto-remember-continuity', fn: autoRememberContinuity },\n  { name: 'security-scan-aggregator', fn: securityScanAggregator },\n\n  // --- Skill validation hooks (run at stop time) ---\n  { name: 'coverage-check', fn: coverageCheck },\n  { name: 'evidence-collector', fn: evidenceCollector },\n  { name: 'coverage-threshold-gate', fn: coverageThresholdGate },\n  { name: 'cross-instance-test-validator', fn: crossInstanceTestValidator },\n  { name: 'di-pattern-enforcer', fn: diPatternEnforcer },\n  { name: 'duplicate-code-detector', fn: duplicateCodeDetector },\n  { name: 'eval-metrics-collector', fn: evalMetricsCollector },\n  { name: 'migration-validator', fn: migrationValidator },\n  { name: 'review-summary-generator', fn: reviewSummaryGenerator },\n  { name: 'security-summary', fn: securitySummary },\n  { name: 'test-pattern-validator', fn: testPatternValidator },\n  { name: 'test-runner', fn: testRunner },\n\n  // --- Heavy analysis hooks (run last, optional) ---\n  { name: 'full-test-suite', fn: fullTestSuite },\n];\n\n/** Exposed for registry wiring tests */\nexport const registeredHookNames = () => HOOKS.map(h => h.name);\n\n// -----------------------------------------------------------------------------\n// Dispatcher Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Unified dispatcher that runs all Stop hooks in parallel\n */\nexport async function unifiedStopDispatcher(input: HookInput): Promise<HookResult> {\n  // Prevent infinite re-entry (CC 2.1.25: stop_hook_active)\n  if (input.stop_hook_active) {\n    logHook('stop-dispatcher', 'Skipping: stop_hook_active=true (re-entry prevention)');\n    return outputSilentSuccess();\n  }\n\n  // CC 2.1.49: Log last assistant message snippet for audit trail\n  if (input.last_assistant_message) {\n    const snippet = input.last_assistant_message.substring(0, 200);\n    logHook('stop-dispatcher', `last_assistant_message (first 200): ${snippet}`);\n  }\n\n  // Run all hooks in parallel\n  const results = await Promise.allSettled(\n    HOOKS.map(async hook => {\n      try {\n        const result = hook.fn(input);\n        if (result instanceof Promise) {\n          await result;\n        }\n        return { hook: hook.name, status: 'success' };\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        logHook('stop-dispatcher', `${hook.name} failed: ${message}`);\n        return { hook: hook.name, status: 'error', message };\n      }\n    })\n  );\n\n  // Log summary for debugging (only errors)\n  const errors = results.filter(\n    r => r.status === 'rejected' || (r.status === 'fulfilled' && r.value.status === 'error')\n  );\n\n  if (errors.length > 0) {\n    logHook('stop-dispatcher', `${errors.length}/${HOOKS.length} hooks had errors`);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Stop Hooks Entry Point\n *\n * Hooks that run when conversation stops (Stop event)\n * Bundle: stop.mjs (~25 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\n\n// Re-export calibration engine for stop hooks\nexport * from '../lib/calibration-engine.js';\n\n// Stop hooks (9)\nimport { autoRememberContinuity } from '../stop/auto-remember-continuity.js';\nimport { autoSaveContext } from '../stop/auto-save-context.js';\nimport { fullTestSuite } from '../stop/full-test-suite.js';\nimport { issueWorkSummary } from '../stop/issue-work-summary.js';\nimport { securityScanAggregator } from '../stop/security-scan-aggregator.js';\nimport { sessionPatterns } from '../stop/session-patterns.js';\nimport { taskCompletionCheck } from '../stop/task-completion-check.js';\nimport { calibrationPersist } from '../stop/calibration-persist.js';\nimport { unifiedStopDispatcher } from '../stop/unified-dispatcher.js';\n\n// Intelligent Decision Capture System\nimport { workflowPreferenceLearner } from '../stop/workflow-preference-learner.js';\nimport { sessionEndTracking } from '../stop/session-end-tracking.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Stop hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'stop/auto-remember-continuity': autoRememberContinuity,\n  'stop/auto-save-context': autoSaveContext,\n  'stop/full-test-suite': fullTestSuite,\n  'stop/issue-work-summary': issueWorkSummary,\n  'stop/security-scan-aggregator': securityScanAggregator,\n  'stop/session-patterns': sessionPatterns,\n  'stop/task-completion-check': taskCompletionCheck,\n  'stop/calibration-persist': calibrationPersist,\n  'stop/unified-dispatcher': unifiedStopDispatcher,\n  // Intelligent Decision Capture System\n  'stop/workflow-preference-learner': workflowPreferenceLearner,\n  'stop/session-end-tracking': sessionEndTracking,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "appendFileSync", "mkdirSync", "dirname", "buffer", "flushing", "handlersRegistered", "bufferWrite", "filePath", "content", "ensureHandlers", "flush", "grouped", "entry", "arr", "path", "contents", "ensureHandlers", "handlersRegistered", "flush", "execSync", "os", "path", "getHomeDir", "getTempDir", "getProjectDir", "getPluginRoot", "getLogDir", "getMetricsFile", "path", "getTempDir", "getSessionTempDir", "sessionId", "path", "getTempDir", "getActiveTodosFile", "joinPath", "path", "pathSeparator", "execSync", "createHash", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "basename", "MAX_PROJECT_LENGTH", "MAX_BRANCH_LENGTH", "SAFE_CHARS", "getProjectName", "projectDir", "dir", "name", "sanitizeName", "getGitBranchForSession", "branch", "sanitized", "formatDateComponent", "date", "d", "month", "day", "formatTimeComponent", "hours", "minutes", "generateShortHash", "entropy", "maxLength", "generateSmartSessionId", "project", "dateStr", "timeStr", "hash", "getCachedSessionId", "cachePath", "data", "age", "maxAge", "cacheSessionId", "sessionId", "instanceDir", "getOrGenerateSessionId", "cached", "newId", "getLogDir", "getProjectDir", "getPluginRoot", "getEnvFile", "getSessionId", "getOrGenerateSessionId", "getCachedBranch", "projectDir", "branch", "execSync", "getLogLevel", "normalizeLineEndings", "content", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputWithNotification", "userMessage", "claudeContext", "result", "outputAllowWithContext", "systemMessage", "outputError", "message", "outputWarning", "outputStderrWarning", "outputDeny", "outputWithUpdatedInput", "updatedInput", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "existsSync", "statSync", "rotated", "renameSync", "ensureDir", "dir", "mkdirSync", "logHook", "hookName", "logDir", "timestamp", "bufferWrite", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "extractContext", "estimateTokenCount", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "lineContainsAll", "terms", "line", "t", "lineContainsAllCI", "lower", "normalizeCommand", "command", "escapeRegex", "str", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MIN_SAMPLES_FOR_ADJUSTMENT", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "DECAY_FACTOR", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "keyword", "existing", "a", "applyDecay", "now", "dayMs", "adj", "age", "records", "successful", "r", "avgConf", "sum", "agentStats", "stat", "b", "getAdjustments", "getAgentSuccessRate", "agentRecords", "getCalibrationStats", "hasMinimalCalibrationData", "basename", "autoRememberContinuity", "input", "logHook", "projectDir", "getProjectDir", "_promptMsg", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "autoSaveContext", "input", "logHook", "sessionDir", "getProjectDir", "sessionState", "existsSync", "mkdirSync", "timestamp", "content", "readFileSync", "state", "updated", "writeFileSync", "error", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "shouldRunTests", "projectDir", "lastRunFile", "existsSync", "result", "execSync", "logHook", "runTests", "_logFile", "exitCode", "readFileSync", "cmd", "fullTestSuite", "input", "getProjectDir", "logDir", "mkdirSync", "logFile", "outputSilentSuccess", "writeFileSync", "existsSync", "readFileSync", "unlinkSync", "rmdirSync", "execSync", "SAFE_ARG_RE", "assertSafeShellArg", "arg", "label", "assertSafeIssueNumber", "num", "isGhAvailable", "execSync", "isGitHubRepo", "projectDir", "generateComment", "_issueNum", "data", "sessionId", "commits", "commitsSection", "c", "tasksSection", "t", "postComment", "issueNum", "comment", "safeIssueNum", "issueWorkSummary", "input", "logHook", "getProjectDir", "getSessionId", "safeSessionId", "sessionDir", "getSessionTempDir", "progressFile", "existsSync", "outputSilentSuccess", "progressJson", "readFileSync", "issues", "postedCount", "issueData", "assertSafeIssueNumber", "unlinkSync", "rmdirSync", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "readdirSync", "execSync", "runNpmAudit", "projectDir", "resultsDir", "existsSync", "logHook", "execSync", "error", "writeFileSync", "result", "runPipAudit", "parsed", "runSemgrep", "highSeverity", "r", "runBandit", "safeResultsDir", "assertSafeShellArg", "runSecretScan", "secretPatterns", "secretsFound", "findings", "extensions", "scanDir", "dir", "entries", "readdirSync", "entry", "fullPath", "ext", "content", "readFileSync", "aggregateResults", "results", "totalCritical", "totalHigh", "scansCompleted", "f", "report", "securityScanAggregator", "input", "getProjectDir", "mkdirSync", "outputSilentSuccess", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "createHash", "os", "IDENTITY_CONFIG_FILE", "SALT", "DEFAULT_PRIVACY", "cachedIdentity", "cachedPrivacy", "generateAnonymousId", "input", "createHash", "SALT", "getMachineId", "readUserConfig", "projectDir", "configPath", "IDENTITY_CONFIG_FILE", "existsSync", "content", "readFileSync", "error", "logHook", "getGitIdentity", "result", "execSync", "getEnvIdentity", "resolveUserIdentity", "cachedIdentity", "dir", "getProjectDir", "machineId", "config", "git", "env", "userId", "anonId", "getPrivacySettings", "cachedPrivacy", "DEFAULT_PRIVACY", "canShare", "dataType", "scope", "privacy", "getIdentityContext", "identity", "resolveUserIdentity", "getSessionId", "SESSION_ID_PATTERN", "isValidSessionId", "sessionId", "getSessionDir", "projectDir", "sid", "getSessionId", "pDir", "getProjectDir", "getEventsPath", "ensureSessionDir", "dir", "existsSync", "mkdirSync", "eventCounter", "counterLoaded", "counterDirty", "lastPersistTime", "PERSIST_INTERVAL", "getCounterPath", "loadPersistedCounter", "counterPath", "data", "readFileSync", "logHook", "persistCounter", "now", "writeFileSync", "generateEventId", "trackEvent", "eventType", "name", "options", "event", "generateEventId", "getIdentityContext", "sanitizeForStorage", "truncate", "ensureSessionDir", "eventsPath", "getEventsPath", "bufferWrite", "logHook", "error", "trackSessionEnd", "trackEvent", "loadSessionEvents", "sessionId", "eventsPath", "getEventsPath", "existsSync", "readFileSync", "line", "error", "logHook", "generateSessionSummary", "events", "identity", "getIdentityContext", "eventCounts", "skillsUsed", "agentsSpawned", "hooksTriggered", "startTime", "endTime", "event", "durationMs", "truncate", "str", "maxLen", "sanitizeForStorage", "obj", "sanitized", "sensitiveKeys", "key", "value", "s", "TOOL_CATEGORIES", "getToolCategory", "toolName", "extractToolSequence", "metricsFile", "existsSync", "tools", "readFileSync", "a", "b", "tool", "getToolCount", "sum", "count", "detectWorkflowType", "detectDominantLanguage", "_tools", "initWorkflowProfile", "profilePath", "updateWorkflowProfile", "workflowType", "dominantLang", "toolCount", "toolSequence", "profile", "timestamp", "seqSet", "mkdirSync", "writeFileSync", "initPatternsFile", "patternsPath", "aggregateToolPreferences", "usageByCategory", "toolEvents", "loadSessionEvents", "e", "event", "toolName", "category", "getToolCategory", "preferences", "sorted", "updateToolPreferences", "projectDir", "logHook", "prefsPath", "existingPrefs", "prefCount", "mergePatterns", "queuePath", "queue", "queueCount", "existing", "now", "allPatterns", "patternMap", "p", "mergedPatterns", "successes", "failures", "categories", "updated", "sessionPatterns", "input", "getProjectDir", "getMetricsFile", "workflowProfile", "outputSilentSuccess", "existsSync", "readFileSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadRegistry", "file", "readFileSync", "saveRegistry", "registry", "writeFileSync", "err", "logHook", "formatTaskDeleteForClaude", "taskId", "reason", "getOrphanedTasks", "registry", "loadRegistry", "failedIds", "t", "id", "cleanupOldTasks", "maxAgeMs", "registry", "loadRegistry", "cutoff", "t", "p", "saveRegistry", "taskCompletionCheck", "input", "logHook", "warnings", "projectDir", "getProjectDir", "sessionId", "getSessionId", "registryFile", "existsSync", "inProgress", "readFileSync", "t", "error", "orphans", "getOrphanedTasks", "orphanInstructions", "orphan", "formatTaskDeleteForClaude", "todosFile", "getActiveTodosFile", "context", "w", "outputWithContext", "outputSilentSuccess", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "getConfigFile", "existsSync", "data", "readFileSync", "clearSessionState", "stateFile", "getStateFile", "existsSync", "unlinkSync", "logHook", "cleanupOldStates", "dir", "getStateDir", "readdirSync", "statSync", "files", "f", "a", "b", "file", "MAX_RECORD_AGE_MS", "cleanupOldRecords", "data", "cutoff", "before", "after", "logHook", "generateSummary", "stats", "topAgents", "a", "calibrationPersist", "_input", "loadConfig", "clearSessionState", "cleanupOldStates", "outputSilentSuccess", "loadCalibrationData", "applyDecay", "saveCalibrationData", "summary", "err", "cleanupOldTasks", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "basename", "getFlowFilePath", "sessionId", "join", "getProjectDir", "getCompletedFlowsPath", "loadDecisionFlow", "filePath", "existsSync", "content", "readFileSync", "err", "logHook", "archiveFlow", "flow", "archivePath", "getCompletedFlowsPath", "dir", "dirname", "existsSync", "mkdirSync", "line", "bufferWrite", "err", "logHook", "inferWorkflowPattern", "actions", "counts", "action", "testIndices", "a", "i", "writeIndices", "findConsecutiveRun", "countAlternations", "lastTest", "category", "maxRun", "currentRun", "categoryA", "categoriesB", "alternations", "lastWasA", "isA", "isB", "calculateStats", "successes", "analyzeDecisionFlow", "sessionId", "flow", "loadDecisionFlow", "inferWorkflowPattern", "calculateStats", "completeDecisionFlow", "archived", "archiveFlow", "logHook", "WORKFLOW_PATTERN_DESCRIPTIONS", "convertFlowPattern", "flowPattern", "existingPatterns", "existing", "p", "frequency", "PROFILE_VERSION", "MIGRATIONS", "profile", "migrateProfileSchema", "currentVersion", "PROFILE_VERSION", "migrationFn", "logHook", "getHomeDir", "getOrchestKitDir", "join", "getUserProfileDir", "userId", "sanitizedUserId", "getUserProfilePath", "getLegacyProfilePath", "getProjectDir", "migrateProfileIfNeeded", "legacyPath", "newPath", "existsSync", "newDir", "dirname", "mkdirSync", "content", "readFileSync", "writeFileSync", "sanitizedId", "error", "createEmptyProfile", "identity", "resolveUserIdentity", "now", "loadUserProfile", "uid", "profilePath", "rawProfile", "saveUserProfile", "profileDir", "updateUsageStats", "existing", "success", "durationMs", "newCount", "newSuccessRate", "newAvgDuration", "aggregateSession", "summary", "skill", "agent", "flow", "analyzeDecisionFlow", "patternName", "existingIndex", "p", "newPattern", "convertFlowPattern", "MAX_AGGREGATED_SESSIONS", "exportForGlobal", "profile", "anonDecisions", "d", "project", "rest", "sessionProfileAggregator", "_input", "identity", "resolveUserIdentity", "logHook", "summary", "generateSessionSummary", "outputSilentSuccess", "profile", "loadUserProfile", "updatedProfile", "aggregateSession", "saveUserProfile", "getPrivacySettings", "canShare", "generalizableDecisions", "exportForGlobal", "d", "error", "sessionEndTracking", "_input", "trackSessionEnd", "logHook", "outputSilentSuccess", "error", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "dirname", "HOOK_NAME", "MIN_ACTIONS_FOR_PATTERN", "getWorkflowPreferencesPath", "getProjectDir", "loadWorkflowPreferences", "filePath", "createEmptyWorkflowPreferences", "content", "saveWorkflowPreferences", "data", "dir", "err", "logHook", "patterns", "pattern_counts", "pattern_success_rates", "pattern", "calculateWorkflowPreferences", "preferences", "timestamp", "count", "successRates", "avgSuccessRate", "a", "b", "updateWorkflowPreferences", "flow", "successRate", "workflowPreferenceLearner", "input", "sessionId", "getSessionId", "analyzeDecisionFlow", "outputSilentSuccess", "completeDecisionFlow", "topPref", "existsSync", "mkdirSync", "execSync", "coverageCheck", "_input", "projectDir", "getProjectDir", "logDir", "getLogDir", "logFile", "threshold", "mkdirSync", "logLines", "timestamp", "coverageFile", "coverageXml", "existsSync", "totalLine", "execSync", "line", "match", "coverage", "coverageDir", "summaryFile", "bufferWrite", "outputSilentSuccess", "existsSync", "mkdirSync", "readdirSync", "evidenceCollector", "_input", "logDir", "getLogDir", "projectDir", "getProjectDir", "logFile", "mkdirSync", "timestamp", "logLines", "lastExitCode", "existsSync", "testResultsDir", "files", "readdirSync", "file", "bufferWrite", "outputSilentSuccess", "existsSync", "readFileSync", "COVERAGE_PATHS", "parseCoverage", "filePath", "content", "data", "coverageThresholdGate", "_input", "projectDir", "getProjectDir", "threshold", "coverageFile", "coverageContent", "path", "fullPath", "existsSync", "readFileSync", "outputSilentSuccess", "coverage", "reason", "outputBlock", "existsSync", "readFileSync", "basename", "dirname", "isTestFile", "filePath", "findTestFile", "implFile", "base", "ext", "patterns", "pattern", "existsSync", "dir", "baseFilename", "testDirPatterns", "testFilename", "parentDir", "extractTestableUnits", "content", "units", "matches", "match", "name", "lines", "line", "crossInstanceTestValidator", "input", "outputSilentSuccess", "errors", "warnings", "testFile", "testableUnits", "testContent", "readFileSync", "untestedUnits", "unit", "fname", "outputBlock", "warningContext", "outputWithContext", "basename", "diPatternEnforcer", "input", "filePath", "content", "outputSilentSuccess", "filename", "errors", "serviceIdx", "className", "last", "p", "repoIdx", "syncPattern", "lines", "line", "logHook", "ctx", "outputWithContext", "readFileSync", "readdirSync", "execSync", "getRepoRoot", "projectDir", "dir", "getProjectDir", "execSync", "extractSignatures", "content", "filePath", "signatures", "matches", "lines", "line", "match", "findCodeFiles", "dir", "pattern", "files", "ignoreDirs", "walk", "currentDir", "entries", "readdirSync", "entry", "fullPath", "checkCopyPastePatterns", "warnings", "prev", "count", "startLine", "checkUtilityPatterns", "errors", "fetchCount", "validationCount", "jsonCount", "envCount", "duplicateCodeDetector", "input", "outputSilentSuccess", "projectRoot", "getRepoRoot", "getProjectDir", "codeFiles", "signature", "name", "codeFile", "fileContent", "readFileSync", "relPath", "copyPasteWarnings", "w", "utilityCheck", "ctx", "outputWithContext", "existsSync", "readFileSync", "readdirSync", "evalMetricsCollector", "_input", "projectDir", "getProjectDir", "messages", "evalResultsPath", "existsSync", "content", "readFileSync", "data", "key", "value", "formatted", "lines", "deepevalDir", "files", "readdirSync", "file", "ragasPath", "msg", "outputSilentSuccess", "existsSync", "readFileSync", "execSync", "basename", "migrationValidator", "input", "filePath", "outputSilentSuccess", "existsSync", "errors", "content", "readFileSync", "outputWithContext", "execSync", "error", "logHook", "ctx", "mkdirSync", "reviewSummaryGenerator", "_input", "logDir", "getLogDir", "logFile", "mkdirSync", "logContent", "bufferWrite", "outputSilentSuccess", "mkdirSync", "securitySummary", "_input", "logDir", "getLogDir", "logFile", "mkdirSync", "logContent", "bufferWrite", "outputSilentSuccess", "isTestFile", "filePath", "testPatternValidator", "input", "content", "outputSilentSuccess", "errors", "shortTests", "t", "totalExpects", "totalTests", "avgExpects", "logHook", "outputBlock", "existsSync", "execSync", "execFileSync", "basename", "dirname", "findProjectRoot", "startDir", "dir", "existsSync", "parent", "isSafeFilePath", "p", "testRunner", "input", "filePath", "outputSilentSuccess", "execSync", "lines", "execFileSync", "error", "projectRoot", "testPattern", "HOOKS", "autoSaveContext", "sessionPatterns", "issueWorkSummary", "calibrationPersist", "sessionProfileAggregator", "sessionEndTracking", "workflowPreferenceLearner", "taskCompletionCheck", "autoRememberContinuity", "securityScanAggregator", "coverageCheck", "evidenceCollector", "coverageThresholdGate", "crossInstanceTestValidator", "diPatternEnforcer", "duplicateCodeDetector", "evalMetricsCollector", "migrationValidator", "reviewSummaryGenerator", "securitySummary", "testPatternValidator", "testRunner", "fullTestSuite", "unifiedStopDispatcher", "input", "logHook", "outputSilentSuccess", "snippet", "errors", "HOOKS", "hook", "result", "error", "message", "r", "hooks", "autoRememberContinuity", "autoSaveContext", "fullTestSuite", "issueWorkSummary", "securityScanAggregator", "sessionPatterns", "taskCompletionCheck", "calibrationPersist", "unifiedStopDispatcher", "workflowPreferenceLearner", "sessionEndTracking", "getHook", "name", "listHooks"]
}
