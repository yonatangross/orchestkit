{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/analytics-buffer.ts", "../src/lib/paths.ts", "../src/lib/session-id-generator.ts", "../src/lib/orchestration-types.ts", "../src/lib/orchestration-state.ts", "../src/lib/retry-manager.ts", "../src/lib/calibration-engine.ts", "../src/subagent-start/graph-memory-inject.ts", "../src/subagent-start/context-gate.ts", "../src/subagent-start/subagent-context-stager.ts", "../src/subagent-start/subagent-validator.ts", "../src/subagent-start/model-cost-advisor.ts", "../src/subagent-start/issue-context-injector.ts", "../src/subagent-start/unified-dispatcher.ts", "../src/subagent-stop/agent-memory-store.ts", "../src/subagent-stop/auto-spawn-quality.ts", "../src/subagent-stop/context-publisher.ts", "../src/subagent-stop/feedback-loop.ts", "../src/lib/task-integration.ts", "../src/lib/agent-teams.ts", "../src/lib/multi-agent-coordinator.ts", "../src/subagent-stop/handoff-preparer.ts", "../src/subagent-stop/multi-claude-verifier.ts", "../src/subagent-stop/output-validator.ts", "../src/subagent-stop/subagent-quality-gate.ts", "../src/subagent-stop/retry-handler.ts", "../src/lib/session-tracker.ts", "../src/lib/user-identity.ts", "../src/lib/analytics.ts", "../src/subagent-stop/unified-dispatcher.ts", "../src/subagent-stop/sync-subagent-stop-dispatcher.ts", "../src/entries/subagent.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PostToolUseFailure'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification'\n  | 'PreCompact'\n  | 'TeammateIdle'\n  | 'TaskCompleted'\n  | 'WorktreeCreate'\n  | 'WorktreeRemove'\n  | 'ConfigChange';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** Whether a stop hook is currently active (prevents re-entry) */\n  stop_hook_active?: boolean;\n  /** Permission mode (CC 2.1.25: dontAsk mode makes quality gates warn-only) */\n  permissionMode?: 'default' | 'acceptEdits' | 'dontAsk';\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // TeammateIdle specific fields (CC 2.1.33)\n  /** Teammate agent ID */\n  teammate_id?: string;\n  /** Teammate agent type */\n  teammate_type?: string;\n  /** How long the teammate has been idle (ms) */\n  idle_duration_ms?: number;\n\n  // TaskCompleted specific fields (CC 2.1.33)\n  /** Completed task ID */\n  task_id?: string;\n  /** Task subject */\n  task_subject?: string;\n  /** Task result status */\n  task_status?: string;\n  /** Token count consumed by the task (CC 2.1.30) */\n  token_count?: number;\n  /** Number of tool invocations in the task (CC 2.1.30) */\n  tool_uses?: number;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n\n  // Stop/SubagentStop specific fields (CC 2.1.47)\n  /** The final assistant message text (Stop and SubagentStop, CC 2.1.47+) */\n  last_assistant_message?: string;\n\n  // Workspace/statusline fields (CC 2.1.47)\n  /** Directories added via /add-dir, from statusline workspace section (CC 2.1.47+) */\n  added_dirs?: string[];\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PostToolUseFailure' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n  /** Modified tool input (CC 2.1.25: canonical way to modify tool inputs) */\n  updatedInput?: Record<string, unknown>;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { existsSync, statSync, renameSync, mkdirSync, readSync, readFileSync, writeFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\nimport {\n  getLogDir as getLogDirFromPaths,\n  getProjectDir as getProjectDirFromPaths,\n  getPluginRoot as getPluginRootFromPaths,\n} from './paths.js';\nimport { getOrGenerateSessionId } from './session-id-generator.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// Re-export from paths.ts for cross-platform compatibility\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getLogDir(): string {\n  return getLogDirFromPaths();\n}\n\n/**\n * Get the project directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getProjectDir(): string {\n  return getProjectDirFromPaths();\n}\n\n/**\n * Get the plugin root directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getPluginRoot(): string {\n  return getPluginRootFromPaths();\n}\n\n/**\n * Get the environment file path (CC 2.1.25: CLAUDE_ENV_FILE support)\n * Falls back to .instance_env for backward compatibility\n */\nexport function getEnvFile(): string {\n  if (process.env.CLAUDE_ENV_FILE) {\n    return process.env.CLAUDE_ENV_FILE;\n  }\n  // Fallback to legacy .instance_env\n  const pluginRoot = getPluginRoot();\n  return `${pluginRoot}/.claude/.instance_env`;\n}\n\n/**\n * Get the session ID\n *\n * Resolution order:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime - preferred)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate smart session ID: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n *\n * Example smart ID: \"orchestkit-main-0130-1745-a3f2\"\n *\n * The old fallback format \"fallback-{pid}-{timestamp}\" was confusing and unhelpful.\n * Smart IDs are human-readable, showing project, branch, and time context.\n */\nexport function getSessionId(): string {\n  return getOrGenerateSessionId();\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Normalize line endings from CRLF to LF for cross-platform compatibility.\n * Windows uses \\r\\n (CRLF) while Unix uses \\n (LF).\n * This is critical for parsing YAML frontmatter where we match '---' exactly.\n */\nexport function normalizeLineEndings(content: string): string {\n  return content.replace(/\\r\\n/g, '\\n');\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with user notification + Claude context (CC 2.1.9+)\n * Issue #278: Dual-channel output for three-tier UX\n *\n * @param userMessage - Brief message shown to user via systemMessage (optional)\n * @param claudeContext - Full context for Claude via additionalContext (optional)\n * @returns HookResult with appropriate channels set\n *\n * Usage:\n * - Both set: User sees notification, Claude gets context\n * - Only claudeContext: Silent injection (Claude-only)\n * - Only userMessage: User notification without context\n */\nexport function outputWithNotification(\n  userMessage: string | undefined,\n  claudeContext: string | undefined\n): HookResult {\n  const result: HookResult = {\n    continue: true,\n    suppressOutput: true,\n  };\n\n  if (userMessage) {\n    result.systemMessage = userMessage;\n  }\n\n  if (claudeContext) {\n    result.hookSpecificOutput = {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: claudeContext,\n    };\n  }\n\n  return result;\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message via JSON stdout \u2014 visible to both user and Claude (CC 2.1.7+).\n * Use this when Claude needs to see and act on the warning (e.g., cost advice, quality gates).\n * For user-only warnings where Claude should NOT see the message, use outputStderrWarning.\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output warning via stderr + exit(2) \u2014 visible to user only, Claude does NOT see it (CC 2.1.39).\n * Use this for informational warnings that should not influence Claude's behavior\n * (e.g., deprecation notices, non-actionable advisories).\n *\n * IMPORTANT: This function calls process.exit(2) and never returns.\n * Do NOT use inside unified dispatchers \u2014 it will crash the dispatcher process.\n * Only use in standalone hook entry points.\n */\nexport function outputStderrWarning(message: string): never {\n  process.stderr.write(`\\u26a0 ${message}\\n`);\n  process.exit(2);\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with updatedInput - modifies tool input before execution (CC 2.1.25)\n * Canonical way to modify tool inputs from PreToolUse hooks\n */\nexport function outputWithUpdatedInput(updatedInput: Record<string, unknown>): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      updatedInput,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    bufferWrite(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    bufferWrite(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction (shared by all sync dispatchers)\n// -----------------------------------------------------------------------------\n\n/**\n * Extract additionalContext from a hook result.\n * Handles both the correct hookSpecificOutput.additionalContext format\n * and the legacy bare systemMessage format.\n *\n * Issue #682: Deduplicated from 5 dispatchers into shared utility.\n */\nexport function extractContext(result: HookResult): string | null {\n  // Standard format: hookSpecificOutput.additionalContext\n  if (result.hookSpecificOutput?.additionalContext) {\n    return result.hookSpecificOutput.additionalContext as string;\n  }\n\n  // Legacy format: bare systemMessage (antipattern-detector bug)\n  if (result.systemMessage && typeof result.systemMessage === 'string') {\n    return result.systemMessage;\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker?.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Rules File Utilities (Token Reduction \u2014 materialize to .claude/rules/)\n// -----------------------------------------------------------------------------\n\n/**\n * FNV-1a 32-bit hash \u2014 fast, non-cryptographic hash for delta detection.\n * Used to skip writing rules files when content hasn't changed.\n */\nexport function fnv1aHash(str: string): string {\n  let hash = 0x811c9dc5; // FNV offset basis\n  for (let i = 0; i < str.length; i++) {\n    hash ^= str.charCodeAt(i);\n    hash = Math.imul(hash, 0x01000193); // FNV prime\n  }\n  return (hash >>> 0).toString(16).padStart(8, '0');\n}\n\n/**\n * Write a rules file atomically with hash-guard skip.\n * Skips write if file content hash is unchanged (avoids unnecessary I/O).\n *\n * @param rulesDir - Directory to write to (e.g., ~/.claude/rules/ or {project}/.claude/rules/)\n * @param filename - File name (e.g., 'user-profile.md')\n * @param content - Content to write\n * @param hookName - Hook name for logging\n * @returns true if file was written, false if skipped (unchanged)\n */\nexport function writeRulesFile(\n  rulesDir: string,\n  filename: string,\n  content: string,\n  hookName: string,\n): boolean {\n  const filePath = join(rulesDir, filename);\n\n  // Hash-guard: skip write if content unchanged\n  if (existsSync(filePath)) {\n    try {\n      const existing = readFileSync(filePath, 'utf8');\n      if (fnv1aHash(existing) === fnv1aHash(content)) {\n        logHook(hookName, `Rules file ${filename} unchanged, skipping write`);\n        return false;\n      }\n    } catch {\n      // Can't read existing \u2014 proceed with write\n    }\n  }\n\n  // Ensure directory exists\n  if (!existsSync(rulesDir)) {\n    mkdirSync(rulesDir, { recursive: true });\n  }\n\n  writeFileSync(filePath, content, 'utf8');\n  logHook(hookName, `Wrote rules file: ${filePath}`);\n  return true;\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// ReDoS-Safe String Matching\n// -----------------------------------------------------------------------------\n\n/**\n * Check if any single line contains all specified substrings (ReDoS-safe O(n)).\n * Use instead of polynomial regexes like /A.*B.*C/.test(content).\n */\nexport function lineContainsAll(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => terms.every(t => line.includes(t)));\n}\n\n/**\n * Check if any single line contains all specified substrings (case-insensitive, ReDoS-safe O(n)).\n */\nexport function lineContainsAllCI(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => {\n    const lower = line.toLowerCase();\n    return terms.every(t => lower.includes(t.toLowerCase()));\n  });\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Analytics Write Buffer \u2014 Batches appendFileSync calls and flushes on exit\n *\n * Reduces per-hook I/O overhead by buffering analytics/metrics/log writes\n * and flushing them in a single batch per file path. Registered process\n * handlers ensure data is written before the process terminates.\n *\n * Issue #688: Buffer analytics writes and flush on process exit\n */\n\nimport { appendFileSync, mkdirSync } from 'node:fs';\nimport { dirname } from 'node:path';\n\ninterface BufferEntry {\n  filePath: string;\n  content: string;\n}\n\nconst buffer: BufferEntry[] = [];\nlet flushing = false;\nlet handlersRegistered = false;\n\n/**\n * Queue an analytics/log write for batched flushing.\n * Call this instead of appendFileSync for non-essential writes.\n */\nexport function bufferWrite(filePath: string, content: string): void {\n  buffer.push({ filePath, content });\n  ensureHandlers();\n}\n\n/**\n * Flush all buffered writes to disk immediately.\n * Groups entries by file path to minimize syscalls.\n */\nexport function flush(): void {\n  if (flushing || buffer.length === 0) return;\n  flushing = true;\n\n  // Group by filePath to write each file once\n  const grouped = new Map<string, string[]>();\n  for (const entry of buffer) {\n    const arr = grouped.get(entry.filePath);\n    if (arr) {\n      arr.push(entry.content);\n    } else {\n      grouped.set(entry.filePath, [entry.content]);\n    }\n  }\n\n  for (const [path, contents] of grouped) {\n    try {\n      mkdirSync(dirname(path), { recursive: true });\n      appendFileSync(path, contents.join(''));\n    } catch {\n      // Ignore flush errors \u2014 never block process exit\n    }\n  }\n\n  buffer.length = 0;\n  flushing = false;\n}\n\n/** Number of entries currently buffered (for testing) */\nexport function pendingCount(): number {\n  return buffer.length;\n}\n\n/** Clear buffer without writing (for testing) */\nexport function _resetForTesting(): void {\n  buffer.length = 0;\n  flushing = false;\n}\n\nfunction ensureHandlers(): void {\n  if (handlersRegistered) return;\n  handlersRegistered = true;\n\n  process.on('exit', flush);\n  process.on('SIGTERM', () => { flush(); process.exit(0); });\n  process.on('SIGINT', () => { flush(); process.exit(0); });\n}\n", "/**\n * Cross-platform path utilities for TypeScript hooks\n *\n * Provides consistent path handling across Windows, macOS, and Linux.\n * All path construction uses path.join() for correct separators.\n * All temp directories use os.tmpdir() for platform awareness.\n */\n\nimport os from 'node:os';\nimport path from 'node:path';\n\n/**\n * Get the user's home directory (cross-platform)\n * Prefers explicit env vars, falls back to os.homedir()\n */\nexport function getHomeDir(): string {\n  return process.env.HOME || process.env.USERPROFILE || os.homedir();\n}\n\n/**\n * Get the system temp directory (cross-platform)\n * Returns /tmp on Unix, C:\\Users\\X\\AppData\\Local\\Temp on Windows\n */\nexport function getTempDir(): string {\n  return os.tmpdir();\n}\n\n/**\n * Get the project directory from environment\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory from environment\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the log directory path (cross-platform)\n * Uses path.join() for correct separators on all platforms\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return path.join(getHomeDir(), '.claude', 'logs', 'ork');\n  }\n  return path.join(getProjectDir(), '.claude', 'logs');\n}\n\n/**\n * Get the memory directory path (cross-platform)\n */\nexport function getMemoryDir(): string {\n  return path.join(getProjectDir(), '.claude', 'memory');\n}\n\n/**\n * Get the coordination directory path (cross-platform)\n */\nexport function getCoordinationDir(): string {\n  return path.join(getProjectDir(), '.claude', 'coordination');\n}\n\n/**\n * Get the session metrics file path (cross-platform)\n * Uses CLAUDE_METRICS_FILE env var if set (for test isolation), otherwise temp dir.\n */\nexport function getMetricsFile(): string {\n  return process.env.CLAUDE_METRICS_FILE || path.join(getTempDir(), 'claude-session-metrics.json');\n}\n\n/**\n * Get the session error metrics file path (cross-platform)\n */\nexport function getSessionErrorsFile(): string {\n  return process.env.CLAUDE_SESSION_ERRORS_FILE || path.join(getTempDir(), 'claude-session-errors.json');\n}\n\n/**\n * Get the session temp directory for a given session ID (cross-platform)\n */\nexport function getSessionTempDir(sessionId: string): string {\n  return path.join(getTempDir(), `claude-session-${sessionId}`);\n}\n\n/**\n * Get the active todos file path (cross-platform)\n */\nexport function getActiveTodosFile(): string {\n  return path.join(getTempDir(), 'claude-active-todos.json');\n}\n\n/**\n * Get the read count temp file path (cross-platform)\n */\nexport function getReadCountFile(): string {\n  return path.join(getTempDir(), 'claude-read-count');\n}\n\n/**\n * Normalize a path for consistent comparison\n * Converts backslashes to forward slashes and removes trailing slashes\n */\nexport function normalizePath(p: string): string {\n  return path.normalize(p).replace(/\\\\/g, '/').replace(/\\/$/, '');\n}\n\n/**\n * Check if a path is absolute\n */\nexport function isAbsolutePath(p: string): boolean {\n  return path.isAbsolute(p);\n}\n\n/**\n * Join path segments (cross-platform)\n * Re-export for convenience\n */\nexport const joinPath = path.join;\n\n/**\n * Get path separator for current platform\n */\nexport const pathSeparator = path.sep;\n", "/**\n * Smart Session ID Generator\n * Generates human-readable session IDs when CLAUDE_SESSION_ID is not available.\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * Benefits:\n * - Human-readable at a glance\n * - Contains project context\n * - Contains branch info\n * - Chronologically sortable (date-time)\n * - Short unique suffix prevents collisions\n * - Valid file path characters only\n */\n\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, basename } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Maximum length for project name component */\nconst MAX_PROJECT_LENGTH = 20;\n\n/** Maximum length for branch name component */\nconst MAX_BRANCH_LENGTH = 15;\n\n/** Characters allowed in session ID (safe for file paths) */\nconst SAFE_CHARS = /[^a-z0-9-]/g;\n\n// =============================================================================\n// SESSION ID GENERATION\n// =============================================================================\n\n/**\n * Get project name from directory path\n * Sanitizes to lowercase alphanumeric with dashes\n */\nexport function getProjectName(projectDir?: string): string {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const name = basename(dir);\n  return sanitizeName(name, MAX_PROJECT_LENGTH);\n}\n\n/**\n * Get git branch name (cached for performance)\n * Returns 'nobranch' if git is not available or not in a repo\n */\nexport function getGitBranchForSession(projectDir?: string): string {\n  // Check cache first\n  if (process.env.ORCHESTKIT_SESSION_BRANCH) {\n    return process.env.ORCHESTKIT_SESSION_BRANCH;\n  }\n\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n\n    const sanitized = sanitizeName(branch || 'detached', MAX_BRANCH_LENGTH);\n    process.env.ORCHESTKIT_SESSION_BRANCH = sanitized;\n    return sanitized;\n  } catch {\n    return 'nobranch';\n  }\n}\n\n/**\n * Format current date as MMDD\n */\nexport function formatDateComponent(date?: Date): string {\n  const d = date || new Date();\n  const month = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  return `${month}${day}`;\n}\n\n/**\n * Format current time as HHMM (24-hour)\n */\nexport function formatTimeComponent(date?: Date): string {\n  const d = date || new Date();\n  const hours = String(d.getHours()).padStart(2, '0');\n  const minutes = String(d.getMinutes()).padStart(2, '0');\n  return `${hours}${minutes}`;\n}\n\n/**\n * Generate short hash for uniqueness (4 hex chars)\n * Uses PID + timestamp + random for entropy\n */\nexport function generateShortHash(): string {\n  const entropy = `${process.pid}-${Date.now()}-${Math.random()}`;\n  return createHash('sha256')\n    .update(entropy)\n    .digest('hex')\n    .slice(0, 4);\n}\n\n/**\n * Sanitize a name for use in session ID\n * - Lowercase\n * - Replace non-alphanumeric with dashes\n * - Collapse multiple dashes\n * - Trim dashes from ends\n * - Truncate to max length\n */\nexport function sanitizeName(name: string, maxLength: number): string {\n  return name\n    .toLowerCase()\n    .replace(SAFE_CHARS, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '')\n    .slice(0, maxLength);\n}\n\n/**\n * Generate a smart session ID\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * @param projectDir - Optional project directory (defaults to env or cwd)\n * @param date - Optional date for testing (defaults to now)\n */\nexport function generateSmartSessionId(projectDir?: string, date?: Date): string {\n  const project = getProjectName(projectDir);\n  const branch = getGitBranchForSession(projectDir);\n  const dateStr = formatDateComponent(date);\n  const timeStr = formatTimeComponent(date);\n  const hash = generateShortHash();\n\n  return `${project}-${branch}-${dateStr}-${timeStr}-${hash}`;\n}\n\n// =============================================================================\n// SESSION ID CACHING\n// =============================================================================\n\n/**\n * Get cached session ID from .instance directory\n * Returns undefined if not cached\n */\nexport function getCachedSessionId(projectDir?: string): string | undefined {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const cachePath = join(dir, '.instance', 'session-id.json');\n\n  if (!existsSync(cachePath)) {\n    return undefined;\n  }\n\n  try {\n    const data = JSON.parse(readFileSync(cachePath, 'utf8'));\n    // Validate the cached ID hasn't expired (24 hours)\n    if (data.session_id && data.created_at) {\n      const age = Date.now() - new Date(data.created_at).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n      if (age < maxAge) {\n        return data.session_id;\n      }\n    }\n  } catch {\n    // Ignore read/parse errors\n  }\n\n  return undefined;\n}\n\n/**\n * Cache session ID to .instance directory\n */\nexport function cacheSessionId(sessionId: string, projectDir?: string): void {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const instanceDir = join(dir, '.instance');\n  const cachePath = join(instanceDir, 'session-id.json');\n\n  try {\n    if (!existsSync(instanceDir)) {\n      mkdirSync(instanceDir, { recursive: true });\n    }\n\n    writeFileSync(cachePath, JSON.stringify({\n      session_id: sessionId,\n      created_at: new Date().toISOString(),\n    }, null, 2));\n  } catch {\n    // Ignore write errors - caching is optional\n  }\n}\n\n/**\n * Get or generate session ID with caching\n *\n * Priority:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate new smart session ID (and cache it)\n */\nexport function getOrGenerateSessionId(projectDir?: string): string {\n  // 1. Try CLAUDE_SESSION_ID first (preferred)\n  if (process.env.CLAUDE_SESSION_ID) {\n    return process.env.CLAUDE_SESSION_ID;\n  }\n\n  // 2. Try cached session ID\n  const cached = getCachedSessionId(projectDir);\n  if (cached) {\n    return cached;\n  }\n\n  // 3. Generate new smart session ID\n  const newId = generateSmartSessionId(projectDir);\n  cacheSessionId(newId, projectDir);\n  return newId;\n}\n", "/**\n * Orchestration Types - Shared type definitions for Agent Orchestration Layer\n * Issue #197: Agent Orchestration Layer with CC 2.1.16 Task Integration\n *\n * These types support:\n * - Intent classification with hybrid scoring\n * - Agent and skill matching\n * - CC 2.1.16 Task system integration\n * - Outcome-based calibration\n * - Multi-agent coordination\n */\n\n// -----------------------------------------------------------------------------\n// Confidence Thresholds\n// -----------------------------------------------------------------------------\n\nexport const THRESHOLDS = {\n  /** Auto-dispatch agent without confirmation */\n  AUTO_DISPATCH: 85,\n  /** Auto-inject skill content */\n  SKILL_INJECT: 80,\n  /** Strong recommendation shown to user */\n  STRONG_RECOMMEND: 70,\n  /** Suggestion shown to user */\n  SUGGEST: 50,\n  /** Minimum confidence to consider */\n  MINIMUM: 40,\n} as const;\n\n// -----------------------------------------------------------------------------\n// Intent Classification Types\n// -----------------------------------------------------------------------------\n\n/** Signal types used in intent classification */\nexport type SignalType =\n  | 'keyword'         // Direct keyword match\n  | 'phrase'          // Multi-word phrase match\n  | 'context'         // Context continuity from history\n  | 'cooccurrence'    // Learned keyword co-occurrence\n  | 'negation'        // Detected negation reducing confidence\n  | 'boost'           // Calibration boost from successful outcomes\n  | 'penalty';        // Calibration penalty from failures\n\n/** Individual signal contributing to classification */\nexport interface IntentSignal {\n  type: SignalType;\n  source: string;       // What triggered this signal\n  weight: number;       // Weight contribution (0-100)\n  matched: string;      // What was matched in the prompt\n}\n\n/** Match result for an agent */\nexport interface AgentMatch {\n  agent: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Match result for a skill */\nexport interface SkillMatch {\n  skill: string;\n  confidence: number;\n  description: string;\n  matchedKeywords: string[];\n  signals: IntentSignal[];\n}\n\n/** Result from intent classification */\nexport interface ClassificationResult {\n  /** Matching agents sorted by confidence */\n  agents: AgentMatch[];\n  /** Matching skills sorted by confidence */\n  skills: SkillMatch[];\n  /** Primary detected intent category */\n  intent: string;\n  /** Highest confidence score across all matches */\n  confidence: number;\n  /** All signals used in classification */\n  signals: IntentSignal[];\n  /** Whether this should trigger auto-dispatch */\n  shouldAutoDispatch: boolean;\n  /** Whether skills should be auto-injected */\n  shouldInjectSkills: boolean;\n}\n\n// -----------------------------------------------------------------------------\n// Orchestration State Types\n// -----------------------------------------------------------------------------\n\n/** Action to take based on classification */\nexport type OrchestrationAction =\n  | 'auto-dispatch'    // Immediately spawn agent\n  | 'inject-skill'     // Auto-load skill content\n  | 'strong-recommend' // Show strong recommendation\n  | 'suggest'          // Show suggestion\n  | 'none';            // No action needed\n\n/** State for a dispatched agent */\nexport interface DispatchedAgent {\n  agent: string;\n  taskId?: string;     // CC 2.1.16 task ID if created\n  confidence: number;\n  dispatchedAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'retrying';\n  retryCount: number;\n  maxRetries: number;\n}\n\n/** Current orchestration session state */\nexport interface OrchestrationState {\n  sessionId: string;\n  /** Active dispatched agents */\n  activeAgents: DispatchedAgent[];\n  /** Skills currently injected */\n  injectedSkills: string[];\n  /** Recent prompts for context continuity */\n  promptHistory: string[];\n  /** Max prompts to keep in history */\n  maxHistorySize: number;\n  /** Last classification result */\n  lastClassification?: ClassificationResult;\n  /** Timestamp of last update */\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// CC 2.1.16 Task Integration Types\n// -----------------------------------------------------------------------------\n\n/** Metadata attached to tasks for orchestration */\nexport interface TaskMetadata {\n  /** Source of task creation */\n  source: 'orchestration' | 'user' | 'pipeline';\n  /** Agent that was dispatched */\n  dispatchedAgent?: string;\n  /** Classification confidence at dispatch time */\n  dispatchConfidence?: number;\n  /** Pipeline this task belongs to */\n  pipelineId?: string;\n  /** Step in pipeline sequence */\n  pipelineStep?: number;\n  /** Related skill names */\n  relatedSkills?: string[];\n  /** Signals that triggered dispatch */\n  dispatchSignals?: IntentSignal[];\n}\n\n/** Instruction to create a CC 2.1.16 task */\nexport interface TaskCreateInstruction {\n  subject: string;\n  description: string;\n  activeForm: string;\n  metadata: TaskMetadata;\n  /** Tasks this one is blocked by */\n  blockedBy?: string[];\n}\n\n/** Instruction to update a CC 2.1.16 task */\nexport interface TaskUpdateInstruction {\n  taskId: string;\n  status?: 'pending' | 'in_progress' | 'completed' | 'deleted';\n  addBlockedBy?: string[];\n  addBlocks?: string[];\n}\n\n// -----------------------------------------------------------------------------\n// Retry and Error Handling Types\n// -----------------------------------------------------------------------------\n\n/** Outcome of an agent execution */\nexport type AgentOutcome = 'success' | 'partial' | 'failure' | 'rejected';\n\n/** Decision on what to do after failure */\nexport interface RetryDecision {\n  shouldRetry: boolean;\n  retryCount: number;\n  maxRetries: number;\n  /** Alternative agent to suggest if giving up */\n  alternativeAgent?: string;\n  /** Reason for decision */\n  reason: string;\n  /** Delay before retry in ms */\n  delayMs?: number;\n}\n\n/** Record of an agent execution attempt */\nexport interface ExecutionAttempt {\n  agent: string;\n  taskId?: string;\n  attemptNumber: number;\n  startedAt: string;\n  completedAt?: string;\n  outcome?: AgentOutcome;\n  error?: string;\n  durationMs?: number;\n}\n\n// -----------------------------------------------------------------------------\n// Calibration Types\n// -----------------------------------------------------------------------------\n\n/** Record of a dispatched agent outcome for calibration */\nexport interface CalibrationRecord {\n  timestamp: string;\n  sessionId: string;\n  agent: string;\n  promptHash: string;        // Hash of triggering prompt\n  matchedKeywords: string[];\n  dispatchConfidence: number;\n  outcome: AgentOutcome;\n  durationMs?: number;\n  /** User feedback if any */\n  feedback?: 'positive' | 'negative' | 'neutral';\n}\n\n/** Learned adjustment for keyword/agent pairs */\nexport interface CalibrationAdjustment {\n  keyword: string;\n  agent: string;\n  /** Positive = boost, negative = penalty */\n  adjustment: number;\n  sampleCount: number;\n  lastUpdated: string;\n}\n\n/** Calibration data store */\nexport interface CalibrationData {\n  schemaVersion: string;\n  createdAt: string;\n  updatedAt: string;\n  records: CalibrationRecord[];\n  adjustments: CalibrationAdjustment[];\n  /** Summary stats for monitoring */\n  stats: {\n    totalDispatches: number;\n    successRate: number;\n    avgConfidence: number;\n    topAgents: Array<{ agent: string; count: number; successRate: number }>;\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Multi-Agent Pipeline Types\n// -----------------------------------------------------------------------------\n\n/** Known pipeline definitions */\nexport type PipelineType =\n  | 'product-thinking'\n  | 'full-stack-feature'\n  | 'ai-integration'\n  | 'security-audit'\n  | 'frontend-compliance'\n  | 'custom';\n\n/** Step in a multi-agent pipeline */\nexport interface PipelineStep {\n  agent: string;\n  description: string;\n  /** Task dependencies (step indices) */\n  dependsOn: number[];\n  /** Skills to inject for this step */\n  skills?: string[];\n  /** Estimated context tokens for this step */\n  estimatedTokens?: number;\n}\n\n/** Definition of a multi-agent pipeline */\nexport interface PipelineDefinition {\n  type: PipelineType;\n  name: string;\n  description: string;\n  /** Trigger patterns that activate this pipeline */\n  triggers: string[];\n  steps: PipelineStep[];\n  /** Total estimated tokens for full pipeline */\n  estimatedTotalTokens: number;\n}\n\n/** Active pipeline execution state */\nexport interface PipelineExecution {\n  pipelineId: string;\n  type: PipelineType;\n  startedAt: string;\n  /** Map of step index to task ID */\n  taskIds: Record<number, string>;\n  /** Current step being executed */\n  currentStep: number;\n  /** Completed steps */\n  completedSteps: number[];\n  status: 'running' | 'completed' | 'failed' | 'paused';\n}\n\n// -----------------------------------------------------------------------------\n// Configuration Types\n// -----------------------------------------------------------------------------\n\n/** Orchestration configuration */\nexport interface OrchestrationConfig {\n  /** Enable auto-dispatch at high confidence */\n  enableAutoDispatch: boolean;\n  /** Enable skill auto-injection */\n  enableSkillInjection: boolean;\n  /** Maximum tokens for skill injection */\n  maxSkillInjectionTokens: number;\n  /** Enable outcome calibration */\n  enableCalibration: boolean;\n  /** Enable pipeline detection */\n  enablePipelines: boolean;\n  /** Custom confidence thresholds */\n  thresholds?: Partial<typeof THRESHOLDS>;\n  /** Max retries for failed agents */\n  maxRetries: number;\n  /** Retry delay base in ms */\n  retryDelayBaseMs: number;\n}\n\n/** Default orchestration configuration */\nexport const DEFAULT_CONFIG: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 1200,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n", "/**\n * Orchestration State - Session state management for agent orchestration\n * Issue #197: Agent Orchestration Layer\n *\n * Manages:\n * - Active dispatched agents\n * - Injected skills tracking\n * - Prompt history for context continuity\n * - State persistence across hook invocations\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  OrchestrationState,\n  DispatchedAgent,\n  OrchestrationConfig,\n  ClassificationResult,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// State File Management\n// -----------------------------------------------------------------------------\n\nfunction getStateDir(): string {\n  return `${getProjectDir()}/.claude/orchestration`;\n}\n\nfunction getStateFile(): string {\n  const sessionId = getSessionId();\n  return `${getStateDir()}/session-${sessionId}.json`;\n}\n\nfunction getConfigFile(): string {\n  return `${getProjectDir()}/.claude/orchestration/config.json`;\n}\n\n/**\n * Ensure state directory exists\n */\nfunction ensureStateDir(): void {\n  const dir = getStateDir();\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      logHook('orchestration-state', `Failed to create state dir: ${dir}`);\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// State Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Load orchestration state for current session\n */\nexport function loadState(): OrchestrationState {\n  const stateFile = getStateFile();\n\n  if (existsSync(stateFile)) {\n    try {\n      const data = readFileSync(stateFile, 'utf8');\n      return JSON.parse(data) as OrchestrationState;\n    } catch (err) {\n      logHook('orchestration-state', `Failed to load state: ${err}`);\n    }\n  }\n\n  // Return default state\n  return {\n    sessionId: getSessionId(),\n    activeAgents: [],\n    injectedSkills: [],\n    promptHistory: [],\n    maxHistorySize: 10,\n    updatedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Save orchestration state\n */\nexport function saveState(state: OrchestrationState): void {\n  ensureStateDir();\n  const stateFile = getStateFile();\n\n  state.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(stateFile, JSON.stringify(state, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save state: ${err}`);\n  }\n}\n\n/**\n * Update state with a mutation function\n */\nexport function updateState(\n  mutate: (state: OrchestrationState) => void\n): OrchestrationState {\n  const state = loadState();\n  mutate(state);\n  saveState(state);\n  return state;\n}\n\n// -----------------------------------------------------------------------------\n// Agent Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Add a dispatched agent to state\n */\nexport function trackDispatchedAgent(\n  agent: string,\n  confidence: number,\n  taskId?: string\n): DispatchedAgent {\n  const dispatched: DispatchedAgent = {\n    agent,\n    taskId,\n    confidence,\n    dispatchedAt: new Date().toISOString(),\n    status: 'pending',\n    retryCount: 0,\n    maxRetries: 3,\n  };\n\n  updateState(state => {\n    // Remove any existing entry for same agent\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n    state.activeAgents.push(dispatched);\n  });\n\n  logHook('orchestration-state', `Tracked dispatched agent: ${agent} (conf: ${confidence})`);\n  return dispatched;\n}\n\n/**\n * Update agent status\n */\nexport function updateAgentStatus(\n  agent: string,\n  status: DispatchedAgent['status'],\n  taskId?: string\n): void {\n  updateState(state => {\n    const entry = state.activeAgents.find(a => a.agent === agent);\n    if (entry) {\n      entry.status = status;\n      if (taskId) entry.taskId = taskId;\n      if (status === 'retrying') entry.retryCount++;\n    }\n  });\n\n  logHook('orchestration-state', `Updated agent status: ${agent} -> ${status}`);\n}\n\n/**\n * Remove completed/failed agent from tracking\n */\nexport function removeAgent(agent: string): void {\n  updateState(state => {\n    state.activeAgents = state.activeAgents.filter(a => a.agent !== agent);\n  });\n}\n\n/**\n * Get currently active agent (if any)\n */\nexport function getActiveAgent(): DispatchedAgent | undefined {\n  const state = loadState();\n  return state.activeAgents.find(a => a.status === 'in_progress');\n}\n\n/**\n * Check if an agent is currently dispatched\n */\nexport function isAgentDispatched(agent: string): boolean {\n  const state = loadState();\n  return state.activeAgents.some(\n    a => a.agent === agent && (a.status === 'pending' || a.status === 'in_progress')\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Skill Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Track injected skill\n */\nexport function trackInjectedSkill(skill: string): void {\n  updateState(state => {\n    if (!state.injectedSkills.includes(skill)) {\n      state.injectedSkills.push(skill);\n    }\n  });\n}\n\n/**\n * Check if skill was already injected\n */\nexport function isSkillInjected(skill: string): boolean {\n  const state = loadState();\n  return state.injectedSkills.includes(skill);\n}\n\n/**\n * Get all injected skills\n */\nexport function getInjectedSkills(): string[] {\n  return loadState().injectedSkills;\n}\n\n// -----------------------------------------------------------------------------\n// Prompt History\n// -----------------------------------------------------------------------------\n\n/**\n * Add prompt to history (for context continuity)\n */\nexport function addToPromptHistory(prompt: string): void {\n  updateState(state => {\n    state.promptHistory.push(prompt);\n    // Trim to max size\n    if (state.promptHistory.length > state.maxHistorySize) {\n      state.promptHistory = state.promptHistory.slice(-state.maxHistorySize);\n    }\n  });\n}\n\n/**\n * Get recent prompt history\n */\nexport function getPromptHistory(): string[] {\n  return loadState().promptHistory;\n}\n\n// -----------------------------------------------------------------------------\n// Classification Caching\n// -----------------------------------------------------------------------------\n\n/**\n * Store last classification result\n */\nexport function cacheClassification(result: ClassificationResult): void {\n  updateState(state => {\n    state.lastClassification = result;\n  });\n}\n\n/**\n * Get last classification result\n */\nexport function getLastClassification(): ClassificationResult | undefined {\n  return loadState().lastClassification;\n}\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_CONFIG_VALUES: OrchestrationConfig = {\n  enableAutoDispatch: true,\n  enableSkillInjection: true,\n  maxSkillInjectionTokens: 1200,\n  enableCalibration: true,\n  enablePipelines: true,\n  maxRetries: 3,\n  retryDelayBaseMs: 1000,\n};\n\n/**\n * Load orchestration configuration\n */\nexport function loadConfig(): OrchestrationConfig {\n  const configFile = getConfigFile();\n\n  if (existsSync(configFile)) {\n    try {\n      const data = readFileSync(configFile, 'utf8');\n      return { ...DEFAULT_CONFIG_VALUES, ...JSON.parse(data) };\n    } catch {\n      // Return defaults on error\n    }\n  }\n\n  return DEFAULT_CONFIG_VALUES;\n}\n\n/**\n * Save orchestration configuration\n */\nexport function saveConfig(config: Partial<OrchestrationConfig>): void {\n  ensureStateDir();\n  const configFile = getConfigFile();\n  const current = loadConfig();\n  const merged = { ...current, ...config };\n\n  try {\n    writeFileSync(configFile, JSON.stringify(merged, null, 2));\n  } catch (err) {\n    logHook('orchestration-state', `Failed to save config: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clear session state (called on session end)\n */\nexport function clearSessionState(): void {\n  const stateFile = getStateFile();\n\n  try {\n    if (existsSync(stateFile)) {\n      const { unlinkSync } = require('node:fs');\n      unlinkSync(stateFile);\n      logHook('orchestration-state', 'Cleared session state');\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n\n/**\n * Clean up old state files (keep last 5 sessions)\n */\nexport function cleanupOldStates(): void {\n  const dir = getStateDir();\n\n  if (!existsSync(dir)) return;\n\n  try {\n    const { readdirSync, statSync, unlinkSync } = require('node:fs');\n    const files = readdirSync(dir)\n      .filter((f: string) => f.startsWith('session-') && f.endsWith('.json'))\n      .map((f: string) => ({\n        name: f,\n        path: `${dir}/${f}`,\n        mtime: statSync(`${dir}/${f}`).mtime.getTime(),\n      }))\n      .sort((a: { mtime: number }, b: { mtime: number }) => b.mtime - a.mtime);\n\n    // Keep only last 5\n    for (const file of files.slice(5)) {\n      try {\n        unlinkSync(file.path);\n        logHook('orchestration-state', `Cleaned up old state: ${file.name}`);\n      } catch {\n        // Ignore\n      }\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n}\n", "/**\n * Retry Manager - Intelligent retry decisions for failed agents\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Exponential backoff retry logic\n * - Alternative agent suggestions\n * - Failure pattern detection\n * - Max retry limits\n */\n\nimport { logHook } from './common.js';\nimport type {\n  RetryDecision,\n  ExecutionAttempt,\n  AgentOutcome,\n  DispatchedAgent,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_BASE_DELAY_MS = 1000;\nconst MAX_DELAY_MS = 30000;\n\n/** Alternative agent mappings for common failure scenarios */\nconst ALTERNATIVE_AGENTS: Record<string, string[]> = {\n  // If backend architect fails, try these\n  'backend-system-architect': ['database-engineer', 'api-designer'],\n  // If frontend fails, try UI designer first\n  'frontend-ui-developer': ['rapid-ui-designer', 'accessibility-specialist'],\n  // If test generator fails, try debug investigator\n  'test-generator': ['debug-investigator', 'code-quality-reviewer'],\n  // If security auditor fails, try layer auditor\n  'security-auditor': ['security-layer-auditor'],\n  // If workflow architect fails, try LLM integrator\n  'workflow-architect': ['llm-integrator', 'data-pipeline-engineer'],\n};\n\n/** Error patterns that indicate retry is unlikely to help */\nconst NON_RETRYABLE_ERRORS: Array<{ test: (s: string) => boolean }> = [\n  { test: (s) => /permission denied/i.test(s) },\n  { test: (s) => /access denied/i.test(s) },\n  { test: (s) => /not found/i.test(s) && /file|module|package/i.test(s) },\n  { test: (s) => /(?:file|module|package)\\s+not\\s+found/i.test(s) },\n  { test: (s) => /missing required/i.test(s) },\n  { test: (s) => /invalid (?:api|token|key)/i.test(s) },\n  { test: (s) => /authentication failed/i.test(s) },\n  { test: (s) => /quota exceeded/i.test(s) },\n  { test: (s) => /rate limit/i.test(s) },\n];\n\n/** Error patterns that suggest trying an alternative agent */\nconst ALTERNATIVE_SUGGESTING_ERRORS = [\n  /not my specialization/i,\n  /outside my scope/i,\n  /better suited for/i,\n  /consider using/i,\n  /specialized agent/i,\n];\n\n// -----------------------------------------------------------------------------\n// Retry Logic\n// -----------------------------------------------------------------------------\n\n/**\n * Calculate exponential backoff delay\n */\nexport function calculateBackoffDelay(\n  attemptNumber: number,\n  baseDelayMs: number = DEFAULT_BASE_DELAY_MS\n): number {\n  // Exponential backoff with jitter\n  const exponentialDelay = baseDelayMs * 2 ** (attemptNumber - 1);\n  const jitter = Math.random() * 0.1 * exponentialDelay; // 10% jitter\n  return Math.min(exponentialDelay + jitter, MAX_DELAY_MS);\n}\n\n/**\n * Check if error is retryable\n */\nexport function isRetryableError(error: string): boolean {\n  for (const pattern of NON_RETRYABLE_ERRORS) {\n    if (pattern.test(error)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Check if error suggests alternative agent\n */\nexport function suggestsAlternative(error: string): boolean {\n  for (const pattern of ALTERNATIVE_SUGGESTING_ERRORS) {\n    if (pattern.test(error)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get alternative agent for a given agent\n */\nexport function getAlternativeAgent(agent: string, triedAgents: string[] = []): string | undefined {\n  const alternatives = ALTERNATIVE_AGENTS[agent];\n  if (!alternatives) return undefined;\n\n  // Return first alternative not yet tried\n  for (const alt of alternatives) {\n    if (!triedAgents.includes(alt)) {\n      return alt;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Make retry decision based on execution history and error\n */\nexport function makeRetryDecision(\n  agent: string,\n  attemptNumber: number,\n  error: string,\n  triedAgents: string[] = [],\n  maxRetries: number = DEFAULT_MAX_RETRIES\n): RetryDecision {\n  logHook('retry-manager', `Evaluating retry for ${agent}, attempt ${attemptNumber}`);\n\n  // Check if max retries exceeded\n  if (attemptNumber >= maxRetries) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Max retries (${maxRetries}) exceeded` +\n        (alternative ? `. Consider trying ${alternative} instead.` : ''),\n    };\n  }\n\n  // Check if error is retryable\n  if (!isRetryableError(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    return {\n      shouldRetry: false,\n      retryCount: attemptNumber,\n      maxRetries,\n      alternativeAgent: alternative,\n      reason: `Non-retryable error detected: ${error.slice(0, 100)}`,\n    };\n  }\n\n  // Check if error suggests alternative agent\n  if (suggestsAlternative(error)) {\n    const alternative = getAlternativeAgent(agent, triedAgents);\n    if (alternative) {\n      return {\n        shouldRetry: false,\n        retryCount: attemptNumber,\n        maxRetries,\n        alternativeAgent: alternative,\n        reason: `Error suggests using alternative agent: ${alternative}`,\n      };\n    }\n  }\n\n  // Retry with backoff\n  const delayMs = calculateBackoffDelay(attemptNumber);\n  return {\n    shouldRetry: true,\n    retryCount: attemptNumber,\n    maxRetries,\n    delayMs,\n    reason: `Retrying (attempt ${attemptNumber + 1}/${maxRetries}) after ${Math.round(delayMs / 1000)}s`,\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Execution Tracking\n// -----------------------------------------------------------------------------\n\n/**\n * Create execution attempt record\n */\nexport function createAttempt(\n  agent: string,\n  attemptNumber: number,\n  taskId?: string\n): ExecutionAttempt {\n  return {\n    agent,\n    taskId,\n    attemptNumber,\n    startedAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Complete execution attempt with outcome\n */\nexport function completeAttempt(\n  attempt: ExecutionAttempt,\n  outcome: AgentOutcome,\n  error?: string\n): ExecutionAttempt {\n  const completedAt = new Date().toISOString();\n  const durationMs = new Date(completedAt).getTime() - new Date(attempt.startedAt).getTime();\n\n  return {\n    ...attempt,\n    completedAt,\n    outcome,\n    error,\n    durationMs,\n  };\n}\n\n/**\n * Analyze execution history for patterns\n */\nexport function analyzeAttemptHistory(attempts: ExecutionAttempt[]): {\n  successRate: number;\n  avgDuration: number;\n  commonErrors: string[];\n} {\n  if (attempts.length === 0) {\n    return { successRate: 0, avgDuration: 0, commonErrors: [] };\n  }\n\n  const successful = attempts.filter(a => a.outcome === 'success').length;\n  const successRate = successful / attempts.length;\n\n  const durations = attempts\n    .filter(a => a.durationMs !== undefined)\n    .map(a => a.durationMs!);\n  const avgDuration = durations.length > 0\n    ? durations.reduce((a, b) => a + b, 0) / durations.length\n    : 0;\n\n  // Count error patterns\n  const errorCounts = new Map<string, number>();\n  for (const attempt of attempts) {\n    if (attempt.error) {\n      // Normalize error to first 50 chars\n      const normalized = attempt.error.slice(0, 50).toLowerCase();\n      errorCounts.set(normalized, (errorCounts.get(normalized) || 0) + 1);\n    }\n  }\n\n  // Get most common errors\n  const commonErrors = Array.from(errorCounts.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 3)\n    .map(([error]) => error);\n\n  return { successRate, avgDuration, commonErrors };\n}\n\n// -----------------------------------------------------------------------------\n// Dispatched Agent Updates\n// -----------------------------------------------------------------------------\n\n/**\n * Update dispatched agent for retry\n */\nexport function prepareForRetry(\n  agent: DispatchedAgent,\n  decision: RetryDecision\n): DispatchedAgent {\n  return {\n    ...agent,\n    status: 'retrying',\n    retryCount: decision.retryCount,\n  };\n}\n\n/**\n * Format retry decision as user-facing message\n */\nexport function formatRetryDecision(decision: RetryDecision, agent: string): string {\n  if (decision.shouldRetry) {\n    return `## Retry Scheduled\n\nAgent \\`${agent}\\` will retry after ${Math.round((decision.delayMs || 0) / 1000)} seconds.\n\n**Attempt:** ${decision.retryCount + 1} of ${decision.maxRetries}\n**Reason:** ${decision.reason}`;\n  }\n\n  let message = `## Retry Not Recommended\n\nAgent \\`${agent}\\` has ${decision.retryCount >= decision.maxRetries ? 'exhausted retries' : 'encountered a non-retryable error'}.\n\n**Reason:** ${decision.reason}`;\n\n  if (decision.alternativeAgent) {\n    message += `\n\n### Alternative Suggestion\n\nConsider using \\`${decision.alternativeAgent}\\` instead:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${decision.alternativeAgent}\"\n\\`\\`\\``;\n  }\n\n  return message;\n}\n", "/**\n * Calibration Engine - Outcome-based learning for intent classification\n * Issue #197: Agent Orchestration Layer\n *\n * Learns from agent dispatch outcomes to improve classification accuracy:\n * - Records dispatch-outcome pairs\n * - Calculates keyword-agent boost/penalty adjustments\n * - Provides calibration data for intent classifier\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { createHash } from 'node:crypto';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  CalibrationRecord,\n  CalibrationAdjustment,\n  CalibrationData,\n  AgentOutcome,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum records to keep in calibration data */\nconst MAX_RECORDS = 500;\n\n/** Minimum samples needed before applying adjustments */\nconst MIN_SAMPLES_FOR_ADJUSTMENT = 3;\n\n/** Maximum adjustment magnitude */\nconst MAX_ADJUSTMENT = 15;\n\n/** Adjustment step per outcome */\nconst ADJUSTMENT_STEP = 3;\n\n/** Decay factor for old records (applied to adjustments) */\nconst DECAY_FACTOR = 0.9;\n\n// -----------------------------------------------------------------------------\n// File Management\n// -----------------------------------------------------------------------------\n\nfunction getCalibrationFile(): string {\n  return `${getProjectDir()}/.claude/feedback/calibration-data.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/feedback`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Load calibration data from file\n */\nexport function loadCalibrationData(): CalibrationData {\n  const file = getCalibrationFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      logHook('calibration-engine', 'Failed to load calibration data, using defaults');\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n    records: [],\n    adjustments: [],\n    stats: {\n      totalDispatches: 0,\n      successRate: 0,\n      avgConfidence: 0,\n      topAgents: [],\n    },\n  };\n}\n\n/**\n * Save calibration data to file\n */\nexport function saveCalibrationData(data: CalibrationData): void {\n  ensureDir();\n  const file = getCalibrationFile();\n\n  data.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(data, null, 2));\n    logHook('calibration-engine', 'Saved calibration data');\n  } catch (err) {\n    logHook('calibration-engine', `Failed to save calibration data: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Recording\n// -----------------------------------------------------------------------------\n\n/**\n * Create a hash of prompt for deduplication\n */\nexport function hashPrompt(prompt: string): string {\n  return createHash('sha256').update(prompt.toLowerCase().trim()).digest('hex').slice(0, 16);\n}\n\n/**\n * Record a dispatch outcome\n */\nexport function recordOutcome(\n  prompt: string,\n  agent: string,\n  matchedKeywords: string[],\n  confidence: number,\n  outcome: AgentOutcome,\n  durationMs?: number,\n  feedback?: 'positive' | 'negative' | 'neutral'\n): void {\n  const data = loadCalibrationData();\n\n  const record: CalibrationRecord = {\n    timestamp: new Date().toISOString(),\n    sessionId: getSessionId(),\n    agent,\n    promptHash: hashPrompt(prompt),\n    matchedKeywords,\n    dispatchConfidence: confidence,\n    outcome,\n    durationMs,\n    feedback,\n  };\n\n  data.records.push(record);\n\n  // Trim old records\n  if (data.records.length > MAX_RECORDS) {\n    data.records = data.records.slice(-MAX_RECORDS);\n  }\n\n  // Update adjustments\n  updateAdjustments(data, record);\n\n  // Update stats\n  updateStats(data);\n\n  saveCalibrationData(data);\n\n  logHook(\n    'calibration-engine',\n    `Recorded outcome: ${agent} -> ${outcome} (conf: ${confidence})`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Adjustment Calculation\n// -----------------------------------------------------------------------------\n\n/**\n * Update adjustments based on new record\n */\nfunction updateAdjustments(data: CalibrationData, record: CalibrationRecord): void {\n  const isPositive = record.outcome === 'success';\n  const isNegative = record.outcome === 'failure' || record.outcome === 'rejected';\n\n  if (!isPositive && !isNegative) {\n    // Partial outcomes don't affect adjustments\n    return;\n  }\n\n  const adjustmentDelta = isPositive ? ADJUSTMENT_STEP : -ADJUSTMENT_STEP;\n\n  for (const keyword of record.matchedKeywords) {\n    const existing = data.adjustments.find(\n      a => a.keyword === keyword && a.agent === record.agent\n    );\n\n    if (existing) {\n      // Update existing adjustment\n      existing.adjustment = Math.max(\n        -MAX_ADJUSTMENT,\n        Math.min(MAX_ADJUSTMENT, existing.adjustment + adjustmentDelta)\n      );\n      existing.sampleCount++;\n      existing.lastUpdated = new Date().toISOString();\n    } else {\n      // Create new adjustment\n      data.adjustments.push({\n        keyword,\n        agent: record.agent,\n        adjustment: adjustmentDelta,\n        sampleCount: 1,\n        lastUpdated: new Date().toISOString(),\n      });\n    }\n  }\n}\n\n/**\n * Apply decay to old adjustments\n */\nexport function applyDecay(data: CalibrationData): void {\n  const now = Date.now();\n  const dayMs = 24 * 60 * 60 * 1000;\n\n  for (const adj of data.adjustments) {\n    const age = now - new Date(adj.lastUpdated).getTime();\n    const daysOld = Math.floor(age / dayMs);\n\n    if (daysOld > 7) {\n      // Apply decay for adjustments older than 7 days\n      adj.adjustment = Math.round(adj.adjustment * DECAY_FACTOR);\n\n      // Remove zero adjustments\n      if (Math.abs(adj.adjustment) < 1) {\n        adj.adjustment = 0;\n      }\n    }\n  }\n\n  // Remove zero adjustments\n  data.adjustments = data.adjustments.filter(a => a.adjustment !== 0);\n}\n\n// -----------------------------------------------------------------------------\n// Statistics\n// -----------------------------------------------------------------------------\n\n/**\n * Update aggregate statistics\n */\nfunction updateStats(data: CalibrationData): void {\n  const records = data.records;\n  if (records.length === 0) return;\n\n  // Total dispatches\n  data.stats.totalDispatches = records.length;\n\n  // Success rate\n  const successful = records.filter(r => r.outcome === 'success').length;\n  data.stats.successRate = successful / records.length;\n\n  // Average confidence\n  const avgConf = records.reduce((sum, r) => sum + r.dispatchConfidence, 0) / records.length;\n  data.stats.avgConfidence = Math.round(avgConf);\n\n  // Top agents by count and success rate\n  const agentStats = new Map<string, { count: number; success: number }>();\n  for (const record of records) {\n    const stat = agentStats.get(record.agent) || { count: 0, success: 0 };\n    stat.count++;\n    if (record.outcome === 'success') stat.success++;\n    agentStats.set(record.agent, stat);\n  }\n\n  data.stats.topAgents = Array.from(agentStats.entries())\n    .map(([agent, stat]) => ({\n      agent,\n      count: stat.count,\n      successRate: stat.success / stat.count,\n    }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 10);\n}\n\n// -----------------------------------------------------------------------------\n// Query Functions\n// -----------------------------------------------------------------------------\n\n/**\n * Get adjustments for intent classifier\n */\nexport function getAdjustments(): CalibrationAdjustment[] {\n  const data = loadCalibrationData();\n\n  // Only return adjustments with sufficient samples\n  return data.adjustments.filter(a => a.sampleCount >= MIN_SAMPLES_FOR_ADJUSTMENT);\n}\n\n/**\n * Get success rate for a specific agent\n */\nexport function getAgentSuccessRate(agent: string): number | null {\n  const data = loadCalibrationData();\n  const agentRecords = data.records.filter(r => r.agent === agent);\n\n  if (agentRecords.length < MIN_SAMPLES_FOR_ADJUSTMENT) {\n    return null;\n  }\n\n  const successful = agentRecords.filter(r => r.outcome === 'success').length;\n  return successful / agentRecords.length;\n}\n\n/**\n * Get calibration stats\n */\nexport function getCalibrationStats(): CalibrationData['stats'] {\n  return loadCalibrationData().stats;\n}\n\n/**\n * Check if we have enough data for meaningful calibration\n */\nexport function hasMinimalCalibrationData(): boolean {\n  const data = loadCalibrationData();\n  return data.records.length >= MIN_SAMPLES_FOR_ADJUSTMENT;\n}\n", "/**\n * Graph Memory Inject - SubagentStart Hook\n * CC 2.1.7 Compliant: outputs JSON with continue field\n *\n * Injects graph-based memory context before agent spawn.\n * Always runs - knowledge graph requires no configuration.\n *\n * Part of OrchestKit memory system.\n *\n * Version: 1.0.0 (split from agent-memory-inject.ts)\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir } from '../lib/common.js';\nimport { existsSync, statSync } from 'node:fs';\nimport { resolve } from 'node:path';\n\n// Agent type to domain mapping\nconst AGENT_DOMAINS: Record<string, string> = {\n  'database-engineer': 'database schema SQL PostgreSQL migration pgvector',\n  'backend-system-architect': 'API REST architecture backend FastAPI microservice',\n  'frontend-ui-developer': 'React frontend UI component TypeScript Tailwind',\n  'security-auditor': 'security OWASP vulnerability audit authentication',\n  'test-generator': 'testing unit integration coverage pytest MSW',\n  'workflow-architect': 'LangGraph workflow agent orchestration state',\n  'llm-integrator': 'LLM API OpenAI Anthropic embeddings RAG function-calling',\n  'data-pipeline-engineer': 'data pipeline embeddings vector ETL chunking',\n  'metrics-architect': 'metrics OKR KPI analytics instrumentation',\n  'ux-researcher': 'UX user research persona journey accessibility',\n  'code-quality-reviewer': 'code quality review linting type-check patterns',\n  'infrastructure-architect': 'infrastructure cloud Docker Kubernetes deployment',\n  'ci-cd-engineer': 'CI CD pipeline GitHub Actions deployment automation',\n  'accessibility-specialist': 'accessibility WCAG ARIA screen-reader a11y',\n  'product-strategist': 'product strategy roadmap features prioritization',\n};\n\nfunction getAgentDomain(agentType: string): string {\n  return AGENT_DOMAINS[agentType] || agentType;\n}\n\n/** Minimum graph file size in bytes to consider it useful (~3 entities) */\nconst MIN_GRAPH_SIZE = 100;\n\n/**\n * Graph memory inject - skips when graph is empty/tiny\n */\nexport function graphMemoryInject(input: HookInput): HookResult {\n  logHook('graph-memory-inject', 'Graph memory inject hook starting');\n\n  // Early return: skip if knowledge graph is empty or too small\n  const graphDataFile = resolve(getProjectDir(), '.claude/memory/knowledge-graph.jsonl');\n  if (!existsSync(graphDataFile)) {\n    logHook('graph-memory-inject', 'No graph data file, skipping');\n    return outputSilentSuccess();\n  }\n  try {\n    const graphSize = statSync(graphDataFile).size;\n    if (graphSize < MIN_GRAPH_SIZE) {\n      logHook('graph-memory-inject', `Graph too small (${graphSize}B < ${MIN_GRAPH_SIZE}B), skipping`);\n      return outputSilentSuccess();\n    }\n  } catch {\n    logHook('graph-memory-inject', 'Could not stat graph file, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Extract agent type from hook input\n  const toolInput = input.tool_input || {};\n  // CC 2.1.47: subagent_type is reliably set in SubagentStart events\n  const agentType = (toolInput.subagent_type as string) || '';\n\n  if (!agentType) {\n    logHook('graph-memory-inject', 'No agent type detected, passing through');\n    return outputSilentSuccess();\n  }\n\n  const agentId = `ork:${agentType}`;\n  const domainKeywords = getAgentDomain(agentType);\n\n  logHook('graph-memory-inject', `Detected agent type: ${agentType} (agent_id: ${agentId})`);\n\n  // Build graph memory load instructions\n  const memoryLoadMsg = `[Graph Memory - Agent Context Load]\n\nExecute this MCP call to load graph context for ${agentType} agent:\n\n## Graph Memory Entities\n\\`\\`\\`\nmcp__memory__search_nodes\n{\"query\": \"${agentType} ${domainKeywords}\"}\n\\`\\`\\`\n\n## Integration Instructions\n1. Execute the graph search to retrieve relevant entities and relationships\n2. Review entities for patterns, decisions, and constraints\n3. Check relationships between concepts\n4. Apply learned patterns to current task\n\nAgent ID: ${agentId} | Domain: ${domainKeywords}`;\n\n  const systemMsg = `[Graph Memory] Agent: ${agentType} | ID: ${agentId} | Load graph context via MCP call above`;\n\n  logHook('graph-memory-inject', `Outputting graph memory instructions for ${agentType}`);\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n    hookSpecificOutput: {\n      additionalContext: memoryLoadMsg,\n    },\n  };\n}\n", "/**\n * Context Gate - SubagentStart Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Prevents context overflow by limiting concurrent background agents.\n *\n * Strategy:\n * - Track active background agents in session\n * - Block new background spawns when limit exceeded\n * - Force sequential execution for expensive operations\n * - Suggest context compression when approaching limits\n *\n * Version: 1.0.0 (TypeScript port)\n * Part of Context Engineering 2.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync, } from 'node:fs';\nimport { dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputDeny, outputWarning, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst MAX_CONCURRENT_BACKGROUND = 6;\nconst MAX_AGENTS_PER_RESPONSE = 8;\nconst WARNING_THRESHOLD = 5;\nconst EXPENSIVE_TYPES = /^(test-generator|backend-system-architect|workflow-architect|security-auditor|llm-integrator)$/;\n\n// Worktree isolation: raise limits when in worktree (CC 2.1.49)\nfunction isInWorktree(): boolean {\n  const cwd = process.cwd();\n  return cwd.includes('.claude/worktrees/') || cwd.includes('/.git/worktrees/');\n}\n\nfunction getEffectiveLimits(): { maxBackground: number; maxPerResponse: number } {\n  if (isInWorktree()) {\n    return { maxBackground: 10, maxPerResponse: 12 };\n  }\n  return { maxBackground: MAX_CONCURRENT_BACKGROUND, maxPerResponse: MAX_AGENTS_PER_RESPONSE };\n}\n\n// State file paths\nfunction getStateFile(): string {\n  return `${getProjectDir()}/.claude/logs/agent-state.json`;\n}\n\nfunction getSpawnLog(): string {\n  return `${getProjectDir()}/.claude/logs/subagent-spawns.jsonl`;\n}\n\n// -----------------------------------------------------------------------------\n// State Tracking\n// -----------------------------------------------------------------------------\n\ninterface StateData {\n  active_background: string[];\n  session_total: number;\n  last_cleanup: string | null;\n  blocked_count: number;\n}\n\nfunction initState(): void {\n  const stateFile = getStateFile();\n  const dir = dirname(stateFile);\n\n  try {\n    mkdirSync(dir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  if (!existsSync(stateFile)) {\n    const initialState: StateData = {\n      active_background: [],\n      session_total: 0,\n      last_cleanup: null,\n      blocked_count: 0,\n    };\n    try {\n      writeFileSync(stateFile, JSON.stringify(initialState, null, 2));\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction countActiveBackground(): number {\n  const spawnLog = getSpawnLog();\n  if (!existsSync(spawnLog)) {\n    return 0;\n  }\n\n  try {\n    const content = readFileSync(spawnLog, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const recentLines = lines.slice(-20);\n\n    // Count agents spawned in last 5 minutes\n    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();\n    let count = 0;\n\n    for (const line of recentLines) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.timestamp && entry.timestamp > fiveMinutesAgo) {\n          count++;\n        }\n      } catch {\n        // Skip invalid JSON\n      }\n    }\n\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\nfunction countCurrentResponseAgents(): number {\n  const spawnLog = getSpawnLog();\n  if (!existsSync(spawnLog)) {\n    return 0;\n  }\n\n  try {\n    const content = readFileSync(spawnLog, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    const recentLines = lines.slice(-20);\n\n    // Count agents spawned in last 2 seconds (same response)\n    const twoSecondsAgo = new Date(Date.now() - 2 * 1000).toISOString();\n    let count = 0;\n\n    for (const line of recentLines) {\n      try {\n        const entry = JSON.parse(line);\n        if (entry.timestamp && entry.timestamp > twoSecondsAgo) {\n          count++;\n        }\n      } catch {\n        // Skip invalid JSON\n      }\n    }\n\n    return count;\n  } catch {\n    return 0;\n  }\n}\n\nfunction incrementBlockedCount(): void {\n  const stateFile = getStateFile();\n  try {\n    if (existsSync(stateFile)) {\n      const state: StateData = JSON.parse(readFileSync(stateFile, 'utf8'));\n      state.blocked_count = (state.blocked_count || 0) + 1;\n      writeFileSync(stateFile, JSON.stringify(state, null, 2));\n    }\n  } catch {\n    // Ignore\n  }\n}\n\nfunction incrementSessionTotal(): void {\n  const stateFile = getStateFile();\n  try {\n    if (existsSync(stateFile)) {\n      const state: StateData = JSON.parse(readFileSync(stateFile, 'utf8'));\n      state.session_total = (state.session_total || 0) + 1;\n      writeFileSync(stateFile, JSON.stringify(state, null, 2));\n    }\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function contextGate(input: HookInput): HookResult {\n  initState();\n\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const description = (toolInput.description as string) || '';\n  const runInBackground = toolInput.run_in_background === true || toolInput.run_in_background === 'true';\n\n  logHook('context-gate', `Context gate check: ${subagentType} (background=${runInBackground})`);\n\n  // Count current state\n  const activeCount = countActiveBackground();\n  const responseCount = countCurrentResponseAgents();\n\n  logHook('context-gate', `Active background: ${activeCount}, Current response: ${responseCount}`);\n\n  const limits = getEffectiveLimits();\n\n  // Check 1: Too many agents in single response\n  if (responseCount >= limits.maxPerResponse) {\n    logHook('context-gate', `BLOCKED: Too many agents in single response (${responseCount} >= ${limits.maxPerResponse})`);\n\n    return outputDeny(`Context Overflow Protection\n\nToo many agents spawned in a single response (${responseCount} agents).\n\nMaximum allowed: ${limits.maxPerResponse} per response\n\nSOLUTION: Split into multiple responses or use sequential execution.\nConsider using the /context-optimization skill first.\n\nAttempted: ${subagentType} - ${description}`);\n  }\n\n  // Check 2: Too many concurrent background agents\n  if (runInBackground && activeCount >= limits.maxBackground) {\n    logHook('context-gate', `BLOCKED: Too many concurrent background agents (${activeCount} >= ${limits.maxBackground})`);\n\n    incrementBlockedCount();\n\n    return outputDeny(`Background Agent Limit\n\nToo many background agents running concurrently (${activeCount} active).\n\nMaximum allowed: ${limits.maxBackground} concurrent background agents\n\nSOLUTION:\n1. Wait for existing agents to complete\n2. Run this agent in foreground (remove run_in_background)\n3. Use /context-optimization to free up context\n\nAttempted: ${subagentType} - ${description}`);\n  }\n\n  // Warning: Approaching limits\n  if (activeCount >= WARNING_THRESHOLD) {\n    logHook('context-gate', `WARNING: Approaching context budget limit`);\n\n    // Update session total\n    incrementSessionTotal();\n\n    return outputWarning(`Context Budget Warning\n\n${activeCount} background agents active (limit: ${limits.maxBackground}).\n\nConsider:\n- Running remaining agents sequentially\n- Using /context-optimization skill\n- Waiting for current agents to complete\n\nProceeding with: ${subagentType} - ${description}`);\n  }\n\n  // Warning: Expensive agent type\n  if (EXPENSIVE_TYPES.test(subagentType) && activeCount >= 2) {\n    logHook('context-gate', `WARNING: Expensive agent type with multiple active: ${subagentType}`);\n    return outputWarning(`Spawning expensive agent (${subagentType}) with ${activeCount} others active`);\n  }\n\n  // Update session total\n  incrementSessionTotal();\n\n  // Allow the agent to proceed\n  logHook('context-gate', `Context gate passed: ${subagentType}`);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Subagent Context Stager - SubagentStart Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * This hook:\n * 1. Checks if there are active todos from session state\n * 2. Stages relevant context files based on the task description\n * 3. Returns systemMessage with staged context\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, readFileSync, readdirSync } from 'node:fs';\nimport { homedir } from 'node:os';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getSessionState(): string {\n  return `${getProjectDir()}/.claude/context/session/state.json`;\n}\n\nfunction getDecisionsFile(): string {\n  return `${getProjectDir()}/.claude/context/knowledge/decisions/active.json`;\n}\n\nfunction getIssueDir(): string {\n  return `${getProjectDir()}/docs/issues`;\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction Functions\n// -----------------------------------------------------------------------------\n\ninterface SessionState {\n  tasks_pending?: string[];\n  [key: string]: unknown;\n}\n\ninterface DecisionsFile {\n  decisions?: Array<{\n    category?: string;\n    title?: string;\n    status?: string;\n  }>;\n}\n\nfunction extractPendingTasks(): { count: number; summary: string } {\n  const sessionState = getSessionState();\n  if (!existsSync(sessionState)) {\n    return { count: 0, summary: '' };\n  }\n\n  try {\n    const state: SessionState = JSON.parse(readFileSync(sessionState, 'utf8'));\n    const tasksPending = state.tasks_pending || [];\n    const count = tasksPending.length;\n\n    if (count === 0) {\n      return { count: 0, summary: '' };\n    }\n\n    const summary = tasksPending.slice(0, 5).map((t) => `- ${t}`).join('\\n');\n    return { count, summary };\n  } catch {\n    return { count: 0, summary: '' };\n  }\n}\n\nfunction extractRelevantDecisions(_taskDescription: string, category: string): string {\n  const decisionsFile = getDecisionsFile();\n  if (!existsSync(decisionsFile)) {\n    return '';\n  }\n\n  try {\n    const data: DecisionsFile = JSON.parse(readFileSync(decisionsFile, 'utf8'));\n    const decisions = data.decisions || [];\n\n    const relevantDecisions = decisions\n      .filter((d) => d.category === category || d.category === 'api' || d.category === 'database')\n      .slice(0, 8)\n      .map((d) => `- ${d.title} (${d.status || 'unknown'})`);\n\n    return relevantDecisions.join('\\n');\n  } catch {\n    return '';\n  }\n}\n\nfunction findIssueDoc(issueNum: string): string {\n  const issueDir = getIssueDir();\n  if (!existsSync(issueDir)) {\n    return '';\n  }\n\n  try {\n    const entries = readdirSync(issueDir);\n    const match = entries.find((entry) => entry.includes(issueNum));\n    if (match) {\n      return `docs/issues/${match}`;\n    }\n  } catch {\n    // Ignore\n  }\n  return '';\n}\n\n// -----------------------------------------------------------------------------\n// Critical Rules Extraction\n// -----------------------------------------------------------------------------\n\n/**\n * Extract condensed critical rules from global and project CLAUDE.md files.\n * Sub-agents don't inherit ~/.claude/CLAUDE.md from the CC runtime,\n * so we inject key rules via systemMessage to prevent drift.\n *\n * Budget: ~150 tokens max \u2014 enough for guardrails, not a full CLAUDE.md copy.\n */\nfunction extractCriticalRules(): string {\n  const rules: string[] = [];\n\n  // Read global CLAUDE.md (~/.claude/CLAUDE.md)\n  const globalPath = join(homedir(), '.claude', 'CLAUDE.md');\n  const globalRules = safeReadFile(globalPath);\n  if (globalRules) {\n    // Extract bullet points and key directives\n    const extracted = extractRulesFromMarkdown(globalRules, 'global');\n    rules.push(...extracted);\n  }\n\n  // Read project CLAUDE.md\n  const projectPath = join(getProjectDir(), 'CLAUDE.md');\n  const projectRules = safeReadFile(projectPath);\n  if (projectRules) {\n    const extracted = extractRulesFromMarkdown(projectRules, 'project');\n    rules.push(...extracted);\n  }\n\n  if (rules.length === 0) return '';\n\n  // Deduplicate and cap at 12 rules (~150 tokens)\n  const unique = [...new Set(rules)].slice(0, 12);\n  return `CRITICAL RULES (inherited from CLAUDE.md):\\n${unique.map(r => `- ${r}`).join('\\n')}\\n\\n`;\n}\n\nfunction safeReadFile(filePath: string): string {\n  try {\n    if (!existsSync(filePath)) return '';\n    return readFileSync(filePath, 'utf8');\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Extract actionable rules from markdown content.\n * Looks for: bullet points with imperative verbs, DO/DON'T blocks,\n * and lines containing \"always\", \"never\", \"must\".\n */\nfunction extractRulesFromMarkdown(content: string, _source: string): string[] {\n  const rules: string[] = [];\n  const lines = content.split('\\n');\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    // Skip headers, empty lines, code blocks\n    if (!trimmed || trimmed.startsWith('#') || trimmed.startsWith('```')) continue;\n\n    // Match bullet points with strong directives\n    if (/^[-*]\\s+/.test(trimmed)) {\n      const bullet = trimmed.replace(/^[-*]\\s+/, '').trim();\n\n      // Only keep rules with imperative/directive language\n      if (/\\b(always|never|must|don't|do not|required|NEVER|MUST|DON'T)\\b/i.test(bullet)) {\n        // Truncate long rules to ~80 chars\n        const truncated = bullet.length > 80 ? `${bullet.substring(0, 77)}...` : bullet;\n        rules.push(truncated);\n      }\n    }\n\n    // Match bold DO/DON'T blocks\n    if (/^\\*\\*(DO|DON'T|DO NOT)\\*\\*:/.test(trimmed)) {\n      const directive = trimmed.replace(/\\*\\*/g, '').trim();\n      if (directive.length <= 80) {\n        rules.push(directive);\n      }\n    }\n  }\n\n  return rules;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentContextStager(input: HookInput): HookResult {\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const taskDescription = (toolInput.task_description as string) || (toolInput.description as string) || '';\n\n  logHook('subagent-context-stager', `Staging context for ${subagentType}`);\n\n  let stagedContext = '';\n\n  // === INJECT CRITICAL RULES FROM CLAUDE.md FILES ===\n  const criticalRules = extractCriticalRules();\n  if (criticalRules) {\n    stagedContext += criticalRules;\n    logHook('subagent-context-stager', 'Injected critical rules from CLAUDE.md');\n  }\n\n  // === CHECK FOR ACTIVE TODOS (Context Protocol 2.0) ===\n  const { count: pendingCount, summary: taskSummary } = extractPendingTasks();\n  if (pendingCount > 0) {\n    logHook('subagent-context-stager', `Found ${pendingCount} pending tasks`);\n    stagedContext += `ACTIVE TODOS:\\n${taskSummary}\\n\\n`;\n  }\n\n  // === STAGE RELEVANT ARCHITECTURE DECISIONS ===\n  const taskLower = taskDescription.toLowerCase();\n\n  if (/backend|api|endpoint|database|migration/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Backend task detected - staging backend decisions');\n    const backendDecisions = extractRelevantDecisions(taskDescription, 'backend');\n    if (backendDecisions) {\n      stagedContext += `RELEVANT DECISIONS:\\n${backendDecisions}\\n\\n`;\n    }\n  }\n\n  if (/frontend|react|ui|component/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Frontend task detected - staging frontend decisions');\n    const frontendDecisions = extractRelevantDecisions(taskDescription, 'frontend');\n    if (frontendDecisions) {\n      stagedContext += `RELEVANT DECISIONS:\\n${frontendDecisions}\\n\\n`;\n    }\n  }\n\n  // === STAGE TESTING REMINDERS ===\n  if (/test|testing|pytest|jest/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Testing task detected - staging test context');\n    stagedContext += `TESTING REMINDERS:\n- Use 'tee' for visible test output\n- Check test patterns in backend/tests/ or frontend/src/**/__tests__/\n- Ensure coverage meets threshold requirements\n\n`;\n  }\n\n  // === STAGE ISSUE DOCUMENTATION ===\n  if (/issue|#\\d+|bug|fix/.test(taskLower)) {\n    logHook('subagent-context-stager', 'Issue-related task detected');\n\n    const issueMatch = taskDescription.match(/#(\\d+)/);\n    if (issueMatch) {\n      const issueNum = issueMatch[1];\n      const issueDoc = findIssueDoc(issueNum);\n      if (issueDoc) {\n        stagedContext += `ISSUE DOCS: ${issueDoc}\\n\\n`;\n        logHook('subagent-context-stager', `Staged issue documentation for #${issueNum}`);\n      }\n    }\n  }\n\n  // === RETURN SYSTEM MESSAGE (CC 2.1.7 Compliant) ===\n  if (stagedContext) {\n    const systemMessage = `${stagedContext}\\nTask: ${taskDescription}\\nSubagent: ${subagentType}`;\n    const lineCount = stagedContext.split('\\n').filter(Boolean).length;\n    logHook('subagent-context-stager', `Staged context with ${lineCount} lines`);\n\n    return {\n      continue: true,\n      systemMessage,\n    };\n  }\n\n  logHook('subagent-context-stager', 'No context staged for this task');\n  return outputSilentSuccess();\n}\n", "/**\n * Subagent Validator - SubagentStart Hook (PreToolUse for Task)\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * This is the ONLY place we track subagent usage because:\n * - SubagentStop hook doesn't receive subagent_type (Claude Code limitation)\n * - PreToolUse receives full task details including type, description, prompt\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, readFileSync, mkdirSync, readdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { join, dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst BUILTIN_TYPES = new Set([\n  'general-purpose',\n  'Explore',\n  'Plan',\n  'claude-code-guide',\n  'statusline-setup',\n  'Bash',\n]);\n\n// -----------------------------------------------------------------------------\n// Path Helpers (cross-platform using path.join)\n// -----------------------------------------------------------------------------\n\nfunction getTrackingLog(): string {\n  return join(getProjectDir(), '.claude', 'logs', 'subagent-spawns.jsonl');\n}\n\nfunction getPluginJson(): string {\n  return join(getProjectDir(), 'plugin.json');\n}\n\nfunction getAgentsDir(): string {\n  return join(getProjectDir(), 'agents');\n}\n\nfunction getClaudeAgentsDir(): string {\n  return join(getProjectDir(), '.claude', 'agents');\n}\n\nfunction getSkillsDir(): string {\n  return join(getProjectDir(), 'skills');\n}\n\n// -----------------------------------------------------------------------------\n// Validation Functions\n// -----------------------------------------------------------------------------\n\nfunction getValidAgentTypes(): Set<string> {\n  const validTypes = new Set(BUILTIN_TYPES);\n\n  // Source 1: Load from plugin.json agents array\n  const pluginJson = getPluginJson();\n  if (existsSync(pluginJson)) {\n    try {\n      const plugin = JSON.parse(readFileSync(pluginJson, 'utf8'));\n      const agents = plugin.agents || [];\n      for (const agent of agents) {\n        if (agent.id) {\n          validTypes.add(agent.id);\n        }\n      }\n    } catch {\n      // Ignore\n    }\n  }\n\n  // Source 2: Scan agents/ directory\n  const agentsDirs = [getAgentsDir(), getClaudeAgentsDir()];\n  for (const agentsDir of agentsDirs) {\n    if (existsSync(agentsDir)) {\n      try {\n        const files = readdirSync(agentsDir);\n        for (const file of files) {\n          if (file.endsWith('.md')) {\n            validTypes.add(file.replace('.md', ''));\n          }\n        }\n      } catch {\n        // Ignore\n      }\n    }\n  }\n\n  return validTypes;\n}\n\nfunction extractAgentSkills(agentType: string): string[] {\n  const skills: string[] = [];\n  const agentFiles = [\n    join(getAgentsDir(), `${agentType}.md`),\n    join(getClaudeAgentsDir(), `${agentType}.md`),\n  ];\n\n  let agentFile: string | null = null;\n  for (const file of agentFiles) {\n    if (existsSync(file)) {\n      agentFile = file;\n      break;\n    }\n  }\n\n  if (!agentFile) {\n    return skills;\n  }\n\n  try {\n    const content = readFileSync(agentFile, 'utf8');\n    // Normalize CRLF to LF for cross-platform compatibility (Windows uses \\r\\n)\n    const lines = content.replace(/\\r\\n/g, '\\n').split('\\n');\n\n    let inFrontmatter = false;\n    let inSkills = false;\n\n    for (const line of lines) {\n      if (line === '---') {\n        if (!inFrontmatter) {\n          inFrontmatter = true;\n          continue;\n        } else {\n          break; // End of frontmatter\n        }\n      }\n\n      if (!inFrontmatter) continue;\n\n      if (/^skills:/.test(line)) {\n        inSkills = true;\n        continue;\n      }\n\n      if (inSkills && /^[a-zA-Z]/.test(line) && !/^\\s/.test(line)) {\n        inSkills = false;\n        continue;\n      }\n\n      if (inSkills) {\n        const match = line.match(/^\\s*-\\s*(.+)$/);\n        if (match) {\n          const skillName = match[1].trim();\n          skills.push(skillName);\n        }\n      }\n    }\n  } catch {\n    // Ignore\n  }\n\n  return skills;\n}\n\nfunction validateAgentSkills(agentType: string): string[] {\n  const skills = extractAgentSkills(agentType);\n  const missingSkills: string[] = [];\n  const skillsDir = getSkillsDir();\n\n  for (const skill of skills) {\n    const skillPath = join(skillsDir, skill, 'SKILL.md');\n    if (!existsSync(skillPath)) {\n      missingSkills.push(skill);\n    }\n  }\n\n  return missingSkills;\n}\n\n/**\n * Extract tools list from agent frontmatter YAML (CC 2.1.20)\n */\nfunction extractAgentTools(agentType: string): string[] {\n  const tools: string[] = [];\n  const agentFiles = [\n    join(getAgentsDir(), `${agentType}.md`),\n    join(getClaudeAgentsDir(), `${agentType}.md`),\n  ];\n\n  let agentFile: string | null = null;\n  for (const file of agentFiles) {\n    if (existsSync(file)) {\n      agentFile = file;\n      break;\n    }\n  }\n\n  if (!agentFile) return tools;\n\n  try {\n    const content = readFileSync(agentFile, 'utf8');\n    // Normalize CRLF to LF for cross-platform compatibility (Windows uses \\r\\n)\n    const lines = content.replace(/\\r\\n/g, '\\n').split('\\n');\n    let inFrontmatter = false;\n    let inTools = false;\n\n    for (const line of lines) {\n      if (line === '---') {\n        if (!inFrontmatter) {\n          inFrontmatter = true;\n          continue;\n        } else {\n          break;\n        }\n      }\n      if (!inFrontmatter) continue;\n\n      if (/^tools:/.test(line)) {\n        inTools = true;\n        continue;\n      }\n      if (inTools && /^[a-zA-Z]/.test(line) && !/^\\s/.test(line)) {\n        inTools = false;\n        continue;\n      }\n      if (inTools) {\n        const match = line.match(/^\\s*-\\s*(.+)$/);\n        if (match) {\n          tools.push(match[1].trim());\n        }\n      }\n    }\n  } catch {\n    // Ignore\n  }\n\n  return tools;\n}\n\n/**\n * Generate permission profile markdown for agent (CC 2.1.20)\n */\nfunction getPermissionProfile(agentType: string, tools: string[]): string {\n  if (tools.length === 0) return '';\n\n  const readOnly = tools.every(t => ['Read', 'Glob', 'Grep'].includes(t));\n  const hasBash = tools.includes('Bash');\n  const hasWrite = tools.includes('Write') || tools.includes('Edit');\n\n  let riskLevel = 'low';\n  if (hasBash && hasWrite) riskLevel = 'elevated';\n  else if (hasBash || hasWrite) riskLevel = 'moderate';\n\n  return `## Agent Permission Profile (CC 2.1.20)\n\n**Agent**: \\`${agentType}\\`\n**Tools**: ${tools.join(', ')}\n**Risk Level**: ${riskLevel}${readOnly ? ' (read-only)' : ''}\n\n${hasBash ? '> This agent requests Bash access. Review commands carefully.\\n' : ''}`;\n}\n\nfunction logSpawn(subagentType: string, description: string, sessionId: string): void {\n  const trackingLog = getTrackingLog();\n  const dir = dirname(trackingLog);\n\n  try {\n    mkdirSync(dir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const entry = {\n    timestamp: new Date().toISOString(),\n    subagent_type: subagentType,\n    description: description,\n    session_id: sessionId,\n  };\n\n  try {\n    bufferWrite(trackingLog, `${JSON.stringify(entry)}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function subagentValidator(input: HookInput): HookResult {\n  const toolInput = input.tool_input || {};\n  const subagentType = (toolInput.subagent_type as string) || '';\n  const description = (toolInput.description as string) || '';\n  const sessionId = input.session_id; // CC 2.1.9+ guarantees session_id\n\n  logHook('subagent-validator', `Task invocation: ${subagentType} - ${description}`);\n\n  // Log spawn to tracking file\n  logSpawn(subagentType, description, sessionId);\n\n  // Extract agent type (strip namespace prefix like \"ork:\")\n  const agentTypeOnly = subagentType.replace(/^[^:]+:/, '');\n\n  // Get valid types from multiple sources\n  const validTypes = getValidAgentTypes();\n\n  // Validate\n  if (!validTypes.has(subagentType) && !validTypes.has(agentTypeOnly)) {\n    logHook('subagent-validator', `WARNING: Unknown subagent type: ${subagentType}`);\n  }\n\n  // Log spawn\n  logHook('subagent-validator', `Spawning ${subagentType} agent: ${description}`);\n\n  // Validate agent skills\n  const missingSkills = validateAgentSkills(agentTypeOnly);\n  if (missingSkills.length > 0) {\n    const missingList = missingSkills.join(', ');\n    logHook('subagent-validator', `WARNING: Agent '${agentTypeOnly}' references missing skills: ${missingList}`);\n    // Output warning to stderr (visible to user but non-blocking)\n    console.error(`Warning: Agent '${agentTypeOnly}' references ${missingSkills.length} missing skill(s): ${missingList}`);\n  }\n\n  // CC 2.1.20: Extract agent tools and generate permission profile\n  const agentTools = extractAgentTools(agentTypeOnly);\n  if (agentTools.length > 0) {\n    const permissionProfile = getPermissionProfile(agentTypeOnly, agentTools);\n    logHook('subagent-validator', `Agent '${agentTypeOnly}' tools: ${agentTools.join(', ')}`);\n    return outputWithContext(permissionProfile);\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Model Cost Advisor \u2014 SubagentStart Hook\n *\n * Analyzes task complexity and recommends optimal model for cost savings.\n * Reads agent model assignments from frontmatter at runtime (no hardcoded lists).\n * Uses skill `complexity` field and task description keywords for detection.\n *\n * Addresses: Issue #331\n */\n\nimport { mkdirSync, existsSync, readFileSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { join, dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWarning, logHook, getProjectDir, getPluginRoot } from '../lib/common.js';\n\n// Keyword signals for complexity detection (fallback when frontmatter unavailable)\nconst HIGH_COMPLEXITY_SIGNALS = [\n  /security|vulnerab|audit|penetration/i,\n  /architect|design.*system|distributed/i,\n  /migration.*schema|database.*design/i,\n  /performance.*optim|profil|bottleneck/i,\n  /langgraph|workflow.*orchestrat/i,\n];\n\nconst LOW_COMPLEXITY_SIGNALS = [\n  /\\b(?:list|count|check|verify|read|search)\\b/i,\n  /\\b(?:simple|straightforward|quick)\\b/i,\n  /\\b(?:format|lint|style|typo|rename)\\b/i,\n  /\\b(?:status|progress|summary)\\b/i,\n];\n\ninterface ModelAdvice {\n  recommended: string;\n  current: string;\n  reason: string;\n  savingsPercent: number;\n}\n\n/** Cache agent frontmatter reads for the duration of this process */\nconst agentModelCache = new Map<string, string>();\nconst agentComplexityCache = new Map<string, 'low' | 'medium' | 'high' | null>();\n\n/**\n * Read the model field from an agent's frontmatter.\n * Returns 'opus', 'sonnet', 'haiku', or 'inherit'.\n */\nfunction getAgentModel(agentType: string): string {\n  if (agentModelCache.has(agentType)) {\n    return agentModelCache.get(agentType)!;\n  }\n\n  const pluginRoot = getPluginRoot();\n  if (!pluginRoot) {\n    agentModelCache.set(agentType, 'inherit');\n    return 'inherit';\n  }\n\n  const agentFile = join(pluginRoot, 'agents', `${agentType}.md`);\n  if (!existsSync(agentFile)) {\n    agentModelCache.set(agentType, 'inherit');\n    return 'inherit';\n  }\n\n  try {\n    const content = readFileSync(agentFile, 'utf8');\n    const fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (!fmMatch) {\n      agentModelCache.set(agentType, 'inherit');\n      return 'inherit';\n    }\n\n    const modelMatch = fmMatch[1].match(/^model:\\s*(.+)$/m);\n    const model = modelMatch ? modelMatch[1].trim() : 'inherit';\n    agentModelCache.set(agentType, model);\n    return model;\n  } catch {\n    agentModelCache.set(agentType, 'inherit');\n    return 'inherit';\n  }\n}\n\n/**\n * Read complexity from agent's skill frontmatter fields.\n * Returns the highest complexity among the agent's skills.\n */\nfunction getAgentSkillComplexity(agentType: string): 'low' | 'medium' | 'high' | null {\n  if (agentComplexityCache.has(agentType)) {\n    return agentComplexityCache.get(agentType)!;\n  }\n\n  const pluginRoot = getPluginRoot();\n  if (!pluginRoot) {\n    agentComplexityCache.set(agentType, null);\n    return null;\n  }\n\n  const agentFile = join(pluginRoot, 'agents', `${agentType}.md`);\n  if (!existsSync(agentFile)) {\n    agentComplexityCache.set(agentType, null);\n    return null;\n  }\n\n  try {\n    const content = readFileSync(agentFile, 'utf8');\n    const fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n    if (!fmMatch) {\n      agentComplexityCache.set(agentType, null);\n      return null;\n    }\n\n    const skillsMatch = fmMatch[1].match(/^skills:\\s*\\n((?:\\s+-\\s+.+\\n)*)/m);\n    if (!skillsMatch) {\n      agentComplexityCache.set(agentType, null);\n      return null;\n    }\n\n    const skills = skillsMatch[1].match(/^\\s+-\\s+(.+)$/gm)?.map(s => s.trim().replace(/^-\\s+/, '')) || [];\n    if (skills.length === 0) {\n      agentComplexityCache.set(agentType, null);\n      return null;\n    }\n\n    const complexityOrder = { low: 0, medium: 1, high: 2 };\n    let maxComplexity: 'low' | 'medium' | 'high' = 'low';\n\n    // Sample up to 5 skills for performance\n    for (const skill of skills.slice(0, 5)) {\n      const skillFile = join(pluginRoot, 'skills', skill, 'SKILL.md');\n      if (!existsSync(skillFile)) continue;\n\n      const skillContent = readFileSync(skillFile, 'utf8');\n      const skillFm = skillContent.match(/^---\\n([\\s\\S]*?)\\n---/);\n      if (!skillFm) continue;\n\n      const cMatch = skillFm[1].match(/^complexity:\\s*(low|medium|high)$/m);\n      if (cMatch) {\n        const c = cMatch[1] as 'low' | 'medium' | 'high';\n        if (complexityOrder[c] > complexityOrder[maxComplexity]) {\n          maxComplexity = c;\n        }\n      }\n    }\n\n    agentComplexityCache.set(agentType, maxComplexity);\n    return maxComplexity;\n  } catch {\n    agentComplexityCache.set(agentType, null);\n    return null;\n  }\n}\n\n/**\n * Detect task complexity from description, agent type, and skill frontmatter.\n * Priority: skill frontmatter > keyword heuristics > default medium.\n */\nfunction analyzeComplexity(agentType: string, description: string): 'low' | 'medium' | 'high' {\n  const skillComplexity = getAgentSkillComplexity(agentType);\n  if (skillComplexity === 'high') return 'high';\n\n  const highMatches = HIGH_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;\n  const agentModel = getAgentModel(agentType);\n  if (highMatches >= 2 || agentModel === 'opus') return 'high';\n\n  const lowMatches = LOW_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;\n  if (lowMatches >= 2) return 'low';\n\n  if (skillComplexity) return skillComplexity;\n  return 'medium';\n}\n\n/**\n * Resolve the effective model for an agent (handles 'inherit').\n */\nfunction resolveEffectiveModel(agentType: string): string {\n  const model = getAgentModel(agentType);\n  if (model === 'inherit') {\n    return process.env.CLAUDE_MODEL || 'sonnet';\n  }\n  return model;\n}\n\nfunction getModelAdvice(agentType: string, description: string): ModelAdvice | null {\n  const complexity = analyzeComplexity(agentType, description);\n  const current = resolveEffectiveModel(agentType);\n\n  // High complexity task on cheap model \u2192 recommend upgrade\n  if (complexity === 'high' && current === 'haiku') {\n    return {\n      recommended: 'sonnet',\n      current,\n      reason: 'High-complexity task \u2014 haiku may produce lower quality results',\n      savingsPercent: 0,\n    };\n  }\n\n  // Low complexity task on expensive model \u2192 recommend downgrade\n  if (complexity === 'low' && current === 'opus') {\n    return {\n      recommended: 'sonnet',\n      current,\n      reason: 'Simple task \u2014 sonnet handles this equally well at lower cost',\n      savingsPercent: 40,\n    };\n  }\n\n  // Medium complexity on opus (only if agent doesn't explicitly require opus)\n  if (complexity === 'medium' && current === 'opus' && getAgentModel(agentType) !== 'opus') {\n    return {\n      recommended: 'sonnet',\n      current,\n      reason: 'Medium-complexity task \u2014 sonnet is sufficient',\n      savingsPercent: 30,\n    };\n  }\n\n  return null;\n}\n\nfunction logModelUsage(agentType: string, model: string, complexity: string, advice: ModelAdvice | null): void {\n  const logFile = join(getProjectDir(), '.claude', 'logs', 'model-usage.jsonl');\n  try {\n    mkdirSync(dirname(logFile), { recursive: true });\n    bufferWrite(logFile, `${JSON.stringify({\n      timestamp: new Date().toISOString(),\n      agent: agentType,\n      model,\n      complexity,\n      recommendation: advice?.recommended || null,\n      potentialSavings: advice?.savingsPercent || 0,\n    })}\\n`);\n  } catch {\n    // Non-critical\n  }\n}\n\nexport function modelCostAdvisor(input: HookInput): HookResult {\n  const toolInput = input.tool_input || {};\n  const agentType = (toolInput.subagent_type as string) || '';\n  const description = (toolInput.description as string) || '';\n\n  if (!agentType) {\n    return outputSilentSuccess();\n  }\n\n  const complexity = analyzeComplexity(agentType, description);\n  const currentModel = resolveEffectiveModel(agentType);\n  const advice = getModelAdvice(agentType, description);\n\n  logModelUsage(agentType, currentModel, complexity, advice);\n\n  if (!advice) {\n    logHook('model-cost-advisor', `${agentType}: ${currentModel} appropriate for ${complexity} task`);\n    return outputSilentSuccess();\n  }\n\n  logHook('model-cost-advisor',\n    `${agentType}: Recommend ${advice.recommended} over ${advice.current} (${advice.reason})`,\n    'info'\n  );\n\n  if (advice.savingsPercent >= 30) {\n    return outputWarning(\n      `Model cost: ${agentType} using ${advice.current} for ${complexity}-complexity task. ` +\n      `${advice.reason}. ~${advice.savingsPercent}% savings with \"${advice.recommended}\".`\n    );\n  }\n\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-15\n\n/**\n * Issue Context Injector - SubagentStart Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * When on an issue branch (e.g., issue/123-add-auth), injects the GitHub\n * issue details into the subagent's context so it references the issue\n * in commits and PR descriptions.\n *\n * Graceful degradation: if gh fails, branch doesn't match, or anything\n * goes wrong, returns silent success. Never blocks agent spawning.\n *\n * Version: 1.0.0\n */\n\nimport { existsSync, readFileSync, writeFileSync, statSync, mkdirSync } from 'node:fs';\nimport { execFileSync } from 'node:child_process';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, getCachedBranch } from '../lib/common.js';\n\n/** Dedicated cache directory with restricted permissions */\nconst CACHE_DIR = join(tmpdir(), 'orchestkit-issue-cache');\n\n/** Cache TTL in milliseconds (5 minutes) */\nconst CACHE_TTL_MS = 5 * 60 * 1000;\n\n/** Timeout for gh CLI in milliseconds */\nconst GH_TIMEOUT_MS = 3000;\n\ninterface IssueData {\n  title?: string;\n  body?: string;\n  labels?: Array<{ name: string }>;\n}\n\n/**\n * Extract issue number from branch name.\n * Matches patterns like: issue/123-foo, fix/456-bar, feat/789-baz,\n * bug/10-thing, hotfix/11-thing, or just 123-some-description.\n */\nfunction extractIssueNumber(branch: string): string | null {\n  const match = branch.match(/^(?:issue|fix|feat|bug|hotfix|feature)\\/(\\d+)/) ||\n    branch.match(/^(\\d+)-/);\n  return match ? match[1] : null;\n}\n\n/**\n * Get cached issue data if fresh enough.\n */\nfunction ensureCacheDir(): void {\n  try {\n    mkdirSync(CACHE_DIR, { recursive: true, mode: 0o700 });\n  } catch {\n    // Directory may already exist\n  }\n}\n\nfunction getCachedIssue(issueNum: string): IssueData | null {\n  const cachePath = join(CACHE_DIR, `${issueNum}.json`);\n  try {\n    if (!existsSync(cachePath)) return null;\n    const stats = statSync(cachePath);\n    const ageMs = Date.now() - stats.mtimeMs;\n    if (ageMs > CACHE_TTL_MS) return null;\n    return JSON.parse(readFileSync(cachePath, 'utf8'));\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Fetch issue data from GitHub CLI and cache it.\n */\nfunction fetchAndCacheIssue(issueNum: string, projectDir: string): IssueData | null {\n  // Defense-in-depth: validate issue number is purely numeric\n  if (!/^\\d+$/.test(issueNum)) return null;\n\n  try {\n    const output = execFileSync(\n      'gh',\n      ['issue', 'view', issueNum, '--json', 'title,body,labels'],\n      {\n        cwd: projectDir,\n        encoding: 'utf8',\n        timeout: GH_TIMEOUT_MS,\n        stdio: ['pipe', 'pipe', 'pipe'],\n      }\n    ).trim();\n\n    const data: IssueData = JSON.parse(output);\n    try {\n      ensureCacheDir();\n      const cachePath = join(CACHE_DIR, `${issueNum}.json`);\n      writeFileSync(cachePath, JSON.stringify(data), 'utf8');\n    } catch {\n      // Cache write failure is non-critical\n    }\n    return data;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Build context message from issue data.\n */\nfunction buildContextMessage(issueNum: string, issue: IssueData | null): string {\n  const parts: string[] = [];\n\n  if (issue?.title) {\n    parts.push(`Working on GitHub Issue #${issueNum}: ${issue.title}`);\n  } else {\n    parts.push(`Working on GitHub Issue #${issueNum}`);\n  }\n\n  if (issue?.labels && issue.labels.length > 0) {\n    const labelNames = issue.labels.map((l) => l.name).join(', ');\n    parts.push(`Labels: ${labelNames}`);\n  }\n\n  parts.push(`Reference #${issueNum} in all commits. Use 'Closes #${issueNum}' in PR description.`);\n\n  return parts.join('\\n');\n}\n\nexport function issueContextInjector(_input: HookInput): HookResult {\n  try {\n    const projectDir = getProjectDir();\n    const branch = getCachedBranch(projectDir);\n\n    logHook('issue-context-injector', `Branch: ${branch}`);\n\n    const issueNum = extractIssueNumber(branch);\n    if (!issueNum) {\n      logHook('issue-context-injector', 'No issue number in branch name');\n      return outputSilentSuccess();\n    }\n\n    logHook('issue-context-injector', `Detected issue #${issueNum}`);\n\n    // Try cache first, then fetch from gh\n    const issue = getCachedIssue(issueNum) ?? fetchAndCacheIssue(issueNum, projectDir);\n    const contextMsg = buildContextMessage(issueNum, issue);\n\n    logHook('issue-context-injector', `Injecting context for issue #${issueNum}`);\n\n    return {\n      continue: true,\n      systemMessage: contextMsg,\n    };\n  } catch {\n    logHook('issue-context-injector', 'Unexpected error, falling back to silent success', 'warn');\n    return outputSilentSuccess();\n  }\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-20\n\n/**\n * Unified SubagentStart Dispatcher\n * Consolidates 6 SubagentStart hooks into a single process spawn.\n *\n * Issue #685: Reduces 6 separate process spawns to 1 for SubagentStart.\n *\n * Hooks consolidated here (execution order):\n * Phase 1 \u2014 Blocking:\n *   - context-gate (can block when too many concurrent agents)\n * Phase 2 \u2014 Validation + tracking:\n *   - subagent-validator (validates agent type, logs spawn, permission profile)\n * Phase 3 \u2014 Context injection (budget-capped):\n *   - subagent-context-stager (CLAUDE.md rules, pending tasks, decisions)\n *   - graph-memory-inject (knowledge graph context)\n *   - model-cost-advisor (cost optimization warnings)\n *   - issue-context-injector (GitHub issue context from branch name)\n *\n * CC 2.1.49 Compliant: Single consolidated output with 800-token budget\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  logHook,\n  estimateTokenCount,\n  extractContext,\n} from '../lib/common.js';\n\n// Import hook implementations\nimport { contextGate } from './context-gate.js';\nimport { subagentValidator } from './subagent-validator.js';\nimport { subagentContextStager } from './subagent-context-stager.js';\nimport { graphMemoryInject } from './graph-memory-inject.js';\nimport { modelCostAdvisor } from './model-cost-advisor.js';\nimport { issueContextInjector } from './issue-context-injector.js';\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\nconst HOOK_NAME = 'subagent-start-dispatcher';\n\n/** Maximum total tokens for consolidated context output */\nconst MAX_OUTPUT_TOKENS = 800;\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult;\n\ninterface ContextHookConfig {\n  name: string;\n  fn: HookFn;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Registry \u2014 context-producing hooks (Phase 3)\n// -----------------------------------------------------------------------------\n\nconst CONTEXT_HOOKS: ContextHookConfig[] = [\n  { name: 'subagent-context-stager', fn: subagentContextStager },\n  { name: 'graph-memory-inject', fn: graphMemoryInject },\n  { name: 'model-cost-advisor', fn: modelCostAdvisor },\n  { name: 'issue-context-injector', fn: issueContextInjector },\n];\n\n/** Exposed for testing */\nexport const registeredHookNames = () => [\n  'context-gate',\n  'subagent-validator',\n  ...CONTEXT_HOOKS.map(h => h.name),\n];\n\n// extractContext imported from ../lib/common.js (Issue #682)\n\n// -----------------------------------------------------------------------------\n// Dispatcher Implementation\n// -----------------------------------------------------------------------------\n\nexport function unifiedSubagentStartDispatcher(input: HookInput): HookResult {\n  // --- Phase 1: Blocking check (context-gate) ---\n  try {\n    const gateResult = contextGate(input);\n    if (!gateResult.continue) {\n      logHook(HOOK_NAME, 'context-gate blocked agent spawn');\n      return gateResult;\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    logHook(HOOK_NAME, `context-gate failed: ${message}`, 'warn');\n  }\n\n  // --- Phase 2: Validation + tracking (subagent-validator) ---\n  let validatorContext: string | null = null;\n  try {\n    const validatorResult = subagentValidator(input);\n    validatorContext = extractContext(validatorResult);\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    logHook(HOOK_NAME, `subagent-validator failed: ${message}`, 'warn');\n  }\n\n  // --- Phase 3: Context injection hooks (budget-capped) ---\n  const contextParts: string[] = [];\n  const systemMessages: string[] = [];\n  let totalTokens = 0;\n\n  // Add validator context first (high priority \u2014 permission profile)\n  if (validatorContext) {\n    const tokens = estimateTokenCount(validatorContext);\n    contextParts.push(validatorContext);\n    totalTokens += tokens;\n  }\n\n  for (const hook of CONTEXT_HOOKS) {\n    try {\n      const result = hook.fn(input);\n\n      // Collect systemMessage separately (merged at end)\n      if (result.systemMessage && typeof result.systemMessage === 'string') {\n        systemMessages.push(result.systemMessage);\n      }\n\n      // Collect additionalContext with budget enforcement\n      const context = result.hookSpecificOutput?.additionalContext as string | undefined;\n      if (context) {\n        const contextTokens = estimateTokenCount(context);\n        if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {\n          logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);\n          continue;\n        }\n        contextParts.push(context);\n        totalTokens += contextTokens;\n        logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');\n    }\n  }\n\n  // --- Combine results ---\n  const hasContext = contextParts.length > 0;\n  const hasSystemMessage = systemMessages.length > 0;\n\n  if (!hasContext && !hasSystemMessage) {\n    return outputSilentSuccess();\n  }\n\n  const result: HookResult = { continue: true };\n\n  if (hasSystemMessage) {\n    // Intentional: concatenate all system messages. In practice only subagent-validator\n    // emits systemMessage (permission profile). If multiple hooks emit, first-wins may\n    // be preferable \u2014 monitor for verbose output.\n    result.systemMessage = systemMessages.join('\\n\\n');\n  }\n\n  if (hasContext) {\n    const consolidated = contextParts.join('\\n\\n---\\n\\n');\n    logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);\n    result.hookSpecificOutput = {\n      additionalContext: consolidated,\n    };\n  }\n\n  return result;\n}\n", "/**\n * Agent Memory Store - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Extracts and stores successful patterns after agent completion.\n *\n * Strategy:\n * - Parse agent output for decision patterns\n * - Extract key architectural choices\n * - Log patterns for graph memory storage\n * - Track agent performance metrics\n * - Detect categories for proper organization\n *\n * Version: 2.1.0 (graph-first)\n */\n\nimport { existsSync, mkdirSync, unlinkSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { basename, dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, getProjectDir, lineContainsAll } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst DECISION_PATTERNS = [\n  'decided to',\n  'chose',\n  'implemented using',\n  'selected',\n  'opted for',\n  'will use',\n  'pattern:',\n  'approach:',\n  'architecture:',\n  'recommends',\n  'best practice',\n  'anti-pattern',\n  'learned that',\n];\n\nconst SCOPE_DECISIONS = 'decisions';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getPatternsLog(): string {\n  return `${getProjectDir()}/.claude/logs/agent-patterns.jsonl`;\n}\n\nfunction getAgentTrackingDir(): string {\n  return `${getProjectDir()}/.claude/session`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction getProjectId(): string {\n  const projectDir = getProjectDir();\n  const projectName = basename(projectDir) || 'default-project';\n  return projectName\n    .toLowerCase()\n    .replace(/ /g, '-')\n    .replace(/[^a-z0-9-]/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .replace(/-+/g, '-');\n}\n\nfunction scopedId(scope: string): string {\n  return `${getProjectId()}-${scope}`;\n}\n\n/**\n * Detect pattern category from text content\n */\nfunction detectPatternCategory(text: string): string {\n  // Security: Limit input length to prevent performance issues\n  const maxLength = 10240;\n  const truncatedText = text.length > maxLength ? text.substring(0, maxLength) : text;\n  const textLower = truncatedText.toLowerCase();\n\n  if (/pagination|cursor|offset/.test(textLower)) {\n    return 'pagination';\n  }\n  if (/security|vulnerability|exploit|injection|xss|csrf|owasp|safety|guardrail/.test(textLower)) {\n    return 'security';\n  }\n  if (/database|sql|postgres|schema/.test(textLower)) {\n    return 'database';\n  }\n  if (/\\bapi\\b|endpoint|\\brest\\b|graphql/.test(textLower)) {\n    return 'api';\n  }\n  if (/auth|login|jwt|oauth/.test(textLower)) {\n    return 'authentication';\n  }\n  if (/\\btest\\b|testing|pytest|jest|vitest|coverage|\\bmock\\b|fixture|\\bspec\\b/.test(textLower)) {\n    return 'testing';\n  }\n  if (/deploy|\\bci\\b|\\bcd\\b|pipeline|docker|kubernetes|helm|terraform/.test(textLower)) {\n    return 'deployment';\n  }\n  if (/observability|monitoring|logging|tracing|metrics|prometheus|grafana|langfuse/.test(textLower)) {\n    return 'observability';\n  }\n  if (/react|component|frontend|\\bui\\b/.test(textLower)) {\n    return 'frontend';\n  }\n  if (/performance|optimization|cache|index/.test(textLower)) {\n    return 'performance';\n  }\n  if (/llm|\\brag\\b|embedding|vector|semantic|\\bai\\b|\\bml\\b|langchain|langgraph|openai|anthropic/.test(textLower)) {\n    return 'ai-ml';\n  }\n  if (/etl|streaming|dataflow|spark/.test(textLower) || lineContainsAll(textLower, 'data', 'pipeline') || lineContainsAll(textLower, 'batch', 'processing')) {\n    return 'data-pipeline';\n  }\n  if (/architecture|design|structure/.test(textLower)) {\n    return 'architecture';\n  }\n  if (/decided|chose|selected/.test(textLower)) {\n    return 'decision';\n  }\n  return 'pattern';\n}\n\n/**\n * Extract patterns from agent output\n */\nfunction extractPatterns(output: string): string[] {\n  const patterns: string[] = [];\n\n  if (output.length < 50) {\n    return patterns;\n  }\n\n  for (const pattern of DECISION_PATTERNS) {\n    // ReDoS-safe: use line-based includes instead of polynomial regex ^.*pattern.*$\n    const patternLower = pattern.toLowerCase();\n    const matches = output.split('\\n').filter(line =>\n      line.toLowerCase().includes(patternLower)\n    );\n\n    for (const match of matches) {\n      const cleaned = match.trim().substring(0, 200);\n      if (cleaned.length > 20) {\n        patterns.push(cleaned);\n      }\n    }\n  }\n\n  // Deduplicate and limit\n  const unique = [...new Set(patterns)];\n  return unique.slice(0, 5);\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function agentMemoryStore(input: HookInput): HookResult {\n  logHook('agent-memory-store', 'Agent memory store hook starting');\n\n  const toolInput = input.tool_input || {};\n  const agentType = input.subagent_type || (toolInput.subagent_type as string) || (toolInput.type as string) || '';\n  const rawResult = input.tool_result;\n  const agentOutput = typeof rawResult === 'string'\n    ? rawResult\n    : (rawResult?.content || input.agent_output || input.output || '');\n  let success = true;\n\n  // Check for error in output\n  if (input.error) {\n    success = false;\n  }\n\n  // Check for is_error in tool_result object\n  if (typeof rawResult === 'object' && rawResult?.is_error) {\n    success = false;\n  }\n\n  // If no agent type, silent success\n  if (!agentType) {\n    logHook('agent-memory-store', 'No agent type in input, skipping');\n    return outputSilentSuccess();\n  }\n\n  // Build agent_id from AGENT_TYPE\n  const agentId = `ork:${agentType}`;\n\n  // Clean up tracking file to prevent stale data\n  const trackingFile = `${getAgentTrackingDir()}/current-agent-id`;\n  try {\n    if (existsSync(trackingFile)) {\n      unlinkSync(trackingFile);\n    }\n  } catch {\n    // Ignore\n  }\n\n  logHook('agent-memory-store', `Processing completion for agent: ${agentType} (agent_id: ${agentId}, success: ${success})`);\n\n  // Extract patterns (only if successful)\n  const extractedPatterns = success && agentOutput ? extractPatterns(agentOutput) : [];\n\n  if (extractedPatterns.length === 0) {\n    logHook('agent-memory-store', `No patterns extracted from ${agentType} output`);\n    return outputSilentSuccess();\n  }\n\n  // Log patterns for storage\n  const patternsLog = getPatternsLog();\n  const logDir = dirname(patternsLog);\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const projectId = getProjectId();\n  const timestamp = new Date().toISOString();\n  const decisionsId = scopedId(SCOPE_DECISIONS);\n\n  for (const pattern of extractedPatterns) {\n    const category = detectPatternCategory(pattern);\n\n    const entry = {\n      agent: agentType,\n      agent_id: agentId,\n      pattern: pattern,\n      project: projectId,\n      timestamp: timestamp,\n      scope_id: decisionsId,\n      category: category,\n      pending_graph_sync: true,\n    };\n\n    try {\n      bufferWrite(patternsLog, `${JSON.stringify(entry)}\\n`);\n    } catch {\n      // Ignore\n    }\n\n    logHook('agent-memory-store', `Extracted pattern (${category}): ${pattern.substring(0, 50)}...`);\n  }\n\n  logHook('agent-memory-store', `Extracted ${extractedPatterns.length} patterns from ${agentType} output`);\n\n  // Build suggestion message for graph storage\n  const systemMsg = `[Pattern Extraction] ${extractedPatterns.length} patterns extracted from ${agentType}. To persist, use mcp__memory__create_entities with entities: [{\"name\": \"${agentType}-pattern\", \"entityType\": \"Pattern\", \"observations\": [\"<pattern>\"]}]`;\n\n  return {\n    continue: true,\n    systemMessage: systemMsg,\n  };\n}\n", "/**\n * Auto Spawn Quality - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Purpose:\n * - Auto-spawns code-quality-reviewer after test-generator completes\n * - Auto-spawns security-auditor on sensitive file changes\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, readFileSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst SENSITIVE_PATTERNS = [\n  '.env',\n  'credentials',\n  'secret',\n  'auth',\n  'password',\n  'token',\n  'api.key',\n  'private.key',\n  '.pem',\n  'oauth',\n  'jwt',\n  'session',\n  'cookie',\n  'encryption',\n  'crypto',\n];\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getSpawnLog(): string {\n  const logDir = `${getProjectDir()}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return `${logDir}/auto-spawn-quality.log`;\n}\n\nfunction getSpawnQueue(): string {\n  return `${getProjectDir()}/.claude/context/spawn-queue.json`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logSpawn(message: string): void {\n  const logFile = getSpawnLog();\n  const timestamp = new Date().toISOString();\n  try {\n    bufferWrite(logFile, `[${timestamp}] [auto-spawn-quality] ${message}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\nfunction containsSensitiveFiles(output: string): boolean {\n  const lowerOutput = output.toLowerCase();\n  for (const pattern of SENSITIVE_PATTERNS) {\n    if (lowerOutput.includes(pattern)) {\n      logSpawn(`Detected sensitive pattern: ${pattern}`);\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface SpawnRequest {\n  spawn_id: string;\n  target_agent: string;\n  trigger_agent: string;\n  trigger_reason: string;\n  priority: string;\n  timestamp: string;\n  session_id: string;\n  status: string;\n}\n\ninterface SpawnQueue {\n  schema_version: string;\n  created_at: string;\n  queue: SpawnRequest[];\n}\n\nfunction queueSpawn(\n  agentType: string,\n  targetAgent: string,\n  triggerReason: string,\n  priority: string,\n  sessionId: string,\n  timestamp: string\n): string {\n  const spawnId = `SPAWN-${new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 14)}-${Math.floor(Math.random() * 10000)\n    .toString()\n    .padStart(4, '0')}`;\n\n  const spawnQueue = getSpawnQueue();\n  const queueDir = dirname(spawnQueue);\n\n  try {\n    mkdirSync(queueDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  let queue: SpawnQueue;\n  if (existsSync(spawnQueue)) {\n    try {\n      queue = JSON.parse(readFileSync(spawnQueue, 'utf8'));\n    } catch {\n      queue = {\n        schema_version: '1.0.0',\n        created_at: timestamp,\n        queue: [],\n      };\n    }\n  } else {\n    queue = {\n      schema_version: '1.0.0',\n      created_at: timestamp,\n      queue: [],\n    };\n  }\n\n  const request: SpawnRequest = {\n    spawn_id: spawnId,\n    target_agent: targetAgent,\n    trigger_agent: agentType,\n    trigger_reason: triggerReason,\n    priority: priority,\n    timestamp: timestamp,\n    session_id: sessionId,\n    status: 'queued',\n  };\n\n  queue.queue.push(request);\n\n  try {\n    writeFileSync(spawnQueue, JSON.stringify(queue, null, 2));\n    logSpawn(`Queued spawn request: ${spawnId} for ${targetAgent} (reason: ${triggerReason})`);\n  } catch {\n    logSpawn(`ERROR: Failed to queue spawn request for ${targetAgent}`);\n    return '';\n  }\n\n  return spawnId;\n}\n\nfunction writeSpawnSuggestion(\n  agentType: string,\n  targetAgent: string,\n  triggerReason: string,\n  priority: string,\n  sessionId: string,\n  timestamp: string\n): void {\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const suggestionFile = `${handoffDir}/auto_spawn_${targetAgent}_${new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 15)}.json`;\n\n  const suggestion = {\n    type: 'auto_spawn_suggestion',\n    from_agent: agentType,\n    to_agent: targetAgent,\n    timestamp: timestamp,\n    trigger_reason: triggerReason,\n    priority: priority,\n    session_id: sessionId,\n    auto_triggered: true,\n    status: 'suggested',\n  };\n\n  try {\n    writeFileSync(suggestionFile, JSON.stringify(suggestion, null, 2));\n    logSpawn(`Created spawn suggestion: ${targetAgent} (reason: ${triggerReason})`);\n  } catch {\n    // Ignore\n  }\n}\n\ninterface SpawnInfo {\n  target: string;\n  reason: string;\n  priority: string;\n}\n\nfunction checkAutoSpawnConditions(agentType: string, agentOutput: string, error: string): SpawnInfo | null {\n  // Skip if agent had errors\n  if (error && error !== 'null') {\n    logSpawn(`Skipping auto-spawn - agent ${agentType} had errors: ${error}`);\n    return null;\n  }\n\n  // Rule 1: test-generator completion -> code-quality-reviewer\n  if (agentType === 'test-generator') {\n    logSpawn('Rule matched: test-generator -> code-quality-reviewer');\n    return {\n      target: 'code-quality-reviewer',\n      reason: 'test-generator completed - validating test quality and coverage',\n      priority: 'high',\n    };\n  }\n\n  // Rule 2: Any agent with sensitive file changes -> security-auditor\n  if (containsSensitiveFiles(agentOutput)) {\n    if (agentType !== 'security-auditor' && agentType !== 'security-layer-auditor') {\n      logSpawn('Rule matched: sensitive files detected -> security-auditor');\n      return {\n        target: 'security-auditor',\n        reason: 'sensitive file changes detected - security audit required',\n        priority: 'critical',\n      };\n    }\n  }\n\n  // Rule 3: code-quality-reviewer completion -> security-auditor\n  if (agentType === 'code-quality-reviewer') {\n    logSpawn('Rule matched: code-quality-reviewer -> security-auditor');\n    return {\n      target: 'security-auditor',\n      reason: 'code-quality-reviewer completed - proceeding with security scan',\n      priority: 'high',\n    };\n  }\n\n  // Rule 4: backend-system-architect with auth/security mentions -> security-layer-auditor\n  if (agentType === 'backend-system-architect') {\n    const lowerOutput = agentOutput.toLowerCase();\n    if (/authentication|authorization|security|access.control|rbac|acl/.test(lowerOutput)) {\n      logSpawn('Rule matched: backend-system-architect with auth -> security-layer-auditor');\n      return {\n        target: 'security-layer-auditor',\n        reason: 'backend-system-architect designed auth/security layer - validation required',\n        priority: 'high',\n      };\n    }\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function autoSpawnQuality(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const sessionId = input.session_id; // CC 2.1.9+ guarantees session_id\n  const agentOutput = input.agent_output || input.output || '';\n  const error = input.error || '';\n\n  logSpawn(`Checking auto-spawn conditions for agent: ${agentType} (session: ${sessionId})`);\n\n  // Skip if unknown agent type\n  if (agentType === 'unknown' || !agentType) {\n    logSpawn('Skipping unknown agent type');\n    return outputSilentSuccess();\n  }\n\n  // Check auto-spawn conditions\n  const spawnInfo = checkAutoSpawnConditions(agentType, agentOutput, error);\n\n  if (spawnInfo) {\n    // Queue the spawn request\n    const spawnId = queueSpawn(\n      agentType,\n      spawnInfo.target,\n      spawnInfo.reason,\n      spawnInfo.priority,\n      sessionId,\n      timestamp\n    );\n\n    // Write spawn suggestion for orchestrator\n    writeSpawnSuggestion(\n      agentType,\n      spawnInfo.target,\n      spawnInfo.reason,\n      spawnInfo.priority,\n      sessionId,\n      timestamp\n    );\n\n    // Log the action\n    logSpawn(`=== AUTO-SPAWN QUALITY HOOK ===\nTrigger Agent: ${agentType}\nTarget Agent: ${spawnInfo.target}\nReason: ${spawnInfo.reason}\nPriority: ${spawnInfo.priority}\nSpawn ID: ${spawnId}\nTimestamp: ${timestamp}\nSession: ${sessionId}`);\n\n    return {\n      continue: true,\n      systemMessage: `Auto-spawn queued: ${spawnInfo.target} (${spawnInfo.priority} priority)`,\n    };\n  }\n\n  logSpawn(`No auto-spawn conditions matched for ${agentType}`);\n  return outputSilentSuccess();\n}\n", "/**\n * Context Publisher - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Publishes agent decisions to context (Context Protocol 2.0).\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, readFileSync } from 'node:fs';\nimport { dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getDecisionsFile(): string {\n  return `${getProjectDir()}/.claude/context/knowledge/decisions/active.json`;\n}\n\nfunction getSessionState(): string {\n  return `${getProjectDir()}/.claude/context/session/state.json`;\n}\n\nfunction getLogDir(): string {\n  return `${getProjectDir()}/.claude/logs/agent-context`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\ninterface DecisionEntry {\n  timestamp: string;\n  agent: string;\n  summary: string;\n  status: string;\n}\n\ninterface DecisionsFile {\n  schema_version: string;\n  decisions: Record<string, DecisionEntry>;\n}\n\ninterface TaskEntry {\n  agent: string;\n  timestamp: string;\n  summary: string;\n}\n\ninterface SessionState {\n  schema_version: string;\n  session_id: string;\n  started_at: string;\n  last_activity: string;\n  active_agent: string | null;\n  tasks_pending: string[];\n  tasks_completed: TaskEntry[];\n}\n\nfunction ensureDir(dirPath: string): void {\n  try {\n    mkdirSync(dirPath, { recursive: true });\n  } catch {\n    // Ignore\n  }\n}\n\nfunction readJsonFile<T>(filePath: string, defaultValue: T): T {\n  if (!existsSync(filePath)) {\n    return defaultValue;\n  }\n  try {\n    return JSON.parse(readFileSync(filePath, 'utf8')) as T;\n  } catch {\n    return defaultValue;\n  }\n}\n\nfunction writeJsonFile(filePath: string, data: unknown): void {\n  const dir = dirname(filePath);\n  ensureDir(dir);\n  try {\n    writeFileSync(filePath, JSON.stringify(data, null, 2));\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Constants\n// -----------------------------------------------------------------------------\n\n/** Maximum completed tasks to retain in session state */\nconst MAX_COMPLETED_TASKS = 50;\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function contextPublisher(input: HookInput): HookResult {\n  const agentName = input.subagent_type || input.agent_type || 'unknown';\n  const timestamp = new Date().toISOString();\n\n  // Read agent output from input\n  const output = input.agent_output || input.output || '';\n\n  // Extract summary from output (first 200 chars)\n  let summary = output.substring(0, 200);\n  if (output.length > 200) {\n    summary += '...';\n  }\n\n  // Skip recording empty/unknown task entries \u2014 they bloat state.json\n  const hasContent = agentName !== 'unknown' || summary.trim().length > 0;\n\n  // Create agent key (replace hyphens with underscores for JSON)\n  const agentKey = agentName.replace(/-/g, '_');\n\n  // === Update Decisions File (Context Protocol 2.0) ===\n  // Only write decisions for identified agents with output\n  if (hasContent) {\n    const decisionsFile = getDecisionsFile();\n    const decisionsDir = dirname(decisionsFile);\n    ensureDir(decisionsDir);\n\n    const defaultDecisions: DecisionsFile = {\n      schema_version: '2.0.0',\n      decisions: {},\n    };\n\n    const decisions = readJsonFile(decisionsFile, defaultDecisions);\n\n    // Ensure decisions object exists (defensive against old schema versions)\n    if (!decisions.decisions || typeof decisions.decisions !== 'object') {\n      decisions.decisions = {};\n    }\n\n    const decisionEntry: DecisionEntry = {\n      timestamp,\n      agent: agentName,\n      summary,\n      status: 'completed',\n    };\n\n    decisions.decisions[agentKey] = decisionEntry;\n    writeJsonFile(decisionsFile, decisions);\n  }\n\n  // === Update Session State (Context Protocol 2.0) ===\n  const sessionStateFile = getSessionState();\n  const sessionDir = dirname(sessionStateFile);\n  ensureDir(sessionDir);\n\n  const defaultState: SessionState = {\n    schema_version: '2.0.0',\n    session_id: '',\n    started_at: timestamp,\n    last_activity: timestamp,\n    active_agent: null,\n    tasks_pending: [],\n    tasks_completed: [],\n  };\n\n  const sessionState = readJsonFile(sessionStateFile, defaultState);\n\n  // Ensure arrays exist (defensive against old schema versions)\n  if (!Array.isArray(sessionState.tasks_completed)) {\n    sessionState.tasks_completed = [];\n  }\n  if (!Array.isArray(sessionState.tasks_pending)) {\n    sessionState.tasks_pending = [];\n  }\n\n  // Only record tasks with meaningful content (fixes #449: empty entries bloat)\n  if (hasContent) {\n    const taskEntry: TaskEntry = {\n      agent: agentName,\n      timestamp,\n      summary,\n    };\n\n    sessionState.tasks_completed.push(taskEntry);\n\n    // Cap array size \u2014 keep most recent entries (fixes #449: unbounded growth)\n    if (sessionState.tasks_completed.length > MAX_COMPLETED_TASKS) {\n      sessionState.tasks_completed = sessionState.tasks_completed.slice(-MAX_COMPLETED_TASKS);\n    }\n  }\n\n  sessionState.last_activity = timestamp;\n  sessionState.active_agent = null;\n\n  writeJsonFile(sessionStateFile, sessionState);\n\n  // === Logging ===\n  const logDir = getLogDir();\n  ensureDir(logDir);\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== CONTEXT PUBLICATION (Protocol 2.0) ===\nAgent: ${agentName}\nTimestamp: ${timestamp}\nDecisions file: ${getDecisionsFile()}\nSession state: ${sessionStateFile}\n\n=== AGENT OUTPUT ===\n${output}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Feedback Loop - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n * CC 2.1.16 Compliant: Integrates with Task Management System\n *\n * Purpose:\n * - Captures agent completion context\n * - Routes findings to relevant downstream agents\n * - Logs to decision-log.json\n * - Updates CC 2.1.16 Task status (Issue #197)\n *\n * Version: 2.0.0 (Task Integration)\n */\n\nimport { existsSync, writeFileSync, mkdirSync, readFileSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport { dirname } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\nimport { getTaskByAgent, updateTaskStatus, getActivePipeline } from '../lib/task-integration.js';\nimport { PIPELINES } from '../lib/multi-agent-coordinator.js';\nimport { isAgentTeamsActive } from '../lib/agent-teams.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getDecisionLog(): string {\n  return `${getProjectDir()}/.claude/coordination/decision-log.json`;\n}\n\nfunction getFeedbackLog(): string {\n  const logDir = `${getProjectDir()}/.claude/hooks/logs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return `${logDir}/agent-feedback.log`;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logFeedback(message: string): void {\n  const logFile = getFeedbackLog();\n  const timestamp = new Date().toISOString();\n  try {\n    bufferWrite(logFile, `[${timestamp}] [feedback-loop] ${message}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\n/**\n * Get downstream agents from PIPELINES definitions or fallback mapping\n */\nfunction getDownstreamAgents(agent: string): string {\n  // First, check if agent is part of an active pipeline\n  const activePipeline = getActivePipeline();\n  if (activePipeline) {\n    const pipelineDef = PIPELINES.find(p => p.type === activePipeline.type);\n    if (pipelineDef) {\n      // Find current step\n      const currentStepIdx = pipelineDef.steps.findIndex(s => s.agent === agent);\n      if (currentStepIdx >= 0) {\n        // Get next steps that depend on this one\n        const nextAgents = pipelineDef.steps\n          .filter((s, idx) => s.dependsOn.includes(currentStepIdx) && idx > currentStepIdx)\n          .map(s => s.agent);\n        if (nextAgents.length > 0) {\n          return nextAgents.join(' ');\n        }\n      }\n    }\n  }\n\n  // Fallback: static mapping for non-pipeline scenarios\n  const mapping: Record<string, string> = {\n    // Product thinking pipeline\n    'market-intelligence': 'product-strategist',\n    'product-strategist': 'prioritization-analyst',\n    'prioritization-analyst': 'business-case-builder',\n    'business-case-builder': 'requirements-translator',\n    'requirements-translator': 'metrics-architect',\n    'metrics-architect': 'backend-system-architect',\n    // Full-stack pipeline\n    'backend-system-architect': 'frontend-ui-developer',\n    'frontend-ui-developer': 'test-generator',\n    'test-generator': 'security-auditor',\n    // AI integration pipeline\n    'workflow-architect': 'llm-integrator',\n    'llm-integrator': 'data-pipeline-engineer',\n    'data-pipeline-engineer': 'test-generator',\n    // UI pipeline\n    'rapid-ui-designer': 'frontend-ui-developer',\n    'ux-researcher': 'rapid-ui-designer',\n  };\n\n  return mapping[agent] || '';\n}\n\n/**\n * Categorize feedback based on agent type\n */\nfunction getFeedbackCategory(agent: string): string {\n  const categories: Record<string, string> = {\n    'market-intelligence': 'product-thinking',\n    'product-strategist': 'product-thinking',\n    'prioritization-analyst': 'product-thinking',\n    'business-case-builder': 'product-thinking',\n    'requirements-translator': 'specification',\n    'metrics-architect': 'specification',\n    'backend-system-architect': 'architecture',\n    'database-engineer': 'architecture',\n    'data-pipeline-engineer': 'architecture',\n    'frontend-ui-developer': 'frontend',\n    'rapid-ui-designer': 'frontend',\n    'ux-researcher': 'frontend',\n    'test-generator': 'quality',\n    'code-quality-reviewer': 'quality',\n    'security-auditor': 'security',\n    'security-layer-auditor': 'security',\n    'workflow-architect': 'ai-integration',\n    'llm-integrator': 'ai-integration',\n    'debug-investigator': 'debugging',\n  };\n\n  return categories[agent] || 'general';\n}\n\n/**\n * Get instance ID consistently\n */\nfunction getInstanceId(): string {\n  return process.env.CLAUDE_INSTANCE_ID || `${require('node:os').hostname()}-${process.pid}`;\n}\n\nfunction extractFindingsSummary(output: string): string {\n  let summary = output.substring(0, 500);\n  if (output.length > 500) {\n    summary += '...';\n  }\n  return summary;\n}\n\ninterface DecisionEntry {\n  decision_id: string;\n  timestamp: string;\n  made_by: {\n    instance_id: string;\n    agent_type: string;\n  };\n  category: string;\n  title: string;\n  description: string;\n  impact: {\n    scope: string;\n    downstream_agents: string[];\n  };\n  status: string;\n  task_id?: string;  // CC 2.1.16 integration\n}\n\ninterface DecisionLog {\n  schema_version: string;\n  log_created_at: string;\n  decisions: DecisionEntry[];\n}\n\nfunction writeDecision(\n  decisionId: string,\n  agentType: string,\n  category: string,\n  summary: string,\n  downstreamAgents: string,\n  status: string,\n  timestamp: string,\n  taskId?: string\n): void {\n  const decisionLog = getDecisionLog();\n  const logDir = dirname(decisionLog);\n\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  let log: DecisionLog;\n  if (existsSync(decisionLog)) {\n    try {\n      log = JSON.parse(readFileSync(decisionLog, 'utf8'));\n    } catch {\n      log = {\n        schema_version: '2.0.0',\n        log_created_at: timestamp,\n        decisions: [],\n      };\n    }\n  } else {\n    log = {\n      schema_version: '2.0.0',\n      log_created_at: timestamp,\n      decisions: [],\n    };\n  }\n\n  const decisionEntry: DecisionEntry = {\n    decision_id: decisionId,\n    timestamp,\n    made_by: {\n      instance_id: getInstanceId(),\n      agent_type: agentType,\n    },\n    category,\n    title: `Agent ${agentType} completed`,\n    description: summary,\n    impact: {\n      scope: 'agent-pipeline',\n      downstream_agents: downstreamAgents.split(' ').filter(Boolean),\n    },\n    status,\n    task_id: taskId,\n  };\n\n  log.decisions.push(decisionEntry);\n\n  try {\n    writeFileSync(decisionLog, JSON.stringify(log, null, 2));\n    logFeedback(`Decision ${decisionId} logged for agent ${agentType}`);\n  } catch {\n    logFeedback('ERROR: Failed to write decision to log');\n  }\n}\n\ninterface HandoffContext {\n  from_agent: string;\n  to_agent: string;\n  timestamp: string;\n  decision_id: string;\n  summary: string;\n  session_id: string;\n  status: string;\n  feedback_loop: boolean;\n  task_id?: string;  // CC 2.1.16 integration\n}\n\nfunction createHandoffContext(\n  agentType: string,\n  downstreamAgents: string,\n  summary: string,\n  decisionId: string,\n  sessionId: string,\n  timestamp: string,\n  taskId?: string\n): void {\n  if (!downstreamAgents) {\n    return;\n  }\n\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const agents = downstreamAgents.split(' ').filter(Boolean);\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n\n  for (const downstream of agents) {\n    const handoffFile = `${handoffDir}/${agentType}_to_${downstream}_${dateStr}.json`;\n\n    const handoff: HandoffContext = {\n      from_agent: agentType,\n      to_agent: downstream,\n      timestamp,\n      decision_id: decisionId,\n      summary,\n      session_id: sessionId,\n      status: 'pending',\n      feedback_loop: true,\n      task_id: taskId,\n    };\n\n    try {\n      writeFileSync(handoffFile, JSON.stringify(handoff, null, 2));\n      logFeedback(`Created handoff context: ${agentType} -> ${downstream}`);\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function feedbackLoop(input: HookInput): HookResult {\n  // Issue #362: Yield to CC Agent Teams when active \u2014 Teams has native\n  // task tracking and peer messaging, making custom decision-log redundant.\n  if (isAgentTeamsActive()) {\n    return outputSilentSuccess();\n  }\n\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const sessionId = input.session_id; // CC 2.1.9+ guarantees session_id\n  const agentOutput = input.agent_output || input.output || '';\n  const error = input.error || '';\n\n  logFeedback(`Processing feedback for agent: ${agentType} (session: ${sessionId})`);\n\n  // Skip if unknown agent type\n  if (agentType === 'unknown' || !agentType) {\n    logFeedback('Skipping unknown agent type');\n    return outputSilentSuccess();\n  }\n\n  // Generate decision ID\n  const dateStr = new Date().toISOString().replace(/[-:T.]/g, '').substring(0, 8);\n  const randomNum = Math.floor(Math.random() * 10000)\n    .toString()\n    .padStart(4, '0');\n  const decisionId = `DEC-${dateStr}-${randomNum}`;\n\n  // CC 2.1.16: Look up associated task\n  const task = getTaskByAgent(agentType);\n  const taskId = task?.taskId;\n\n  // Determine downstream agents (use pipeline-aware routing)\n  const downstreamAgents = getDownstreamAgents(agentType);\n\n  // Get feedback category\n  const category = getFeedbackCategory(agentType);\n\n  // Extract findings summary\n  let summary: string;\n  let status: string;\n  if (error && error !== 'null') {\n    summary = `Agent failed: ${error}`;\n    status = 'failed';\n  } else {\n    summary = extractFindingsSummary(agentOutput);\n    status = 'completed';\n  }\n\n  // CC 2.1.16: Update task status in registry\n  if (taskId) {\n    updateTaskStatus(taskId, status === 'completed' ? 'completed' : 'failed');\n    logFeedback(`Updated task ${taskId} status to ${status}`);\n  }\n\n  // Write to decision log (now includes task_id)\n  writeDecision(decisionId, agentType, category, summary, downstreamAgents, status, timestamp, taskId);\n\n  // Create handoff context for downstream agents (now includes task_id)\n  if (downstreamAgents) {\n    createHandoffContext(agentType, downstreamAgents, summary, decisionId, sessionId, timestamp, taskId);\n    logFeedback(`Routed findings to downstream agents: ${downstreamAgents}`);\n  } else {\n    logFeedback(`No downstream agents for ${agentType} (terminal agent)`);\n  }\n\n  // Log completion\n  logFeedback(`=== AGENT FEEDBACK LOOP ===\nAgent: ${agentType}\nCategory: ${category}\nDecision ID: ${decisionId}\nTask ID: ${taskId || 'none'}\nTimestamp: ${timestamp}\nStatus: ${status}\nDownstream: ${downstreamAgents || 'none'}\n\nSummary: ${summary}`);\n\n  // Output\n  if (downstreamAgents) {\n    return {\n      continue: true,\n      systemMessage: `Feedback loop: routed to ${downstreamAgents}${taskId ? ` (task: ${taskId})` : ''}`,\n    };\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Task Integration - Bridge to CC 2.1.16 Task Management System\n * Issue #197: Agent Orchestration Layer\n *\n * Provides utilities for:\n * - Generating task creation instructions\n * - Tracking task-to-agent relationships\n * - Managing task state for orchestration\n *\n * Note: This module generates INSTRUCTIONS for Claude to execute\n * task operations, as hooks cannot directly call CC tools.\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport type {\n  TaskCreateInstruction,\n  TaskUpdateInstruction,\n  TaskMetadata,\n  PipelineExecution,\n} from './orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\n/** Task tracking entry stored locally */\ninterface TaskEntry {\n  taskId: string;\n  agent: string;\n  confidence: number;\n  createdAt: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  pipelineId?: string;\n  pipelineStep?: number;\n  blockedBy?: string[];\n  blocks?: string[];\n}\n\n/** Task registry for session */\ninterface TaskRegistry {\n  schemaVersion: string;\n  sessionId: string;\n  tasks: TaskEntry[];\n  pipelines: PipelineExecution[];\n  updatedAt: string;\n}\n\n// -----------------------------------------------------------------------------\n// Registry File Management\n// -----------------------------------------------------------------------------\n\nfunction getRegistryFile(): string {\n  const sessionId = getSessionId();\n  return `${getProjectDir()}/.claude/orchestration/task-registry-${sessionId}.json`;\n}\n\nfunction ensureDir(): void {\n  const dir = `${getProjectDir()}/.claude/orchestration`;\n  if (!existsSync(dir)) {\n    try {\n      mkdirSync(dir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n  }\n}\n\nfunction loadRegistry(): TaskRegistry {\n  const file = getRegistryFile();\n\n  if (existsSync(file)) {\n    try {\n      return JSON.parse(readFileSync(file, 'utf8'));\n    } catch {\n      // Return default on error\n    }\n  }\n\n  return {\n    schemaVersion: '1.0.0',\n    sessionId: getSessionId(),\n    tasks: [],\n    pipelines: [],\n    updatedAt: new Date().toISOString(),\n  };\n}\n\nfunction saveRegistry(registry: TaskRegistry): void {\n  ensureDir();\n  const file = getRegistryFile();\n  registry.updatedAt = new Date().toISOString();\n\n  try {\n    writeFileSync(file, JSON.stringify(registry, null, 2));\n  } catch (err) {\n    logHook('task-integration', `Failed to save registry: ${err}`);\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Task Instructions Generators\n// -----------------------------------------------------------------------------\n\n/**\n * Get action-specific activeForm based on agent type\n */\nfunction getActiveFormForAgent(agent: string, description: string): string {\n  const actionMap: Record<string, string> = {\n    'backend-system-architect': 'Designing',\n    'frontend-ui-developer': 'Building',\n    'test-generator': 'Writing tests for',\n    'security-auditor': 'Auditing',\n    'workflow-architect': 'Architecting',\n    'database-engineer': 'Implementing database for',\n    'llm-integrator': 'Integrating LLM for',\n    'code-quality-reviewer': 'Reviewing',\n    'ux-researcher': 'Researching UX for',\n    'product-strategist': 'Strategizing',\n    'debug-investigator': 'Investigating',\n    'frontend-performance-engineer': 'Optimizing',\n    'accessibility-specialist': 'Auditing accessibility for',\n    'infrastructure-architect': 'Designing infrastructure for',\n    'data-pipeline-engineer': 'Building pipeline for',\n  };\n\n  const action = actionMap[agent] || 'Working on';\n  const shortDesc = description.slice(0, 40).toLowerCase();\n  return `${action} ${shortDesc}`;\n}\n\n/**\n * Generate TaskCreate instruction for an agent dispatch\n */\nexport function generateTaskCreateInstruction(\n  agent: string,\n  description: string,\n  confidence: number,\n  metadata?: Partial<TaskMetadata>\n): TaskCreateInstruction {\n  const agentTitle = agent\n    .split('-')\n    .map(w => w.charAt(0).toUpperCase() + w.slice(1))\n    .join(' ');\n\n  const fullMetadata: TaskMetadata = {\n    source: 'orchestration',\n    dispatchedAgent: agent,\n    dispatchConfidence: confidence,\n    ...metadata,\n  };\n\n  return {\n    subject: `${agentTitle}: ${description.slice(0, 50)}`,\n    description: `Agent dispatched automatically at ${confidence}% confidence.\\n\\n${description}`,\n    activeForm: getActiveFormForAgent(agent, description),\n    metadata: fullMetadata,\n  };\n}\n\n/**\n * Generate TaskUpdate instruction for status change\n */\nexport function generateTaskUpdateInstruction(\n  taskId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'deleted',\n  blockedBy?: string[],\n  blocks?: string[]\n): TaskUpdateInstruction {\n  const instruction: TaskUpdateInstruction = {\n    taskId,\n    status,\n  };\n\n  if (blockedBy && blockedBy.length > 0) {\n    instruction.addBlockedBy = blockedBy;\n  }\n\n  if (blocks && blocks.length > 0) {\n    instruction.addBlocks = blocks;\n  }\n\n  return instruction;\n}\n\n/**\n * Format TaskCreate instruction as markdown for Claude\n */\nexport function formatTaskCreateForClaude(instruction: TaskCreateInstruction): string {\n  return `### Create Task for Tracking\n\n\\`\\`\\`\nTaskCreate:\n  subject: \"${instruction.subject}\"\n  description: \"${instruction.description}\"\n  activeForm: \"${instruction.activeForm}\"\n  metadata:\n    source: \"${instruction.metadata.source}\"\n    dispatchedAgent: \"${instruction.metadata.dispatchedAgent || ''}\"\n    dispatchConfidence: ${instruction.metadata.dispatchConfidence || 0}\n\\`\\`\\``;\n}\n\n/**\n * Generate TaskUpdate instruction for task deletion (CC 2.1.20)\n */\nexport function generateTaskDeleteInstruction(\n  taskId: string,\n  _reason: string\n): TaskUpdateInstruction {\n  return {\n    taskId,\n    status: 'deleted',\n  };\n}\n\n/**\n * Format TaskDelete instruction as markdown for Claude (CC 2.1.20)\n */\nexport function formatTaskDeleteForClaude(taskId: string, reason: string): string {\n  return `### Delete Orphaned Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${taskId}\"\n  status: \"deleted\"\n\\`\\`\\`\n\n**Reason**: ${reason}`;\n}\n\n/**\n * Format TaskUpdate instruction as markdown for Claude\n */\nexport function formatTaskUpdateForClaude(instruction: TaskUpdateInstruction): string {\n  let md = `### Update Task\n\n\\`\\`\\`\nTaskUpdate:\n  taskId: \"${instruction.taskId}\"`;\n\n  if (instruction.status) {\n    md += `\\n  status: \"${instruction.status}\"`;\n  }\n\n  if (instruction.addBlockedBy && instruction.addBlockedBy.length > 0) {\n    md += `\\n  addBlockedBy: ${JSON.stringify(instruction.addBlockedBy)}`;\n  }\n\n  if (instruction.addBlocks && instruction.addBlocks.length > 0) {\n    md += `\\n  addBlocks: ${JSON.stringify(instruction.addBlocks)}`;\n  }\n\n  md += '\\n```';\n  return md;\n}\n\n// -----------------------------------------------------------------------------\n// Task Tracking Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a new task for an agent\n */\nexport function registerTask(\n  taskId: string,\n  agent: string,\n  confidence: number,\n  pipelineId?: string,\n  pipelineStep?: number,\n  blockedBy?: string[],\n  blocks?: string[]\n): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.tasks.find(t => t.taskId === taskId);\n  if (existing) {\n    logHook('task-integration', `Task ${taskId} already registered`);\n    return;\n  }\n\n  registry.tasks.push({\n    taskId,\n    agent,\n    confidence,\n    createdAt: new Date().toISOString(),\n    status: 'pending',\n    pipelineId,\n    pipelineStep,\n    blockedBy,\n    blocks,\n  });\n\n  saveRegistry(registry);\n  logHook('task-integration', `Registered task ${taskId} for agent ${agent}`);\n}\n\n/**\n * Update task status in registry\n */\nexport function updateTaskStatus(\n  taskId: string,\n  status: TaskEntry['status']\n): void {\n  const registry = loadRegistry();\n\n  const task = registry.tasks.find(t => t.taskId === taskId);\n  if (task) {\n    task.status = status;\n    saveRegistry(registry);\n    logHook('task-integration', `Updated task ${taskId} status to ${status}`);\n  }\n}\n\n/**\n * Get task by agent name\n */\nexport function getTaskByAgent(agent: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(\n    t => t.agent === agent && (t.status === 'pending' || t.status === 'in_progress')\n  );\n}\n\n/**\n * Get task by ID\n */\nexport function getTaskById(taskId: string): TaskEntry | undefined {\n  const registry = loadRegistry();\n  return registry.tasks.find(t => t.taskId === taskId);\n}\n\n/**\n * Get pending tasks blocked by a specific failed task (CC 2.1.20)\n */\nexport function getTasksBlockedBy(failedTaskId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks.filter(\n    t =>\n      t.status === 'pending' &&\n      t.blockedBy &&\n      t.blockedBy.includes(failedTaskId)\n  );\n}\n\n/**\n * Get orphaned tasks - pending tasks where all blockers have failed (CC 2.1.20)\n */\nexport function getOrphanedTasks(): TaskEntry[] {\n  const registry = loadRegistry();\n  const failedIds = new Set(\n    registry.tasks.filter(t => t.status === 'failed').map(t => t.taskId)\n  );\n\n  if (failedIds.size === 0) return [];\n\n  return registry.tasks.filter(t => {\n    if (t.status !== 'pending' || !t.blockedBy || t.blockedBy.length === 0) {\n      return false;\n    }\n    // Orphaned if ALL blockers are failed\n    return t.blockedBy.every(id => failedIds.has(id));\n  });\n}\n\n/**\n * Get all tasks for a pipeline\n */\nexport function getPipelineTasks(pipelineId: string): TaskEntry[] {\n  const registry = loadRegistry();\n  return registry.tasks\n    .filter(t => t.pipelineId === pipelineId)\n    .sort((a, b) => (a.pipelineStep || 0) - (b.pipelineStep || 0));\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Operations\n// -----------------------------------------------------------------------------\n\n/**\n * Register a pipeline execution\n */\nexport function registerPipeline(pipeline: PipelineExecution): void {\n  const registry = loadRegistry();\n\n  // Check for duplicate\n  const existing = registry.pipelines.find(p => p.pipelineId === pipeline.pipelineId);\n  if (existing) {\n    logHook('task-integration', `Pipeline ${pipeline.pipelineId} already registered`);\n    return;\n  }\n\n  registry.pipelines.push(pipeline);\n  saveRegistry(registry);\n  logHook('task-integration', `Registered pipeline ${pipeline.pipelineId} (${pipeline.type})`);\n}\n\n/**\n * Update pipeline state\n */\nexport function updatePipeline(\n  pipelineId: string,\n  updates: Partial<PipelineExecution>\n): void {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (pipeline) {\n    Object.assign(pipeline, updates);\n    saveRegistry(registry);\n    logHook('task-integration', `Updated pipeline ${pipelineId}`);\n  }\n}\n\n/**\n * Get active pipeline (if any)\n */\nexport function getActivePipeline(): PipelineExecution | undefined {\n  const registry = loadRegistry();\n  return registry.pipelines.find(p => p.status === 'running');\n}\n\n/**\n * Mark pipeline step complete and check for next\n */\nexport function completePipelineStep(pipelineId: string, step: number): number | null {\n  const registry = loadRegistry();\n\n  const pipeline = registry.pipelines.find(p => p.pipelineId === pipelineId);\n  if (!pipeline) return null;\n\n  if (!pipeline.completedSteps.includes(step)) {\n    pipeline.completedSteps.push(step);\n    pipeline.completedSteps.sort((a, b) => a - b);\n  }\n\n  // Find next unblocked step\n  const tasks = getPipelineTasks(pipelineId);\n  for (const task of tasks) {\n    const taskStep = task.pipelineStep;\n    if (taskStep === undefined) continue;\n    if (pipeline.completedSteps.includes(taskStep)) continue;\n    if (task.status !== 'pending') continue;\n\n    // Check if dependencies are met\n    // For now, assume sequential - previous steps must be complete\n    const prevStepsComplete = taskStep === 0 ||\n      pipeline.completedSteps.includes(taskStep - 1);\n\n    if (prevStepsComplete) {\n      pipeline.currentStep = taskStep;\n      saveRegistry(registry);\n      return taskStep;\n    }\n  }\n\n  // No more steps - pipeline complete\n  pipeline.status = 'completed';\n  saveRegistry(registry);\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\n/**\n * Clean up completed tasks older than threshold\n */\nexport function cleanupOldTasks(maxAgeMs: number = 24 * 60 * 60 * 1000): void {\n  const registry = loadRegistry();\n  const cutoff = Date.now() - maxAgeMs;\n\n  registry.tasks = registry.tasks.filter(t => {\n    if (t.status === 'pending' || t.status === 'in_progress') return true;\n    const taskTime = new Date(t.createdAt).getTime();\n    return taskTime > cutoff;\n  });\n\n  registry.pipelines = registry.pipelines.filter(p => {\n    if (p.status === 'running') return true;\n    const pipelineTime = new Date(p.startedAt).getTime();\n    return pipelineTime > cutoff;\n  });\n\n  saveRegistry(registry);\n}\n", "/**\n * Agent Teams Detection & Configuration Utility\n * Issue #362: Deprecate coordination hooks redundant with CC Agent Teams\n *\n * CC Agent Teams (CC 2.1.33+) provides native multi-instance coordination:\n * - Teammate lifecycle management\n * - 5-minute runtime heartbeat\n * - Idle notifications\n * - Cleanup on session end\n *\n * When Agent Teams is active, OrchestKit's custom coordination hooks\n * should yield to CC's native implementation to avoid duplication.\n */\n\nimport { existsSync, readFileSync, readdirSync, statSync, rmSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Check if CC Agent Teams is active.\n *\n * Detection signals:\n * - CLAUDE_CODE_TEAM_NAME: Set when running as part of an Agent Teams team\n * - CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS: Feature flag for Agent Teams\n */\nexport function isAgentTeamsActive(): boolean {\n  return !!(\n    process.env.CLAUDE_CODE_TEAM_NAME ||\n    process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS === '1'\n  );\n}\n\n/** Check if current session is a teammate in a team */\nexport function isTeammate(): boolean {\n  return !!process.env.CLAUDE_CODE_TEAM_NAME;\n}\n\n/** Get current team name */\nexport function getTeamName(): string | null {\n  return process.env.CLAUDE_CODE_TEAM_NAME || null;\n}\n\nexport interface TeamMember {\n  name: string;\n  agentType: string;\n}\n\n/**\n * Read team config to get member list.\n * Reads from ~/.claude/teams/{team-name}/config.json\n */\nexport function getTeamMembers(): TeamMember[] {\n  const teamName = getTeamName();\n  if (!teamName) return [];\n\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n\n  const configPath = join(homeDir, '.claude', 'teams', teamName, 'config.json');\n  if (!existsSync(configPath)) return [];\n\n  try {\n    const config = JSON.parse(readFileSync(configPath, 'utf-8'));\n    const members = config.members;\n    if (!Array.isArray(members)) return [];\n\n    return members.map((m: { name?: string; agentType?: string }) => ({\n      name: m.name || 'unknown',\n      agentType: m.agentType || 'unknown',\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/** Count current team members */\nexport function getTeamSize(): number {\n  return getTeamMembers().length;\n}\n\n/** List all team directories */\nexport function listAllTeams(): string[] {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n  const teamsDir = join(homeDir, '.claude', 'teams');\n  if (!existsSync(teamsDir)) return [];\n  try {\n    return readdirSync(teamsDir).filter(name => {\n      try { return statSync(join(teamsDir, name)).isDirectory(); } catch { return false; }\n    });\n  } catch { return []; }\n}\n\n/** Check if team is stale (no config, or dir older than maxAgeHours) */\nexport function isStaleTeam(teamName: string, maxAgeHours: number = 4): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  const teamPath = join(homeDir, '.claude', 'teams', teamName);\n  if (!existsSync(teamPath)) return false;\n  const configPath = join(teamPath, 'config.json');\n  if (!existsSync(configPath)) return true;  // no config = orphaned\n  try {\n    const ageMs = Date.now() - statSync(teamPath).mtimeMs;\n    return ageMs > maxAgeHours * 3600_000;\n  } catch { return true; }\n}\n\n/** Remove team + task directories */\nexport function cleanupTeam(teamName: string): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  let ok = true;\n  for (const sub of ['teams', 'tasks']) {\n    const dir = join(homeDir, '.claude', sub, teamName);\n    if (existsSync(dir)) {\n      try { rmSync(dir, { recursive: true, force: true }); } catch { ok = false; }\n    }\n  }\n  return ok;\n}\n", "/**\n * Multi-Agent Coordinator - Pipeline detection and coordination logic\n * Issue #197: Agent Orchestration Layer\n *\n * Provides:\n * - Pipeline definitions for common workflows\n * - Pipeline detection from prompts\n * - Task chain generation with dependencies\n */\n\nimport { logHook } from './common.js';\nimport type {\n  PipelineType,\n  PipelineDefinition,\n  PipelineExecution,\n  TaskCreateInstruction,\n  TaskMetadata,\n} from './orchestration-types.js';\nimport { registerPipeline, registerTask } from './task-integration.js';\nimport { isAgentTeamsActive } from './agent-teams.js';\n\n// -----------------------------------------------------------------------------\n// Pipeline Definitions\n// -----------------------------------------------------------------------------\n\n/**\n * Predefined pipeline configurations\n */\nexport const PIPELINES: PipelineDefinition[] = [\n  {\n    type: 'product-thinking',\n    name: 'Product Thinking Pipeline',\n    description: 'Full product discovery and specification workflow',\n    triggers: [\n      'should we build',\n      'product decision',\n      'feature validation',\n      'market research',\n      'user research',\n    ],\n    steps: [\n      {\n        agent: 'market-intelligence',\n        description: 'Analyze competitive landscape and market trends',\n        dependsOn: [],\n        skills: ['market-research'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'ux-researcher',\n        description: 'Create personas and map user journeys',\n        dependsOn: [0],\n        skills: ['user-research'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'product-strategist',\n        description: 'Validate value proposition and alignment',\n        dependsOn: [0, 1],\n        skills: ['product-strategy'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'prioritization-analyst',\n        description: 'Score and prioritize using frameworks',\n        dependsOn: [2],\n        skills: ['prioritization'],\n        estimatedTokens: 1500,\n      },\n      {\n        agent: 'business-case-builder',\n        description: 'Build ROI and cost-benefit analysis',\n        dependsOn: [2, 3],\n        skills: ['business-case'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'requirements-translator',\n        description: 'Transform to PRD and user stories',\n        dependsOn: [4],\n        skills: ['requirements'],\n        estimatedTokens: 2500,\n      },\n    ],\n    estimatedTotalTokens: 13500,\n  },\n  {\n    type: 'full-stack-feature',\n    name: 'Full-Stack Feature Pipeline',\n    description: 'End-to-end feature implementation workflow',\n    triggers: [\n      'full-stack feature',\n      'build a feature',\n      'implement end-to-end',\n      'create full feature',\n      'add complete feature',\n    ],\n    steps: [\n      {\n        agent: 'backend-system-architect',\n        description: 'Design API and database schema',\n        dependsOn: [],\n        skills: ['api-design', 'database-patterns'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Build React components and UI',\n        dependsOn: [0],\n        skills: ['react-server-components-framework', 'form-state-patterns'],\n        estimatedTokens: 3500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create unit and integration tests',\n        dependsOn: [0, 1],\n        skills: ['testing-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-auditor',\n        description: 'Audit for vulnerabilities',\n        dependsOn: [0, 1],\n        skills: ['security-patterns'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 10000,\n  },\n  {\n    type: 'ai-integration',\n    name: 'AI Integration Pipeline',\n    description: 'Add AI/LLM capabilities to application',\n    triggers: [\n      'add rag',\n      'add llm',\n      'ai integration',\n      'implement rag',\n      'add ai feature',\n      'langgraph workflow',\n    ],\n    steps: [\n      {\n        agent: 'workflow-architect',\n        description: 'Design LangGraph workflow and state',\n        dependsOn: [],\n        skills: ['langgraph'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'llm-integrator',\n        description: 'Connect LLM APIs with function calling',\n        dependsOn: [0],\n        skills: ['llm-integration'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'data-pipeline-engineer',\n        description: 'Build embeddings and data pipeline',\n        dependsOn: [0],\n        skills: ['embeddings', 'rag-retrieval'],\n        estimatedTokens: 2500,\n      },\n      {\n        agent: 'test-generator',\n        description: 'Create LLM testing infrastructure',\n        dependsOn: [1, 2],\n        skills: ['testing-patterns'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 8500,\n  },\n  {\n    type: 'security-audit',\n    name: 'Security Audit Pipeline',\n    description: 'Comprehensive security review workflow',\n    triggers: [\n      'security audit',\n      'security review',\n      'vulnerability scan',\n      'security assessment',\n    ],\n    steps: [\n      {\n        agent: 'security-auditor',\n        description: 'Scan for OWASP Top 10 vulnerabilities',\n        dependsOn: [],\n        skills: ['security-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'security-layer-auditor',\n        description: 'Verify defense-in-depth layers',\n        dependsOn: [0],\n        skills: ['security-patterns'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'ai-safety-auditor',\n        description: 'Audit AI/LLM security if applicable',\n        dependsOn: [0],\n        skills: ['mcp-security-hardening'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 5500,\n  },\n  {\n    type: 'frontend-compliance',\n    name: 'Frontend 2026 Compliance Pipeline',\n    description: 'Modernize frontend to 2026 patterns',\n    triggers: [\n      'frontend compliance',\n      'modernize frontend',\n      'update react',\n      'frontend 2026',\n    ],\n    steps: [\n      {\n        agent: 'frontend-ui-developer',\n        description: 'Upgrade to React 19 patterns',\n        dependsOn: [],\n        skills: ['react-server-components-framework', 'zustand-patterns'],\n        estimatedTokens: 3000,\n      },\n      {\n        agent: 'frontend-performance-engineer',\n        description: 'Optimize Core Web Vitals',\n        dependsOn: [0],\n        skills: ['performance'],\n        estimatedTokens: 2000,\n      },\n      {\n        agent: 'accessibility-specialist',\n        description: 'Ensure WCAG 2.2 compliance',\n        dependsOn: [0],\n        skills: ['testing-patterns', 'accessibility'],\n        estimatedTokens: 1500,\n      },\n    ],\n    estimatedTotalTokens: 6500,\n  },\n];\n\n// -----------------------------------------------------------------------------\n// Pipeline Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect if prompt matches a pipeline trigger.\n * Issue #362: Yields to CC Agent Teams when active \u2014 Teams has its own\n * task list and peer-to-peer messaging, making custom pipelines redundant.\n */\nexport function detectPipeline(prompt: string): PipelineDefinition | null {\n  if (isAgentTeamsActive()) {\n    logHook('multi-agent-coordinator', 'Agent Teams active \u2014 yielding pipeline detection to native Teams');\n    return null;\n  }\n\n  const promptLower = prompt.toLowerCase();\n\n  for (const pipeline of PIPELINES) {\n    for (const trigger of pipeline.triggers) {\n      if (promptLower.includes(trigger)) {\n        logHook(\n          'multi-agent-coordinator',\n          `Detected pipeline: ${pipeline.type} (trigger: \"${trigger}\")`\n        );\n        return pipeline;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get pipeline by type\n */\nexport function getPipelineByType(type: PipelineType): PipelineDefinition | null {\n  return PIPELINES.find(p => p.type === type) || null;\n}\n\n// -----------------------------------------------------------------------------\n// Pipeline Execution\n// -----------------------------------------------------------------------------\n\n/**\n * Create a pipeline execution plan with task instructions\n */\nexport function createPipelineExecution(\n  pipeline: PipelineDefinition\n): {\n  execution: PipelineExecution;\n  tasks: TaskCreateInstruction[];\n} {\n  const pipelineId = `pipeline-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;\n\n  // Create task instructions for each step\n  const tasks: TaskCreateInstruction[] = [];\n  const taskIds: Record<number, string> = {};\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const taskId = `task-${pipelineId}-${i}`;\n    taskIds[i] = taskId;\n\n    const metadata: TaskMetadata = {\n      source: 'pipeline',\n      dispatchedAgent: step.agent,\n      pipelineId,\n      pipelineStep: i,\n      relatedSkills: step.skills,\n    };\n\n    // Build blockedBy from dependsOn\n    const blockedBy = step.dependsOn.map(dep => taskIds[dep]).filter(Boolean);\n\n    tasks.push({\n      subject: `[${pipeline.name}] Step ${i + 1}: ${step.description}`,\n      description: `Pipeline step: ${step.agent}\\n\\n${step.description}\\n\\nEstimated tokens: ${step.estimatedTokens}`,\n      activeForm: `Running ${step.agent}`,\n      metadata,\n      blockedBy: blockedBy.length > 0 ? blockedBy : undefined,\n    });\n  }\n\n  const execution: PipelineExecution = {\n    pipelineId,\n    type: pipeline.type,\n    startedAt: new Date().toISOString(),\n    taskIds,\n    currentStep: 0,\n    completedSteps: [],\n    status: 'running',\n  };\n\n  return { execution, tasks };\n}\n\n/**\n * Register pipeline and tasks with tracking systems\n */\nexport function registerPipelineExecution(\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): void {\n  // Register pipeline\n  registerPipeline(execution);\n\n  // Register each task\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    const taskId = execution.taskIds[i];\n\n    if (taskId && task.metadata.dispatchedAgent) {\n      registerTask(\n        taskId,\n        task.metadata.dispatchedAgent,\n        task.metadata.dispatchConfidence || 100,\n        execution.pipelineId,\n        i\n      );\n    }\n  }\n\n  logHook(\n    'multi-agent-coordinator',\n    `Registered pipeline ${execution.pipelineId} with ${tasks.length} tasks`\n  );\n}\n\n// -----------------------------------------------------------------------------\n// Message Formatting\n// -----------------------------------------------------------------------------\n\n/**\n * Format pipeline plan as markdown for user\n */\nexport function formatPipelinePlan(\n  pipeline: PipelineDefinition,\n  execution: PipelineExecution,\n  tasks: TaskCreateInstruction[]\n): string {\n  let md = `## \uD83D\uDD04 Pipeline Detected: ${pipeline.name}\n\n${pipeline.description}\n\n**Pipeline ID:** \\`${execution.pipelineId}\\`\n**Estimated Total Tokens:** ~${pipeline.estimatedTotalTokens}\n\n### Pipeline Steps\n\n`;\n\n  for (let i = 0; i < pipeline.steps.length; i++) {\n    const step = pipeline.steps[i];\n    const deps = step.dependsOn.length > 0\n      ? ` (after steps: ${step.dependsOn.map(d => d + 1).join(', ')})`\n      : ' (can start immediately)';\n\n    md += `**${i + 1}. ${step.agent}**${deps}\n   ${step.description}\n   Skills: ${step.skills?.join(', ') || 'none'}\n\n`;\n  }\n\n  md += `### Task Creation Instructions\n\nCreate these tasks to track the pipeline:\n\n`;\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i];\n    md += `**Task ${i + 1}:**\n\\`\\`\\`\nTaskCreate:\n  subject: \"${task.subject}\"\n  activeForm: \"${task.activeForm}\"\n${task.blockedBy ? `  blockedBy: ${JSON.stringify(task.blockedBy)}` : ''}\n\\`\\`\\`\n\n`;\n  }\n\n  md += `### Start Pipeline\n\nAfter creating all tasks, spawn the first agent:\n\n\\`\\`\\`\nTask tool with subagent_type: \"${pipeline.steps[0].agent}\"\n\\`\\`\\`\n\nThe orchestration layer will track progress and suggest next agents as steps complete.`;\n\n  return md;\n}\n", "/**\n * Handoff Preparer - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Prepares context for handoff to next agent in pipeline.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst VALID_AGENTS = new Set([\n  'market-intelligence',\n  'product-strategist',\n  'prioritization-analyst',\n  'business-case-builder',\n  'requirements-translator',\n  'metrics-architect',\n  'backend-system-architect',\n  'code-quality-reviewer',\n  'data-pipeline-engineer',\n  'database-engineer',\n  'debug-investigator',\n  'frontend-ui-developer',\n  'llm-integrator',\n  'rapid-ui-designer',\n  'security-auditor',\n  'security-layer-auditor',\n  'system-design-reviewer',\n  'test-generator',\n  'ux-researcher',\n  'workflow-architect',\n]);\n\n// Pipeline mappings\nconst NEXT_AGENT_MAP: Record<string, string> = {\n  // Product thinking pipeline\n  'market-intelligence': 'product-strategist',\n  'product-strategist': 'prioritization-analyst',\n  'prioritization-analyst': 'business-case-builder',\n  'business-case-builder': 'requirements-translator',\n  'requirements-translator': 'metrics-architect',\n  'metrics-architect': 'backend-system-architect',\n  // Full-stack pipeline\n  'backend-system-architect': 'frontend-ui-developer',\n  'frontend-ui-developer': 'test-generator',\n  'test-generator': 'code-quality-reviewer',\n  'code-quality-reviewer': 'security-auditor',\n  // AI integration pipeline\n  'workflow-architect': 'llm-integrator',\n  'llm-integrator': 'data-pipeline-engineer',\n  'data-pipeline-engineer': 'code-quality-reviewer',\n  // Database pipeline\n  'database-engineer': 'backend-system-architect',\n  // UI pipeline\n  'rapid-ui-designer': 'frontend-ui-developer',\n  'ux-researcher': 'rapid-ui-designer',\n  // Terminal agents\n  'security-auditor': 'none',\n  'security-layer-auditor': 'none',\n  'debug-investigator': 'none',\n  'system-design-reviewer': 'none',\n};\n\n// Handoff suggestions\nconst SUGGESTIONS_MAP: Record<string, string> = {\n  'market-intelligence': 'Next: product-strategist should define product vision based on market analysis',\n  'product-strategist': 'Next: prioritization-analyst should rank features from strategy',\n  'prioritization-analyst': 'Next: business-case-builder should create ROI justification',\n  'business-case-builder': 'Next: requirements-translator should convert to technical specs',\n  'requirements-translator': 'Next: metrics-architect should define success criteria',\n  'metrics-architect': 'Next: backend-system-architect should design API endpoints',\n  'backend-system-architect': 'Next: frontend-ui-developer should build UI components',\n  'frontend-ui-developer': 'Next: test-generator should create test coverage',\n  'test-generator': 'Next: code-quality-reviewer should validate implementation',\n  'code-quality-reviewer': 'Next: security-auditor should perform security scan',\n  'workflow-architect': 'Next: llm-integrator should configure LLM providers',\n  'llm-integrator': 'Next: data-pipeline-engineer should set up embeddings',\n  'data-pipeline-engineer': 'Next: code-quality-reviewer should validate data pipeline',\n  'database-engineer': 'Next: backend-system-architect should integrate schema',\n  'rapid-ui-designer': 'Next: frontend-ui-developer should implement designs',\n  'ux-researcher': 'Next: rapid-ui-designer should create mockups',\n};\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction getNextAgent(agentName: string): string {\n  return NEXT_AGENT_MAP[agentName] || 'none';\n}\n\nfunction getSuggestions(agentName: string): string {\n  return SUGGESTIONS_MAP[agentName] || 'Pipeline complete';\n}\n\ninterface HandoffContext {\n  from_agent: string;\n  to_agent: string;\n  timestamp: string;\n  summary: string;\n  suggestions: string;\n  status: string;\n}\n\nfunction writeHandoffFile(\n  agentName: string,\n  nextAgent: string,\n  timestamp: string,\n  summary: string,\n  suggestions: string\n): string {\n  const handoffDir = `${getProjectDir()}/.claude/context/handoffs`;\n  try {\n    mkdirSync(handoffDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const handoffFile = `${handoffDir}/${agentName}_to_${nextAgent}_${dateStr}.json`;\n\n  const handoff: HandoffContext = {\n    from_agent: agentName,\n    to_agent: nextAgent,\n    timestamp,\n    summary,\n    suggestions,\n    status: 'ready_for_handoff',\n  };\n\n  try {\n    writeFileSync(handoffFile, JSON.stringify(handoff, null, 2));\n  } catch {\n    // Ignore\n  }\n\n  return handoffFile;\n}\n\nfunction writeLogFile(\n  agentName: string,\n  nextAgent: string,\n  timestamp: string,\n  summary: string,\n  suggestions: string,\n  handoffFile: string\n): void {\n  const logDir = `${getProjectDir()}/.claude/logs/agent-handoffs`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== HANDOFF PREPARATION ===\nFrom: ${agentName}\nTo: ${nextAgent}\nTimestamp: ${timestamp}\nHandoff file: ${handoffFile}\n\nSummary: ${summary}\n\nNext Steps: ${suggestions}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function handoffPreparer(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n\n  const toolInput = input.tool_input || {};\n  const agentName =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n\n  // Skip if not a valid pipeline agent\n  if (!VALID_AGENTS.has(agentName)) {\n    // Silent exit for non-pipeline agents (general-purpose, Explore, etc.)\n    return outputSilentSuccess();\n  }\n\n  const nextAgent = getNextAgent(agentName);\n\n  // Extract agent output\n  const agentOutput = input.agent_output || input.output || '';\n\n  // Generate handoff summary\n  const outputLength = agentOutput.length;\n  let summary: string;\n  if (outputLength > 0) {\n    summary = agentOutput.substring(0, 300);\n    if (outputLength > 300) {\n      summary += '...';\n    }\n  } else {\n    summary = `Agent ${agentName} completed`;\n  }\n\n  // Get suggestions\n  const suggestions = getSuggestions(agentName);\n\n  // Create handoff context file\n  const handoffFile = writeHandoffFile(agentName, nextAgent, timestamp, summary, suggestions);\n\n  // Log to file\n  writeLogFile(agentName, nextAgent, timestamp, summary, suggestions, handoffFile);\n\n  return outputSilentSuccess();\n}\n", "/**\n * Multi-Claude Verifier - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Purpose:\n * 1. Auto-spawn code-quality-reviewer after test-generator completes\n * 2. Auto-spawn security-auditor on sensitive file changes\n * 3. Enable parallel verification for comprehensive coverage\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport { bufferWrite } from '../lib/analytics-buffer.js';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\n// Sensitive file patterns \u2014 plain substring checks to avoid ReDoS\nconst SENSITIVE_PATTERNS = [\n  '.env',\n  'auth',\n  'secret',\n  'credential',\n  'password',\n  'token',\n  'apikey',\n  'api_key',\n  'api-key',\n  'jwt',\n  'session',\n  'oauth',\n  'permission',\n  '.pem',\n  '.key',\n];\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getLogDir(): string {\n  const logDir = `${getProjectDir()}/.claude/logs/multi-claude`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return logDir;\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions\n// -----------------------------------------------------------------------------\n\nfunction logAction(agentName: string, action: string, details: string): void {\n  const logDir = getLogDir();\n  const date = new Date().toISOString().substring(0, 10).replace(/-/g, '');\n  const logFile = `${logDir}/verifier_${date}.log`;\n  const timestamp = new Date().toISOString();\n\n  try {\n    bufferWrite(logFile, `[${timestamp}] [${agentName}] ${action}: ${details}\\n`);\n  } catch {\n    // Ignore\n  }\n}\n\nfunction containsSensitiveFiles(output: string): boolean {\n  const outputLower = output.toLowerCase();\n  for (const pattern of SENSITIVE_PATTERNS) {\n    if (outputLower.includes(pattern)) {\n      return true;\n    }\n  }\n  // Check config+prod combination (previously config.*prod regex)\n  if (outputLower.includes('config') && outputLower.includes('prod')) {\n    return true;\n  }\n  return false;\n}\n\ninterface VerificationAction {\n  agent: string;\n  reason: string;\n}\n\ninterface VerificationQueue {\n  triggered_by: string;\n  timestamp: string;\n  verifications: Array<{\n    agent: string;\n    reason: string;\n    status: string;\n  }>;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function multiClaudeVerifier(input: HookInput): HookResult {\n  const timestamp = new Date().toISOString();\n  const projectDir = getProjectDir();\n\n  const toolInput = input.tool_input || {};\n  const agentName =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    'unknown';\n  const agentOutput = input.agent_output || input.output || '';\n\n  const verificationActions: VerificationAction[] = [];\n\n  // Rule 1: After test-generator, spawn code-quality-reviewer\n  if (agentName === 'test-generator') {\n    verificationActions.push({\n      agent: 'code-quality-reviewer',\n      reason: 'Test generation complete - quality review recommended',\n    });\n    logAction(agentName, 'TRIGGER', 'test-generator completion triggers code-quality-reviewer');\n  }\n\n  // Rule 2: After frontend-ui-developer with form/auth components, spawn security review\n  if (agentName === 'frontend-ui-developer') {\n    if (/form|input|validation|submit|auth|login/i.test(agentOutput)) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Frontend auth/form components - security review recommended',\n      });\n      logAction(agentName, 'TRIGGER', 'frontend auth components trigger security-auditor');\n    }\n  }\n\n  // Rule 3: After backend-system-architect with API endpoints, spawn security review\n  if (agentName === 'backend-system-architect') {\n    if (/endpoint|route|api|auth|jwt|session/i.test(agentOutput)) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Backend API endpoints - security review recommended',\n      });\n      logAction(agentName, 'TRIGGER', 'backend API endpoints trigger security-auditor');\n    }\n  }\n\n  // Rule 4: Any agent touching sensitive files triggers security-auditor\n  if (containsSensitiveFiles(agentOutput)) {\n    // Avoid duplicate\n    const hasSecurityAuditor = verificationActions.some((v) => v.agent === 'security-auditor');\n    if (!hasSecurityAuditor) {\n      verificationActions.push({\n        agent: 'security-auditor',\n        reason: 'Sensitive files modified - security review required',\n      });\n      logAction(agentName, 'TRIGGER', 'sensitive file patterns detected');\n    }\n  }\n\n  // Rule 5: After database-engineer with schema changes, spawn code-quality-reviewer\n  if (agentName === 'database-engineer') {\n    verificationActions.push({\n      agent: 'code-quality-reviewer',\n      reason: 'Database schema changes - review for consistency',\n    });\n    logAction(agentName, 'TRIGGER', 'database changes trigger code-quality-reviewer');\n  }\n\n  // Rule 6: After workflow-architect, spawn security-layer-auditor\n  if (agentName === 'workflow-architect') {\n    verificationActions.push({\n      agent: 'security-layer-auditor',\n      reason: 'LangGraph workflow created - layer audit recommended',\n    });\n    logAction(agentName, 'TRIGGER', 'workflow-architect triggers security-layer-auditor');\n  }\n\n  // Create verification queue file for orchestrator to pick up\n  if (verificationActions.length > 0) {\n    const queueDir = `${projectDir}/.claude/context/verification-queue`;\n    try {\n      mkdirSync(queueDir, { recursive: true });\n    } catch {\n      // Ignore\n    }\n\n    const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n    const queueFile = `${queueDir}/pending_${dateStr}_${agentName}.json`;\n\n    const verificationsQueue: VerificationQueue = {\n      triggered_by: agentName,\n      timestamp,\n      verifications: verificationActions.map((v) => ({\n        agent: v.agent,\n        reason: v.reason,\n        status: 'pending',\n      })),\n    };\n\n    try {\n      writeFileSync(queueFile, JSON.stringify(verificationsQueue, null, 2));\n    } catch {\n      // Ignore\n    }\n\n    // Create system message with recommendations\n    const recommendationMsg =\n      'Multi-Claude Verification Triggered: ' +\n      verificationActions.map((v) => `${v.agent} (${v.reason})`).join('; ');\n\n    logAction(agentName, 'QUEUE', `Created verification queue: ${queueFile}`);\n\n    return {\n      continue: true,\n      systemMessage: recommendationMsg,\n    };\n  }\n\n  logAction(agentName, 'SKIP', 'No verification triggers matched');\n  return outputSilentSuccess();\n}\n", "/**\n * Output Validator - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Validates agent output quality and completeness.\n *\n * Version: 1.0.0 (TypeScript port)\n */\n\nimport { writeFileSync, mkdirSync } from 'node:fs';\nimport type { HookInput, HookResult } from '../types.js';\nimport { getProjectDir } from '../lib/common.js';\n\n// -----------------------------------------------------------------------------\n// Path Helpers\n// -----------------------------------------------------------------------------\n\nfunction getLogDir(): string {\n  const logDir = `${getProjectDir()}/.claude/logs/agent-validation`;\n  try {\n    mkdirSync(logDir, { recursive: true });\n  } catch {\n    // Ignore\n  }\n  return logDir;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\nexport function outputValidator(input: HookInput): HookResult {\n  const agentName = input.subagent_type || input.agent_type || 'unknown';\n  const timestamp = new Date().toISOString();\n\n  // Read agent output\n  const output = input.agent_output || input.output || '';\n\n  const validationErrors: string[] = [];\n  const validationWarnings: string[] = [];\n\n  // Check 1: Output is not empty\n  if (!output) {\n    validationErrors.push('Agent produced empty output');\n  }\n\n  // Check 2: Minimum length check\n  const outputLength = output.length;\n  if (outputLength < 50) {\n    validationWarnings.push(`Output seems very short (${outputLength} chars)`);\n  }\n\n  // Check 3: Check for common error patterns\n  if (/error|failed|exception/i.test(output)) {\n    validationWarnings.push('Output contains error-related keywords');\n  }\n\n  // Check 4: For backend architect, validate JSON structure if present\n  if (agentName === 'backend-system-architect') {\n    if (output.includes('{')) {\n      // Try to extract and validate JSON\n      const jsonMatch = output.match(/\\{[^{}]{0,1000}\\}/);\n      if (jsonMatch) {\n        try {\n          JSON.parse(jsonMatch[0]);\n        } catch {\n          validationWarnings.push('JSON structure may be malformed');\n        }\n      }\n    }\n  }\n\n  // Build validation result\n  const validationStatus = validationErrors.length > 0 ? 'failed' : 'passed';\n\n  // CC 2.1.47: last_assistant_message length as response quality signal\n  const lastMsgLength = input.last_assistant_message?.length ?? null;\n\n  // Create system message\n  let systemMessage = `Output Validation [${validationStatus}] - Agent: ${agentName}, Timestamp: ${timestamp}, Output length: ${outputLength} chars`\n    + (lastMsgLength !== null ? `, Response length: ${lastMsgLength} chars` : '');\n\n  if (validationErrors.length > 0) {\n    systemMessage += ` | Errors: ${validationErrors.join('; ')}`;\n  }\n\n  if (validationWarnings.length > 0) {\n    systemMessage += ` | Warnings: ${validationWarnings.join('; ')}`;\n  }\n\n  // Log to file\n  const logDir = getLogDir();\n  const dateStr = new Date().toISOString().replace(/[-:]/g, '').substring(0, 15);\n  const logFile = `${logDir}/${agentName}_${dateStr}.log`;\n\n  const logContent = `=== OUTPUT VALIDATION ===\n${systemMessage}\n${lastMsgLength !== null ? `Response quality signal: last_assistant_message length = ${lastMsgLength}\\n` : ''}\n=== AGENT OUTPUT ===\n${output}\n`;\n\n  try {\n    writeFileSync(logFile, logContent);\n  } catch {\n    // Ignore\n  }\n\n  // CC 2.1.7 compliant output\n  if (validationStatus === 'failed') {\n    return {\n      continue: false,\n      systemMessage,\n      hookSpecificOutput: {\n        hookEventName: 'SubagentStop' as any,\n      },\n    };\n  }\n\n  // Silent success for passed validation\n  return {\n    continue: true,\n    suppressOutput: true,\n    systemMessage,\n  };\n}\n", "/**\n * Subagent Quality Gate - SubagentStop Hook\n * CC 2.1.7 Compliant: includes continue field in all outputs\n *\n * Validates subagent output quality:\n * 1. Error-presence check (existing gate)\n * 2. Score pattern extraction and threshold validation\n * 3. Output structure validation (evidence/findings presence)\n *\n * Version: 2.0.0 (TypeScript port + schema validation)\n */\n\nimport { existsSync, writeFileSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWarning, logHook, getProjectDir } from '../lib/common.js';\nimport { getMetricsFile } from '../lib/paths.js';\n\n// -----------------------------------------------------------------------------\n// Configuration\n// -----------------------------------------------------------------------------\n\nconst METRICS_FILE = getMetricsFile();\n\ninterface VerificationPolicy {\n  thresholds?: {\n    security_minimum?: number;\n    general_minimum?: number;\n    [dimension: string]: number | undefined;\n  };\n}\n\nconst DEFAULT_THRESHOLDS = {\n  security_minimum: 5.0,\n  general_minimum: 3.0,\n};\n\n// -----------------------------------------------------------------------------\n// Score Extraction\n// -----------------------------------------------------------------------------\n\n/** Parsed score from subagent output */\ninterface ExtractedScore {\n  value: number;\n  max: number;\n  dimension: string | null;\n}\n\n/**\n * Extract score patterns from subagent output text.\n * Matches: \"Score: 7.5/10\", \"**Score:** 8/10\", '\"score\": 7.5', \"Security: 4/10\"\n */\nfunction extractScores(text: string): ExtractedScore[] {\n  const scores: ExtractedScore[] = [];\n  if (!text) return scores;\n\n  // Pattern 1: \"Dimension: N/M\" or \"**Dimension:** N/M\"\n  const slashPattern = /\\*{0,2}(\\w[\\w\\s]{0,30}?)\\*{0,2}\\s*:\\s*(\\d+(?:\\.\\d+)?)\\s*\\/\\s*(\\d+)/g;\n\n  for (const match of text.matchAll(slashPattern)) {\n    const dimension = match[1].trim().toLowerCase();\n    const value = parseFloat(match[2]);\n    const max = parseFloat(match[3]);\n    if (!Number.isNaN(value) && !Number.isNaN(max) && max > 0) {\n      scores.push({ value, max, dimension: dimension === 'score' ? null : dimension });\n    }\n  }\n\n  // Pattern 2: JSON-style \"score\": N or \"score\": N.N\n  const jsonPattern = /\"(\\w+_?score|score)\"\\s*:\\s*(\\d+(?:\\.\\d+)?)/gi;\n  for (const match of text.matchAll(jsonPattern)) {\n    const key = match[1].toLowerCase();\n    const value = parseFloat(match[2]);\n    if (!Number.isNaN(value)) {\n      const dimension = key === 'score' ? null : key.replace(/_score$/, '');\n      scores.push({ value, max: 10, dimension });\n    }\n  }\n\n  return scores;\n}\n\n// -----------------------------------------------------------------------------\n// Policy Loading\n// -----------------------------------------------------------------------------\n\nfunction loadPolicy(): VerificationPolicy {\n  const projectDir = getProjectDir();\n  if (!projectDir || projectDir === '.') return {};\n\n  const policyPath = join(projectDir, '.claude', 'policies', 'verification-policy.json');\n  if (!existsSync(policyPath)) return {};\n\n  try {\n    return JSON.parse(readFileSync(policyPath, 'utf8')) as VerificationPolicy;\n  } catch {\n    logHook('subagent-quality-gate', 'Failed to parse verification-policy.json', 'warn');\n    return {};\n  }\n}\n\nfunction getThreshold(dimension: string | null, policy: VerificationPolicy): number {\n  const thresholds: Record<string, number> = { ...DEFAULT_THRESHOLDS, ...policy.thresholds };\n\n  if (dimension) {\n    const dimKey = `${dimension}_minimum`;\n    if (dimKey in thresholds) {\n      return thresholds[dimKey] ?? DEFAULT_THRESHOLDS.general_minimum;\n    }\n    // Security-related dimensions use security threshold\n    if (/security|vuln|cve|owasp/i.test(dimension)) {\n      return thresholds.security_minimum ?? DEFAULT_THRESHOLDS.security_minimum;\n    }\n  }\n\n  return thresholds.general_minimum ?? DEFAULT_THRESHOLDS.general_minimum;\n}\n\n// -----------------------------------------------------------------------------\n// Structure Validation\n// -----------------------------------------------------------------------------\n\n/**\n * Check if the output contains structured evidence/findings.\n * Returns true if evidence is present or output is too short to expect structure.\n */\nfunction hasStructuredOutput(text: string): boolean {\n  if (!text || text.length < 200) return true; // Too short to expect structure\n\n  const evidencePatterns = [\n    /\\bfinding/i,\n    /\\bevidence/i,\n    /\\brecommendation/i,\n    /\\bissue/i,\n    /\\bresult/i,\n    /\\bsummary/i,\n    /^[-*]\\s/m, // Bullet points\n    /^\\d+\\.\\s/m, // Numbered lists\n    /^#{1,3}\\s/m, // Markdown headers\n  ];\n\n  return evidencePatterns.some((p) => p.test(text));\n}\n\n// -----------------------------------------------------------------------------\n// Metrics\n// -----------------------------------------------------------------------------\n\ninterface Metrics {\n  errors: number;\n  quality_checks: number;\n  threshold_failures: number;\n  [key: string]: unknown;\n}\n\nfunction updateMetrics(type: 'error' | 'threshold_failure' | 'check'): void {\n  if (!existsSync(METRICS_FILE)) return;\n\n  try {\n    const metrics: Metrics = JSON.parse(readFileSync(METRICS_FILE, 'utf8'));\n\n    if (type === 'error') {\n      metrics.errors = (metrics.errors || 0) + 1;\n    } else if (type === 'threshold_failure') {\n      metrics.threshold_failures = (metrics.threshold_failures || 0) + 1;\n    }\n    metrics.quality_checks = (metrics.quality_checks || 0) + 1;\n\n    writeFileSync(METRICS_FILE, JSON.stringify(metrics, null, 2));\n  } catch {\n    // Ignore\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/** Validates subagent output quality with score thresholds and structure checks. */\nexport function subagentQualityGate(input: HookInput): HookResult {\n  const agentId = input.agent_id || '';\n  const subagentType = input.subagent_type || '';\n  const error = input.error || '';\n  const outputText = input.agent_output || input.output || input.last_assistant_message || '';\n\n  logHook('subagent-quality-gate', `Quality gate check: ${subagentType} (${agentId})`);\n\n  // Gate 1: Error presence check (existing behavior)\n  if (error && error !== 'null') {\n    logHook('subagent-quality-gate', `ERROR: Subagent failed - ${error}`);\n    updateMetrics('error');\n    return outputWarning(`Subagent ${subagentType} failed: ${error}`);\n  }\n\n  // Gate 2: Score threshold validation\n  const scores = extractScores(outputText);\n  if (scores.length > 0) {\n    const policy = loadPolicy();\n\n    for (const score of scores) {\n      const normalized = (score.value / score.max) * 10; // Normalize to 0-10 scale\n      const threshold = getThreshold(score.dimension, policy);\n      const label = score.dimension || 'overall';\n\n      if (normalized < threshold) {\n        logHook(\n          'subagent-quality-gate',\n          `Score below threshold: ${label}=${normalized.toFixed(1)}/10 (min: ${threshold})`,\n          'warn',\n        );\n        updateMetrics('threshold_failure');\n        return outputWarning(\n          `Quality gate: ${label} score ${score.value}/${score.max} ` +\n            `(${normalized.toFixed(1)}/10) is below minimum ${threshold}/10. ` +\n            `Review the ${label} findings before proceeding.`,\n        );\n      }\n    }\n  }\n\n  // Gate 3: Output structure validation (advisory only for long outputs)\n  if (outputText.length > 200 && !hasStructuredOutput(outputText)) {\n    logHook(\n      'subagent-quality-gate',\n      `Subagent ${subagentType} output lacks structured findings`,\n      'info',\n    );\n    // Don't block \u2014 just warn. Missing structure is a quality signal, not a hard gate.\n  }\n\n  return outputSilentSuccess();\n}\n", "/**\n * Retry Handler - SubagentStop Hook for Failed Agent Retry Logic\n * Issue #197: Agent Orchestration Layer\n *\n * Handles agent failures by:\n * 1. Evaluating if retry is appropriate\n * 2. Suggesting alternative agents when needed\n * 3. Tracking retry history\n *\n * CC 2.1.9 Compliant: Uses hookSpecificOutput.additionalContext\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, outputWithContext, logHook } from '../lib/common.js';\nimport {\n  makeRetryDecision,\n  formatRetryDecision,\n  createAttempt,\n  completeAttempt,\n} from '../lib/retry-manager.js';\nimport { loadConfig, loadState, updateAgentStatus } from '../lib/orchestration-state.js';\nimport { updateTaskStatus, getTaskByAgent } from '../lib/task-integration.js';\nimport type { AgentOutcome, ExecutionAttempt } from '../lib/orchestration-types.js';\n\n// -----------------------------------------------------------------------------\n// Execution History Storage\n// -----------------------------------------------------------------------------\n\n/** In-memory execution history (per session) */\nconst executionHistory: Map<string, ExecutionAttempt[]> = new Map();\n\n/**\n * Add attempt to history\n */\nfunction addToHistory(agent: string, attempt: ExecutionAttempt): void {\n  const history = executionHistory.get(agent) || [];\n  history.push(attempt);\n  // Keep only last 10 attempts per agent\n  if (history.length > 10) {\n    history.shift();\n  }\n  executionHistory.set(agent, history);\n}\n\n/**\n * Get tried agents (those with failed attempts)\n */\nfunction getTriedAgents(): string[] {\n  const tried: string[] = [];\n  for (const [agent, attempts] of executionHistory) {\n    if (attempts.some(a => a.outcome === 'failure')) {\n      tried.push(agent);\n    }\n  }\n  return tried;\n}\n\n// -----------------------------------------------------------------------------\n// Outcome Detection\n// -----------------------------------------------------------------------------\n\n/**\n * Detect outcome from hook input\n */\nfunction detectOutcome(input: HookInput): { outcome: AgentOutcome; error?: string } {\n  const error = input.error || input.tool_error;\n  const exitCode = input.exit_code;\n  const output = input.agent_output || input.output || '';\n\n  // Explicit error\n  if (error && error !== 'null' && error !== '') {\n    return { outcome: 'failure', error };\n  }\n\n  // Non-zero exit code\n  if (exitCode !== undefined && exitCode !== 0) {\n    return { outcome: 'failure', error: `Exit code: ${exitCode}` };\n  }\n\n  // Check output for rejection patterns\n  const rejectionPatterns = [\n    /i cannot|i can't|i am unable/i,\n    /outside my scope/i,\n    /not appropriate/i,\n    /i refuse/i,\n  ];\n\n  for (const pattern of rejectionPatterns) {\n    if (pattern.test(output.slice(0, 500))) {\n      return { outcome: 'rejected', error: 'Agent rejected the task' };\n    }\n  }\n\n  // Check for partial success patterns\n  const partialPatterns = [\n    /partial(?:ly)?/i,\n    /incomplete/i,\n    /some.*failed/i,\n    /couldn't finish/i,\n  ];\n\n  for (const pattern of partialPatterns) {\n    if (pattern.test(output.slice(0, 500))) {\n      return { outcome: 'partial' };\n    }\n  }\n\n  return { outcome: 'success' };\n}\n\n// -----------------------------------------------------------------------------\n// Hook Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Retry handler hook - handles agent failures and retry decisions\n *\n * When an agent fails, this hook:\n * 1. Records the attempt in history\n * 2. Evaluates whether to retry\n * 3. Suggests alternatives if retry not recommended\n */\nexport function retryHandler(input: HookInput): HookResult {\n  // Get agent type\n  const toolInput = input.tool_input || {};\n  const agentType =\n    (toolInput.subagent_type as string) ||\n    input.subagent_type ||\n    input.agent_type ||\n    '';\n\n  if (!agentType) {\n    return outputSilentSuccess();\n  }\n\n  // Detect outcome\n  const { outcome, error } = detectOutcome(input);\n\n  // Skip retry logic for successful completions\n  if (outcome === 'success') {\n    return outputSilentSuccess();\n  }\n\n  logHook('retry-handler', `Agent ${agentType} completed with outcome: ${outcome}`);\n\n  // Load config and state\n  const config = loadConfig();\n  const state = loadState();\n\n  // Find dispatched agent in state\n  const dispatchedAgent = state.activeAgents.find(a => a.agent === agentType);\n  const currentRetryCount = dispatchedAgent?.retryCount || 0;\n\n  // Record attempt\n  const attempt = createAttempt(agentType, currentRetryCount + 1, dispatchedAgent?.taskId);\n  const completedAttempt = completeAttempt(\n    attempt,\n    outcome,\n    error || undefined\n  );\n  addToHistory(agentType, completedAttempt);\n\n  // Get tried agents for alternative suggestions\n  const triedAgents = getTriedAgents();\n\n  // Make retry decision\n  const decision = makeRetryDecision(\n    agentType,\n    currentRetryCount + 1,\n    error || 'Unknown failure',\n    triedAgents,\n    config.maxRetries\n  );\n\n  logHook(\n    'retry-handler',\n    `Retry decision for ${agentType}: shouldRetry=${decision.shouldRetry}, ` +\n    `alternative=${decision.alternativeAgent || 'none'}`\n  );\n\n  // Update agent status based on decision\n  if (decision.shouldRetry) {\n    updateAgentStatus(agentType, 'retrying');\n  } else {\n    updateAgentStatus(agentType, 'failed');\n\n    // Update task status if exists\n    const task = getTaskByAgent(agentType);\n    if (task) {\n      updateTaskStatus(task.taskId, 'failed');\n    }\n  }\n\n  // Format message for user\n  const message = formatRetryDecision(decision, agentType);\n\n  return outputWithContext(message);\n}\n", "/**\n * Session Event Tracker\n * Logs all session events (skills, agents, hooks, decisions) with user identity.\n *\n * Events are stored per-session in JSONL format for later aggregation.\n * This enables learning user patterns across sessions.\n *\n * Storage: .claude/memory/sessions/{session_id}/events.jsonl\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport { getIdentityContext, type IdentityContext } from './user-identity.js';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * Event types that can be tracked\n */\nexport type SessionEventType =\n  | 'skill_invoked'\n  | 'agent_spawned'\n  | 'hook_triggered'\n  | 'decision_made'\n  | 'preference_stated'\n  | 'problem_reported'\n  | 'solution_found'\n  | 'tool_used'\n  | 'session_start'\n  | 'session_end'\n  | 'communication_style_detected';\n\n/**\n * A single session event\n */\nexport interface SessionEvent {\n  /** Unique event ID */\n  event_id: string;\n  /** Event type */\n  event_type: SessionEventType;\n  /** Identity context (user, session, machine) */\n  identity: IdentityContext;\n  /** Event-specific payload */\n  payload: {\n    /** Name of skill/agent/hook/tool */\n    name: string;\n    /** Input data (optional, may be truncated for privacy) */\n    input?: Record<string, unknown>;\n    /** Output/result (optional, may be truncated) */\n    output?: Record<string, unknown>;\n    /** Duration in milliseconds */\n    duration_ms?: number;\n    /** Whether the event succeeded */\n    success: boolean;\n    /** Additional context */\n    context?: string;\n    /** Confidence score (for decisions) */\n    confidence?: number;\n  };\n}\n\n/**\n * Session summary (aggregated at session end)\n */\nexport interface SessionSummary {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  start_time?: string;\n  end_time?: string;\n  duration_ms?: number;\n  event_counts: Record<SessionEventType, number>;\n  skills_used: string[];\n  agents_spawned: string[];\n  hooks_triggered: string[];\n  decisions_made: number;\n  problems_reported: number;\n  solutions_found: number;\n}\n\n// =============================================================================\n// PATHS\n// =============================================================================\n\n/** Session ID validation regex - alphanumeric, dashes, underscores only (SEC-002) */\nconst SESSION_ID_PATTERN = /^[a-zA-Z0-9_-]{1,128}$/;\n\n/**\n * Validate session ID to prevent path traversal attacks.\n * Defense-in-depth: trusted sources, but we validate at boundary anyway.\n */\nfunction isValidSessionId(sessionId: string): boolean {\n  return SESSION_ID_PATTERN.test(sessionId);\n}\n\n/**\n * Get session storage directory\n * @param sessionId - Optional session ID (defaults to env var)\n * @param projectDir - Optional project directory (defaults to env var)\n */\nfunction getSessionDir(sessionId?: string, projectDir?: string): string {\n  const sid = sessionId || getSessionId();\n  const pDir = projectDir || getProjectDir();\n  // Validate session ID to prevent path traversal (SEC-002)\n  if (!isValidSessionId(sid)) {\n    throw new Error(`Invalid session ID format`);\n  }\n  return `${pDir}/.claude/memory/sessions/${sid}`;\n}\n\n/**\n * Get events file path for a session\n */\nfunction getEventsPath(sessionId?: string, projectDir?: string): string {\n  return `${getSessionDir(sessionId, projectDir)}/events.jsonl`;\n}\n\n/**\n * Ensure session directory exists\n */\nfunction ensureSessionDir(sessionId?: string, projectDir?: string): void {\n  const dir = getSessionDir(sessionId, projectDir);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n// =============================================================================\n// EVENT GENERATION (Persistent Counter - Issue #245)\n// =============================================================================\n\n/** In-memory event counter */\nlet eventCounter = 0;\n\n/** Counter persistence state */\nlet counterLoaded = false;\nlet counterDirty = false;\nlet lastPersistTime = 0;\n\n/** Batch persist interval (ms) - write at most every 5 seconds */\nconst PERSIST_INTERVAL = 5000;\n\n/**\n * Get counter file path for current session\n */\nfunction getCounterPath(sessionId?: string, projectDir?: string): string {\n  const dir = getSessionDir(sessionId, projectDir);\n  return `${dir}/counter.json`;\n}\n\n/**\n * Load persisted counter value\n * Called once at first event generation\n */\nfunction loadPersistedCounter(sessionId?: string, projectDir?: string): void {\n  if (counterLoaded) return;\n  counterLoaded = true;\n\n  try {\n    const counterPath = getCounterPath(sessionId, projectDir);\n    if (existsSync(counterPath)) {\n      const data = JSON.parse(readFileSync(counterPath, 'utf8'));\n      if (typeof data.counter === 'number' && data.counter > 0) {\n        eventCounter = data.counter;\n        logHook('session-tracker', `Loaded event counter: ${eventCounter}`, 'debug');\n      }\n    }\n  } catch {\n    // Ignore load errors - start fresh\n  }\n}\n\n/**\n * Persist counter to disk (batched)\n * Only writes if counter changed and interval elapsed\n */\nfunction persistCounter(sessionId?: string, projectDir?: string): void {\n  if (!counterDirty) return;\n\n  const now = Date.now();\n  if (now - lastPersistTime < PERSIST_INTERVAL) return;\n\n  try {\n    ensureSessionDir(sessionId, projectDir);\n    const counterPath = getCounterPath(sessionId, projectDir);\n    writeFileSync(counterPath, JSON.stringify({\n      counter: eventCounter,\n      updated_at: new Date().toISOString(),\n    }));\n    counterDirty = false;\n    lastPersistTime = now;\n  } catch {\n    // Ignore persist errors - non-critical\n  }\n}\n\n/**\n * Generate unique event ID with persistent counter\n *\n * Format: evt-{timestamp}-{counter}\n * Counter persists across process restarts to prevent ID collisions.\n */\nfunction generateEventId(): string {\n  // Load persisted counter on first call\n  loadPersistedCounter();\n\n  eventCounter++;\n  counterDirty = true;\n\n  // Attempt batched persist\n  persistCounter();\n\n  return `evt-${Date.now()}-${eventCounter}`;\n}\n\n/**\n * Force persist counter (call at session end)\n * Exported for use by stop hooks\n */\nexport function flushEventCounter(): void {\n  if (counterDirty) {\n    try {\n      ensureSessionDir();\n      const counterPath = getCounterPath();\n      writeFileSync(counterPath, JSON.stringify({\n        counter: eventCounter,\n        updated_at: new Date().toISOString(),\n      }));\n      counterDirty = false;\n      logHook('session-tracker', `Flushed event counter: ${eventCounter}`, 'debug');\n    } catch {\n      // Ignore\n    }\n  }\n}\n\n/**\n * Reset counter state (for testing only)\n */\nexport function resetEventCounter(): void {\n  eventCounter = 0;\n  counterLoaded = false;\n  counterDirty = false;\n  lastPersistTime = 0;\n}\n\n// =============================================================================\n// EVENT TRACKING\n// =============================================================================\n\n/**\n * Track a session event\n *\n * @param eventType - Type of event\n * @param name - Name of skill/agent/hook/tool\n * @param options - Additional event options\n */\nexport function trackEvent(\n  eventType: SessionEventType,\n  name: string,\n  options: {\n    input?: Record<string, unknown>;\n    output?: Record<string, unknown>;\n    duration_ms?: number;\n    success?: boolean;\n    context?: string;\n    confidence?: number;\n  } = {}\n): void {\n  try {\n    const event: SessionEvent = {\n      event_id: generateEventId(),\n      event_type: eventType,\n      identity: getIdentityContext(),\n      payload: {\n        name,\n        input: sanitizeForStorage(options.input),\n        output: sanitizeForStorage(options.output),\n        duration_ms: options.duration_ms,\n        success: options.success ?? true,\n        context: options.context ? truncate(options.context, 500) : undefined,\n        confidence: options.confidence,\n      },\n    };\n\n    ensureSessionDir();\n    const eventsPath = getEventsPath();\n    bufferWrite(eventsPath, `${JSON.stringify(event)}\\n`);\n\n    logHook('session-tracker', `Tracked ${eventType}: ${name}`, 'debug');\n  } catch (error) {\n    logHook('session-tracker', `Failed to track event: ${error}`, 'warn');\n  }\n}\n\n/**\n * Track skill invocation\n */\nexport function trackSkillInvoked(\n  skillName: string,\n  args?: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('skill_invoked', skillName, {\n    input: args ? { args } : undefined,\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track agent spawn\n */\nexport function trackAgentSpawned(\n  agentType: string,\n  prompt?: string,\n  success: boolean = true\n): void {\n  trackEvent('agent_spawned', agentType, {\n    input: prompt ? { prompt: truncate(prompt, 200) } : undefined,\n    success,\n  });\n}\n\n/**\n * Track hook triggered\n */\nexport function trackHookTriggered(\n  hookName: string,\n  success: boolean = true,\n  durationMs?: number\n): void {\n  trackEvent('hook_triggered', hookName, {\n    success,\n    duration_ms: durationMs,\n  });\n}\n\n/**\n * Track decision made\n */\nexport function trackDecisionMade(\n  decision: string,\n  rationale?: string,\n  confidence?: number\n): void {\n  trackEvent('decision_made', 'decision', {\n    context: decision,\n    input: rationale ? { rationale } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track preference stated\n */\nexport function trackPreferenceStated(\n  preference: string,\n  confidence?: number\n): void {\n  trackEvent('preference_stated', 'preference', {\n    context: preference,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track problem reported\n */\nexport function trackProblemReported(problem: string): void {\n  trackEvent('problem_reported', 'problem', {\n    context: problem,\n    success: true,\n  });\n}\n\n/**\n * Track solution found\n */\nexport function trackSolutionFound(\n  solution: string,\n  problemId?: string,\n  confidence?: number\n): void {\n  trackEvent('solution_found', 'solution', {\n    context: solution,\n    input: problemId ? { problem_id: problemId } : undefined,\n    confidence,\n    success: true,\n  });\n}\n\n/**\n * Track tool usage\n *\n * @param toolName - Name of the tool (e.g., 'Grep', 'Read')\n * @param success - Whether the tool call succeeded\n * @param durationMs - Duration of the tool call in milliseconds\n * @param category - Tool category (e.g., 'search', 'file_read') for preference tracking\n */\nexport function trackToolUsed(\n  toolName: string,\n  success: boolean = true,\n  durationMs?: number,\n  category?: string\n): void {\n  trackEvent('tool_used', toolName, {\n    success,\n    duration_ms: durationMs,\n    input: category ? { category } : undefined,\n  });\n}\n\n/**\n * Session context captured at session start\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport interface SessionContext {\n  /** Project directory path */\n  project_dir?: string;\n  /** Current git branch */\n  git_branch?: string;\n  /** Time of day category */\n  time_of_day?: 'morning' | 'afternoon' | 'evening' | 'night';\n  /** CC 2.1.47: Number of /add-dir directories active */\n  added_dirs_count?: number;\n  /** Timestamp */\n  started_at: string;\n}\n\n/**\n * Get time of day category from hour\n */\nfunction getTimeOfDay(hour: number): 'morning' | 'afternoon' | 'evening' | 'night' {\n  if (hour >= 5 && hour < 12) return 'morning';\n  if (hour >= 12 && hour < 17) return 'afternoon';\n  if (hour >= 17 && hour < 21) return 'evening';\n  return 'night';\n}\n\n/**\n * Track session start with context\n * Issue #245 Phase 5: Session Lifecycle Tracking\n *\n * @param context - Optional session context (project, branch, time)\n */\nexport function trackSessionStart(context?: Partial<SessionContext>): void {\n  const now = new Date();\n  const sessionContext: SessionContext = {\n    project_dir: context?.project_dir,\n    git_branch: context?.git_branch,\n    time_of_day: context?.time_of_day || getTimeOfDay(now.getHours()),\n    started_at: now.toISOString(),\n  };\n\n  trackEvent('session_start', 'session', {\n    success: true,\n    input: sessionContext as unknown as Record<string, unknown>,\n  });\n}\n\n/**\n * Track session end with timestamp\n * Issue #245 Phase 5: Session Lifecycle Tracking\n */\nexport function trackSessionEnd(): void {\n  trackEvent('session_end', 'session', {\n    success: true,\n    input: { ended_at: new Date().toISOString() },\n  });\n}\n\n/**\n * Track user communication style\n */\nexport function trackCommunicationStyle(\n  style: {\n    verbosity: 'terse' | 'moderate' | 'detailed';\n    interaction_type: 'question' | 'command' | 'discussion';\n    technical_level: 'beginner' | 'intermediate' | 'expert';\n  }\n): void {\n  trackEvent('communication_style_detected', 'communication', {\n    input: style as unknown as Record<string, unknown>,\n    success: true,\n  });\n}\n\n\n// =============================================================================\n// SESSION SUMMARY\n// =============================================================================\n\n/**\n * Load all events for a session\n */\nexport function loadSessionEvents(sessionId?: string): SessionEvent[] {\n  const eventsPath = getEventsPath(sessionId);\n\n  if (!existsSync(eventsPath)) {\n    return [];\n  }\n\n  try {\n    const content = readFileSync(eventsPath, 'utf8');\n    const lines = content.trim().split('\\n').filter(Boolean);\n    return lines.map(line => JSON.parse(line));\n  } catch (error) {\n    logHook('session-tracker', `Failed to load session events: ${error}`, 'warn');\n    return [];\n  }\n}\n\n/**\n * Generate session summary from events\n */\nexport function generateSessionSummary(sessionId?: string): SessionSummary {\n  const events = loadSessionEvents(sessionId);\n  const identity = getIdentityContext();\n\n  const eventCounts: Record<SessionEventType, number> = {\n    skill_invoked: 0,\n    agent_spawned: 0,\n    hook_triggered: 0,\n    decision_made: 0,\n    preference_stated: 0,\n    problem_reported: 0,\n    solution_found: 0,\n    tool_used: 0,\n    session_start: 0,\n    session_end: 0,\n    communication_style_detected: 0,\n  };\n\n  const skillsUsed = new Set<string>();\n  const agentsSpawned = new Set<string>();\n  const hooksTriggered = new Set<string>();\n\n  let startTime: string | undefined;\n  let endTime: string | undefined;\n\n  for (const event of events) {\n    eventCounts[event.event_type]++;\n\n    switch (event.event_type) {\n      case 'skill_invoked':\n        skillsUsed.add(event.payload.name);\n        break;\n      case 'agent_spawned':\n        agentsSpawned.add(event.payload.name);\n        break;\n      case 'hook_triggered':\n        hooksTriggered.add(event.payload.name);\n        break;\n      case 'session_start':\n        startTime = event.identity.timestamp;\n        break;\n      case 'session_end':\n        endTime = event.identity.timestamp;\n        break;\n    }\n  }\n\n  const durationMs =\n    startTime && endTime\n      ? new Date(endTime).getTime() - new Date(startTime).getTime()\n      : undefined;\n\n  return {\n    session_id: sessionId || identity.session_id,\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    start_time: startTime,\n    end_time: endTime,\n    duration_ms: durationMs,\n    event_counts: eventCounts,\n    skills_used: [...skillsUsed],\n    agents_spawned: [...agentsSpawned],\n    hooks_triggered: [...hooksTriggered],\n    decisions_made: eventCounts.decision_made,\n    problems_reported: eventCounts.problem_reported,\n    solutions_found: eventCounts.solution_found,\n  };\n}\n\n// =============================================================================\n// CROSS-SESSION QUERIES\n// =============================================================================\n// GAP-008/009 FIX: Removed listSessionIds() and getRecentUserSessions()\n// These functions were exported but never called by production code.\n// Cross-session queries should be handled by profile-injector if needed.\n// =============================================================================\n\n// =============================================================================\n// UTILITIES\n// =============================================================================\n\n/**\n * Truncate string to max length\n */\nfunction truncate(str: string, maxLen: number): string {\n  if (str.length <= maxLen) return str;\n  return `${str.slice(0, maxLen - 3)}...`;\n}\n\n/**\n * Sanitize object for storage (remove sensitive data, truncate)\n */\nfunction sanitizeForStorage(\n  obj: Record<string, unknown> | undefined\n): Record<string, unknown> | undefined {\n  if (!obj) return undefined;\n\n  const sanitized: Record<string, unknown> = {};\n  const sensitiveKeys = ['password', 'secret', 'token', 'key', 'credential', 'auth'];\n\n  for (const [key, value] of Object.entries(obj)) {\n    // Skip sensitive keys\n    if (sensitiveKeys.some(s => key.toLowerCase().includes(s))) {\n      sanitized[key] = '[REDACTED]';\n      continue;\n    }\n\n    // Truncate long strings\n    if (typeof value === 'string' && value.length > 500) {\n      sanitized[key] = truncate(value, 500);\n      continue;\n    }\n\n    // Recursively sanitize objects\n    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      sanitized[key] = sanitizeForStorage(value as Record<string, unknown>);\n      continue;\n    }\n\n    sanitized[key] = value;\n  }\n\n  return sanitized;\n}\n", "/**\n * User Identity System\n * Resolves and manages user identity across sessions for multi-user decision capture.\n *\n * Identity Resolution Order:\n * 1. Explicit config (.claude/.user_identity.json)\n * 2. Git config (user.email, user.name)\n * 3. Environment variables (USER, USERNAME)\n * 4. Anonymous (machine-based hash)\n *\n * Privacy: User controls what gets shared via privacy settings.\n * Storage: User profiles stored locally in .claude/memory/users/\n */\n\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { basename } from 'node:path';\nimport { getProjectDir, getSessionId, logHook } from './common.js';\nimport * as os from 'node:os';\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\n/**\n * User identity source - where the identity was resolved from\n */\nexport type IdentitySource = 'config' | 'git' | 'env' | 'anonymous';\n\n/**\n * Resolved user identity\n */\nexport interface UserIdentity {\n  /** Unique user identifier (email, username, or anonymous hash) */\n  user_id: string;\n  /** Human-readable display name */\n  display_name: string;\n  /** Optional team/org identifier */\n  team_id?: string;\n  /** Machine identifier (hostname) */\n  machine_id: string;\n  /** How the identity was resolved */\n  source: IdentitySource;\n  /** Anonymous hash for global sharing (privacy-preserving) */\n  anonymous_id: string;\n  /** Email if available */\n  email?: string;\n}\n\n/**\n * User privacy settings - controls what gets shared\n */\nexport interface PrivacySettings {\n  /** Share patterns with team (same project) */\n  share_with_team: boolean;\n  /** Share patterns globally (anonymized) */\n  share_globally: boolean;\n  /** Share decisions */\n  share_decisions: boolean;\n  /** Share preferences */\n  share_preferences: boolean;\n  /** Share skill usage statistics */\n  share_skill_usage: boolean;\n  /** Share prompt content (usually false for privacy) */\n  share_prompts: boolean;\n  /** Anonymize user_id when sharing globally */\n  anonymize_globally: boolean;\n}\n\n/**\n * User identity configuration file format\n */\nexport interface UserIdentityConfig {\n  /** Explicit user ID */\n  user_id?: string;\n  /** Display name */\n  display_name?: string;\n  /** Team identifier */\n  team_id?: string;\n  /** Privacy settings */\n  privacy?: Partial<PrivacySettings>;\n}\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst IDENTITY_CONFIG_FILE = '.claude/.user_identity.json';\nconst SALT = 'orchestkit-user-identity-v1';\n\n/** Default privacy settings (conservative) */\nconst DEFAULT_PRIVACY: PrivacySettings = {\n  share_with_team: true,\n  share_globally: false, // Opt-in\n  share_decisions: true,\n  share_preferences: true,\n  share_skill_usage: false, // Might reveal workflow\n  share_prompts: false, // Privacy sensitive\n  anonymize_globally: true,\n};\n\n// =============================================================================\n// CACHING\n// =============================================================================\n\nlet cachedIdentity: UserIdentity | null = null;\nlet cachedPrivacy: PrivacySettings | null = null;\n\n/**\n * Clear cached identity (for testing)\n */\nexport function clearIdentityCache(): void {\n  cachedIdentity = null;\n  cachedPrivacy = null;\n}\n\n// =============================================================================\n// IDENTITY RESOLUTION\n// =============================================================================\n\n/**\n * Generate anonymous hash from input\n */\nfunction generateAnonymousId(input: string): string {\n  // Use 32 hex chars (128 bits) for proper collision resistance\n  return createHash('sha256')\n    .update(input + SALT)\n    .digest('hex')\n    .slice(0, 32);\n}\n\n/**\n * Get machine identifier\n */\nfunction getMachineId(): string {\n  try {\n    return os.hostname();\n  } catch {\n    return 'unknown-machine';\n  }\n}\n\n/**\n * Try to read explicit user config\n */\nfunction readUserConfig(projectDir: string): UserIdentityConfig | null {\n  const configPath = `${projectDir}/${IDENTITY_CONFIG_FILE}`;\n\n  if (!existsSync(configPath)) {\n    return null;\n  }\n\n  try {\n    const content = readFileSync(configPath, 'utf8');\n    return JSON.parse(content);\n  } catch (error) {\n    logHook('user-identity', `Failed to read user config: ${error}`, 'warn');\n    return null;\n  }\n}\n\n/**\n * Try to get identity from git config\n */\nfunction getGitIdentity(projectDir: string): { email?: string; name?: string } {\n  const result: { email?: string; name?: string } = {};\n\n  try {\n    result.email = execSync('git config user.email', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git email not configured\n  }\n\n  try {\n    result.name = execSync('git config user.name', {\n      cwd: projectDir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n  } catch {\n    // Git name not configured\n  }\n\n  return result;\n}\n\n/**\n * Get identity from environment variables\n */\nfunction getEnvIdentity(): { username?: string } {\n  const username = process.env.USER || process.env.USERNAME || process.env.LOGNAME;\n  return { username };\n}\n\n/**\n * Resolve user identity using fallback chain\n *\n * Resolution order:\n * 1. Explicit config file\n * 2. Git config\n * 3. Environment username\n * 4. Anonymous (machine-based)\n */\nexport function resolveUserIdentity(projectDir?: string): UserIdentity {\n  // Return cached if available\n  if (cachedIdentity) {\n    return cachedIdentity;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const machineId = getMachineId();\n\n  // 1. Try explicit config\n  const config = readUserConfig(dir);\n  if (config?.user_id) {\n    cachedIdentity = {\n      user_id: config.user_id,\n      display_name: config.display_name || config.user_id,\n      team_id: config.team_id,\n      machine_id: machineId,\n      source: 'config',\n      anonymous_id: generateAnonymousId(config.user_id),\n      email: config.user_id.includes('@') ? config.user_id : undefined,\n    };\n    logHook('user-identity', `Resolved from config: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 2. Try git config\n  const git = getGitIdentity(dir);\n  if (git.email) {\n    cachedIdentity = {\n      user_id: git.email,\n      display_name: git.name || git.email.split('@')[0],\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'git',\n      anonymous_id: generateAnonymousId(git.email),\n      email: git.email,\n    };\n    logHook('user-identity', `Resolved from git: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 3. Try environment\n  const env = getEnvIdentity();\n  if (env.username) {\n    const userId = `${env.username}@${machineId}`;\n    cachedIdentity = {\n      user_id: userId,\n      display_name: env.username,\n      team_id: config?.team_id,\n      machine_id: machineId,\n      source: 'env',\n      anonymous_id: generateAnonymousId(userId),\n    };\n    logHook('user-identity', `Resolved from env: ${cachedIdentity.anonymous_id}`, 'debug');\n    return cachedIdentity;\n  }\n\n  // 4. Anonymous fallback\n  const anonId = generateAnonymousId(machineId + process.pid);\n  cachedIdentity = {\n    user_id: `anon-${anonId.slice(0, 8)}`,\n    display_name: 'Anonymous',\n    team_id: config?.team_id,\n    machine_id: machineId,\n    source: 'anonymous',\n    anonymous_id: anonId,\n  };\n  logHook('user-identity', `Resolved as anonymous: ${cachedIdentity.anonymous_id}`, 'debug');\n  return cachedIdentity;\n}\n\n// =============================================================================\n// PRIVACY SETTINGS\n// =============================================================================\n\n/**\n * Get user's privacy settings\n */\nexport function getPrivacySettings(projectDir?: string): PrivacySettings {\n  if (cachedPrivacy) {\n    return cachedPrivacy;\n  }\n\n  const dir = projectDir || getProjectDir();\n  const config = readUserConfig(dir);\n\n  cachedPrivacy = {\n    ...DEFAULT_PRIVACY,\n    ...config?.privacy,\n  };\n\n  return cachedPrivacy;\n}\n\n/**\n * Check if user allows sharing a specific type of data\n */\nexport function canShare(\n  dataType: 'decisions' | 'preferences' | 'skill_usage' | 'prompts',\n  scope: 'team' | 'global'\n): boolean {\n  const privacy = getPrivacySettings();\n\n  // Check scope permission first\n  if (scope === 'team' && !privacy.share_with_team) return false;\n  if (scope === 'global' && !privacy.share_globally) return false;\n\n  // Check data type permission\n  switch (dataType) {\n    case 'decisions':\n      return privacy.share_decisions;\n    case 'preferences':\n      return privacy.share_preferences;\n    case 'skill_usage':\n      return privacy.share_skill_usage;\n    case 'prompts':\n      return privacy.share_prompts;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get user ID for sharing (applies anonymization if needed)\n */\nexport function getUserIdForScope(scope: 'local' | 'team' | 'global'): string {\n  const identity = resolveUserIdentity();\n  const privacy = getPrivacySettings();\n\n  if (scope === 'global' && privacy.anonymize_globally) {\n    return identity.anonymous_id;\n  }\n\n  return identity.user_id;\n}\n\n// =============================================================================\n// IDENTITY PERSISTENCE\n// =============================================================================\n\n/**\n * Save user identity config (creates or updates)\n */\nexport function saveUserIdentityConfig(\n  config: UserIdentityConfig,\n  projectDir?: string\n): boolean {\n  const dir = projectDir || getProjectDir();\n  const configPath = `${dir}/${IDENTITY_CONFIG_FILE}`;\n  const configDir = `${dir}/.claude`;\n\n  try {\n    if (!existsSync(configDir)) {\n      mkdirSync(configDir, { recursive: true });\n    }\n\n    writeFileSync(configPath, JSON.stringify(config, null, 2));\n\n    // Clear cache to pick up new config\n    clearIdentityCache();\n\n    logHook('user-identity', `Saved identity config to ${configPath}`, 'info');\n    return true;\n  } catch (error) {\n    logHook('user-identity', `Failed to save identity config: ${error}`, 'error');\n    return false;\n  }\n}\n\n// =============================================================================\n// CONTEXT HELPERS\n// =============================================================================\n\n/**\n * Get full identity context for session events\n */\nexport interface IdentityContext {\n  session_id: string;\n  user_id: string;\n  anonymous_id: string;\n  team_id?: string;\n  machine_id: string;\n  identity_source: IdentitySource;\n  timestamp: string;\n}\n\n/**\n * Get identity context for tagging events\n */\nexport function getIdentityContext(): IdentityContext {\n  const identity = resolveUserIdentity();\n\n  return {\n    session_id: getSessionId(),\n    user_id: identity.user_id,\n    anonymous_id: identity.anonymous_id,\n    team_id: identity.team_id,\n    machine_id: identity.machine_id,\n    identity_source: identity.source,\n    timestamp: new Date().toISOString(),\n  };\n}\n\n/**\n * Get project-scoped user ID for memory storage\n * Format: {project}-{scope} (e.g., \"my-app-decisions\")\n */\nexport function getProjectUserId(scope: string): string {\n  const projectDir = getProjectDir();\n  // Use path.basename for cross-platform compatibility (Windows uses \\ not /)\n  const projectName = basename(projectDir) || 'unknown';\n  const sanitized = projectName.toLowerCase().replace(/[^a-z0-9-]/g, '-');\n  return `${sanitized}-${scope}`;\n}\n\n/**\n * Get user-scoped ID for memory storage\n * Format: {user_id}-{scope} (e.g., \"alice@company.com-preferences\")\n */\nexport function getUserScopedId(scope: string): string {\n  const identity = resolveUserIdentity();\n  const sanitizedUserId = identity.user_id.toLowerCase().replace(/[^a-z0-9@.-]/g, '-');\n  return `${sanitizedUserId}-${scope}`;\n}\n\n/**\n * Get global scope ID (for cross-project best practices)\n */\nexport function getGlobalScopeId(scope: string): string {\n  return `orchestkit-global-${scope}`;\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-09\n\n/**\n * Cross-Project Analytics \u2014 User-Scoped JSONL\n *\n * Writes local-only analytics to ~/.claude/analytics/.\n * Privacy-by-design: no PII, no prompts, no code, no raw paths.\n * Project paths are hashed (12-char SHA256) for irreversible anonymity.\n *\n * Issue #459: Local Cross-Project Analytics System\n */\n\nimport { mkdirSync, statSync, renameSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { createHash } from 'node:crypto';\nimport { getHomeDir, joinPath } from './paths.js';\n\nfunction getAnalyticsDir(): string {\n  return joinPath(getHomeDir(), '.claude', 'analytics');\n}\n\n/** Hash project path for privacy \u2014 irreversible, 12-char hex */\nexport function hashProject(projectDir: string): string {\n  return createHash('sha256').update(projectDir).digest('hex').slice(0, 12);\n}\n\n/** Extract team context from env vars. Returns undefined when not in a team. */\nexport function getTeamContext(): { team: string } | undefined {\n  const team = process.env.CLAUDE_CODE_TEAM_NAME;\n  return team ? { team } : undefined;\n}\n\n/** Rotate file if it exceeds maxBytes (default 10MB). Renames to <name>.<YYYY-MM>.jsonl */\nexport function rotateIfNeeded(filePath: string, maxBytes = 10_485_760): void {\n  try {\n    const stats = statSync(filePath);\n    if (stats.size > maxBytes) {\n      const month = new Date().toISOString().slice(0, 7); // YYYY-MM\n      const rotated = filePath.replace(/\\.jsonl$/, `.${month}.jsonl`);\n      renameSync(filePath, rotated);\n    }\n  } catch {\n    // File doesn't exist or rename failed \u2014 both fine\n  }\n}\n\n/** Returns true when running inside a test runner (vitest / jest). */\nexport function isTestEnv(): boolean {\n  return !!(process.env.VITEST || process.env.JEST_WORKER_ID);\n}\n\n/** Append a JSONL entry to ~/.claude/analytics/<file>. Fire-and-forget. */\nexport function appendAnalytics(file: string, entry: Record<string, unknown>): void {\n  if (isTestEnv()) return;\n  try {\n    const dir = getAnalyticsDir();\n    mkdirSync(dir, { recursive: true });\n    const filePath = joinPath(dir, file);\n    rotateIfNeeded(filePath);\n    bufferWrite(filePath, `${JSON.stringify(entry)}\\n`);\n  } catch {\n    // Never block hooks\n  }\n}\n", "/**\n * Unified SubagentStop Dispatcher\n * Issue #235: Hook Architecture Refactor\n *\n * Consolidates 4 async SubagentStop hooks into a single dispatcher.\n * Reduces \"Async hook SubagentStop completed\" messages from 4 to 1.\n *\n * CC 2.1.19 Compliant: Single async hook with internal routing\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport { trackEvent } from '../lib/session-tracker.js';\nimport { appendAnalytics, hashProject, getTeamContext } from '../lib/analytics.js';\n\n// Import individual hook implementations\nimport { contextPublisher } from './context-publisher.js';\nimport { handoffPreparer } from './handoff-preparer.js';\nimport { feedbackLoop } from './feedback-loop.js';\nimport { agentMemoryStore } from './agent-memory-store.js';\n\n// -----------------------------------------------------------------------------\n// Types\n// -----------------------------------------------------------------------------\n\ntype HookFn = (input: HookInput) => HookResult | Promise<HookResult>;\n\ninterface HookConfig {\n  name: string;\n  fn: HookFn;\n}\n\n// -----------------------------------------------------------------------------\n// Hook Registry\n// -----------------------------------------------------------------------------\n\n/**\n * Registry of all async SubagentStop hooks consolidated into dispatcher\n */\nconst HOOKS: HookConfig[] = [\n  { name: 'context-publisher', fn: contextPublisher },\n  { name: 'handoff-preparer', fn: handoffPreparer },\n  { name: 'feedback-loop', fn: feedbackLoop },\n  { name: 'agent-memory-store', fn: agentMemoryStore },\n];\n\n/** Exposed for registry wiring tests */\nexport const registeredHookNames = () => HOOKS.map(h => h.name);\n\n// -----------------------------------------------------------------------------\n// Agent Result Tracking (Issue #245)\n// -----------------------------------------------------------------------------\n\n/**\n * Track agent result for user profiling\n * Issue #245: Multi-User Intelligent Decision Capture\n */\nfunction trackAgentResult(input: HookInput): void {\n  try {\n    const agentType = input.tool_input?.subagent_type as string\n      || input.subagent_type\n      || input.agent_type\n      || 'unknown';\n    const agentName = input.tool_input?.name as string || undefined;\n    const success = !input.error;\n    const durationMs = input.duration_ms;\n\n    // Extract result quality indicators\n    const output = input.agent_output || input.output || '';\n    const outputLength = typeof output === 'string' ? output.length : 0;\n\n    trackEvent('agent_spawned', agentType, {\n      success,\n      duration_ms: durationMs,\n      output: {\n        has_output: outputLength > 0,\n        output_length: outputLength,\n        has_error: !!input.error,\n      },\n      context: input.agent_id,\n    });\n\n    // Extract model from SubagentStop input or environment\n    const model = input.tool_input?.model as string\n      || process.env.CLAUDE_MODEL\n      || 'unknown';\n\n    // Cross-project analytics (Issue #459, #727)\n    appendAnalytics('agent-usage.jsonl', {\n      ts: new Date().toISOString(),\n      pid: hashProject(process.env.CLAUDE_PROJECT_DIR || ''),\n      agent: agentType,\n      agent_name: agentName ?? null,\n      model,\n      duration_ms: durationMs,\n      success,\n      output_len: outputLength,\n      last_msg_len: input.last_assistant_message?.length ?? null,\n      ...getTeamContext(),\n    });\n  } catch {\n    // Silent failure - tracking should never break hooks\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Dispatcher Implementation\n// -----------------------------------------------------------------------------\n\n/**\n * Unified dispatcher that runs all SubagentStop hooks in parallel\n */\nexport async function unifiedSubagentStopDispatcher(input: HookInput): Promise<HookResult> {\n  // Track agent result (Issue #245: Multi-User Intelligent Decision Capture)\n  trackAgentResult(input);\n\n  // Run all hooks in parallel\n  const results = await Promise.allSettled(\n    HOOKS.map(async hook => {\n      try {\n        const result = hook.fn(input);\n        if (result instanceof Promise) {\n          await result;\n        }\n        return { hook: hook.name, status: 'success' };\n      } catch (error) {\n        const message = error instanceof Error ? error.message : String(error);\n        logHook('subagent-stop-dispatcher', `${hook.name} failed: ${message}`);\n        return { hook: hook.name, status: 'error', message };\n      }\n    })\n  );\n\n  // Log summary for debugging (only errors)\n  const errors = results.filter(\n    r => r.status === 'rejected' || (r.status === 'fulfilled' && r.value.status === 'error')\n  );\n\n  if (errors.length > 0) {\n    logHook('subagent-stop-dispatcher', `${errors.length}/${HOOKS.length} hooks had errors`);\n  }\n\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-28\n\n/**\n * Sync SubagentStop Dispatcher \u2014 SubagentStop Hook\n * Consolidates 6 synchronous SubagentStop hooks into a single dispatcher.\n *\n * Consolidated hooks:\n * - output-validator (first \u2014 validates output before other hooks process it; may block)\n * - auto-spawn-quality (may return systemMessage)\n * - multi-claude-verifier (may return systemMessage)\n * - subagent-quality-gate (may block via outputWarning)\n * - retry-handler (may return additionalContext via outputWithContext)\n *\n * NOT consolidated (remains separate in hooks.json):\n * - unified-dispatcher (async \u2014 fire-and-forget analytics)\n *\n * CC 2.1.9 Compliant: Short-circuits on continue: false; merges additionalContext + systemMessage\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook, extractContext } from '../lib/common.js';\n\n// Import consolidated hook implementations\nimport { outputValidator } from './output-validator.js';\nimport { autoSpawnQuality } from './auto-spawn-quality.js';\nimport { multiClaudeVerifier } from './multi-claude-verifier.js';\nimport { subagentQualityGate } from './subagent-quality-gate.js';\nimport { retryHandler } from './retry-handler.js';\n\nconst HOOK_NAME = 'sync-subagent-stop-dispatcher';\n\ninterface SyncHookConfig {\n  name: string;\n  fn: (input: HookInput) => HookResult;\n}\n\n/**\n * Registry of sync SubagentStop hooks, executed sequentially.\n * Order matters \u2014 output-validator runs first to validate output before other hooks process it.\n */\nconst SYNC_HOOKS: SyncHookConfig[] = [\n  { name: 'output-validator', fn: outputValidator },\n  { name: 'auto-spawn-quality', fn: autoSpawnQuality },\n  { name: 'multi-claude-verifier', fn: multiClaudeVerifier },\n  { name: 'subagent-quality-gate', fn: subagentQualityGate },\n  { name: 'retry-handler', fn: retryHandler },\n];\n\n/**\n * Consolidated sync SubagentStop dispatcher.\n * Runs all sync hooks sequentially. If any hook returns continue: false,\n * short-circuits immediately and returns that block result.\n * Merges systemMessage and additionalContext from all passing hooks.\n */\nexport function syncSubagentStopDispatcher(input: HookInput): HookResult {\n  const messages: string[] = [];\n\n  for (const hook of SYNC_HOOKS) {\n    try {\n      const result = hook.fn(input);\n\n      // Short-circuit immediately if any hook blocks\n      if (result.continue === false) {\n        logHook(HOOK_NAME, `${hook.name}: blocked (continue: false) \u2014 short-circuiting`);\n        return result;\n      }\n\n      // Collect systemMessage\n      if (result.systemMessage) {\n        messages.push(result.systemMessage);\n        logHook(HOOK_NAME, `${hook.name}: systemMessage collected`);\n      }\n\n      // Collect additionalContext (retry-handler uses outputWithContext)\n      const context = extractContext(result);\n      if (context && !result.systemMessage) {\n        messages.push(context);\n        logHook(HOOK_NAME, `${hook.name}: additionalContext collected`);\n      }\n    } catch (error) {\n      const msg = error instanceof Error ? error.message : String(error);\n      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');\n    }\n  }\n\n  if (messages.length === 0) {\n    logHook(HOOK_NAME, 'All sync hooks silent');\n    return outputSilentSuccess();\n  }\n\n  const merged = messages.join('\\n');\n  logHook(HOOK_NAME, `Merged ${messages.length} messages from sync hooks`);\n\n  return {\n    continue: true,\n    systemMessage: merged,\n  };\n}\n", "/**\n * Subagent Hooks Entry Point\n *\n * Hooks that run on subagent start/stop (SubagentStart, SubagentStop)\n * Bundle: subagent.mjs (~30 KB estimated)\n */\n\n// Re-export types and utilities\nexport * from '../types.js';\nexport * from '../lib/common.js';\n\n// Re-export orchestration modules needed by subagent hooks\nexport * from '../lib/orchestration-types.js';\nexport * from '../lib/orchestration-state.js';\nexport * from '../lib/retry-manager.js';\nexport * from '../lib/calibration-engine.js';\n\n// SubagentStart hooks (6)\nimport { graphMemoryInject } from '../subagent-start/graph-memory-inject.js';\nimport { contextGate } from '../subagent-start/context-gate.js';\nimport { subagentContextStager } from '../subagent-start/subagent-context-stager.js';\nimport { subagentValidator } from '../subagent-start/subagent-validator.js';\nimport { modelCostAdvisor } from '../subagent-start/model-cost-advisor.js';\nimport { issueContextInjector } from '../subagent-start/issue-context-injector.js';\nimport { unifiedSubagentStartDispatcher } from '../subagent-start/unified-dispatcher.js';\n\n// SubagentStop hooks (9)\nimport { agentMemoryStore } from '../subagent-stop/agent-memory-store.js';\nimport { autoSpawnQuality } from '../subagent-stop/auto-spawn-quality.js';\nimport { contextPublisher } from '../subagent-stop/context-publisher.js';\nimport { feedbackLoop } from '../subagent-stop/feedback-loop.js';\nimport { handoffPreparer } from '../subagent-stop/handoff-preparer.js';\nimport { multiClaudeVerifier } from '../subagent-stop/multi-claude-verifier.js';\nimport { outputValidator } from '../subagent-stop/output-validator.js';\nimport { subagentQualityGate } from '../subagent-stop/subagent-quality-gate.js';\nimport { retryHandler } from '../subagent-stop/retry-handler.js';\nimport { unifiedSubagentStopDispatcher } from '../subagent-stop/unified-dispatcher.js';\nimport { syncSubagentStopDispatcher } from '../subagent-stop/sync-subagent-stop-dispatcher.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Subagent hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  // SubagentStart hooks (6)\n  'subagent-start/graph-memory-inject': graphMemoryInject,\n  'subagent-start/context-gate': contextGate,\n  'subagent-start/subagent-context-stager': subagentContextStager,\n  'subagent-start/subagent-validator': subagentValidator,\n  'subagent-start/model-cost-advisor': modelCostAdvisor,\n  'subagent-start/issue-context-injector': issueContextInjector,\n  'subagent-start/unified-dispatcher': unifiedSubagentStartDispatcher,\n\n  // SubagentStop hooks (9)\n  'subagent-stop/agent-memory-store': agentMemoryStore,\n  'subagent-stop/auto-spawn-quality': autoSpawnQuality,\n  'subagent-stop/context-publisher': contextPublisher,\n  'subagent-stop/feedback-loop': feedbackLoop,\n  'subagent-stop/handoff-preparer': handoffPreparer,\n  'subagent-stop/multi-claude-verifier': multiClaudeVerifier,\n  'subagent-stop/output-validator': outputValidator,\n  'subagent-stop/subagent-quality-gate': subagentQualityGate,\n  'subagent-stop/retry-handler': retryHandler,\n  'subagent-stop/unified-dispatcher': unifiedSubagentStopDispatcher,\n  'subagent-stop/sync-subagent-stop-dispatcher': syncSubagentStopDispatcher,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "readFileSync", "writeFileSync", "join", "appendFileSync", "mkdirSync", "dirname", "buffer", "flushing", "handlersRegistered", "bufferWrite", "filePath", "content", "ensureHandlers", "flush", "grouped", "entry", "arr", "path", "contents", "ensureHandlers", "handlersRegistered", "flush", "execSync", "os", "path", "getHomeDir", "getTempDir", "getProjectDir", "getPluginRoot", "getLogDir", "getMetricsFile", "path", "getTempDir", "joinPath", "path", "pathSeparator", "execSync", "createHash", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "basename", "MAX_PROJECT_LENGTH", "MAX_BRANCH_LENGTH", "SAFE_CHARS", "getProjectName", "projectDir", "dir", "name", "sanitizeName", "getGitBranchForSession", "branch", "sanitized", "formatDateComponent", "date", "d", "month", "day", "formatTimeComponent", "hours", "minutes", "generateShortHash", "entropy", "maxLength", "generateSmartSessionId", "project", "dateStr", "timeStr", "hash", "getCachedSessionId", "cachePath", "data", "age", "maxAge", "cacheSessionId", "sessionId", "instanceDir", "getOrGenerateSessionId", "cached", "newId", "getLogDir", "getProjectDir", "getPluginRoot", "getEnvFile", "getSessionId", "getOrGenerateSessionId", "getCachedBranch", "projectDir", "branch", "execSync", "getLogLevel", "normalizeLineEndings", "content", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputWithNotification", "userMessage", "claudeContext", "result", "outputAllowWithContext", "systemMessage", "outputError", "message", "outputWarning", "outputStderrWarning", "outputDeny", "outputWithUpdatedInput", "updatedInput", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "existsSync", "statSync", "rotated", "renameSync", "ensureDir", "dir", "mkdirSync", "logHook", "hookName", "logDir", "timestamp", "bufferWrite", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "extractContext", "estimateTokenCount", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "fnv1aHash", "str", "hash", "i", "writeRulesFile", "rulesDir", "filename", "filePath", "join", "existing", "readFileSync", "writeFileSync", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "lineContainsAll", "terms", "line", "t", "lineContainsAllCI", "lower", "normalizeCommand", "command", "escapeRegex", "THRESHOLDS", "DEFAULT_CONFIG", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getStateDir", "getProjectDir", "getStateFile", "sessionId", "getSessionId", "getConfigFile", "ensureStateDir", "dir", "existsSync", "mkdirSync", "logHook", "loadState", "stateFile", "data", "readFileSync", "err", "saveState", "state", "writeFileSync", "updateState", "mutate", "trackDispatchedAgent", "agent", "confidence", "taskId", "dispatched", "a", "updateAgentStatus", "status", "entry", "removeAgent", "getActiveAgent", "isAgentDispatched", "trackInjectedSkill", "skill", "isSkillInjected", "getInjectedSkills", "addToPromptHistory", "prompt", "getPromptHistory", "cacheClassification", "result", "getLastClassification", "DEFAULT_CONFIG_VALUES", "loadConfig", "configFile", "saveConfig", "config", "merged", "clearSessionState", "unlinkSync", "cleanupOldStates", "readdirSync", "statSync", "files", "f", "b", "file", "DEFAULT_MAX_RETRIES", "DEFAULT_BASE_DELAY_MS", "MAX_DELAY_MS", "ALTERNATIVE_AGENTS", "NON_RETRYABLE_ERRORS", "s", "ALTERNATIVE_SUGGESTING_ERRORS", "calculateBackoffDelay", "attemptNumber", "baseDelayMs", "exponentialDelay", "jitter", "isRetryableError", "error", "pattern", "suggestsAlternative", "getAlternativeAgent", "agent", "triedAgents", "alternatives", "alt", "makeRetryDecision", "maxRetries", "logHook", "alternative", "delayMs", "createAttempt", "taskId", "completeAttempt", "attempt", "outcome", "completedAt", "durationMs", "analyzeAttemptHistory", "attempts", "successRate", "durations", "avgDuration", "b", "errorCounts", "normalized", "commonErrors", "prepareForRetry", "decision", "formatRetryDecision", "message", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "createHash", "MAX_RECORDS", "MIN_SAMPLES_FOR_ADJUSTMENT", "MAX_ADJUSTMENT", "ADJUSTMENT_STEP", "DECAY_FACTOR", "getCalibrationFile", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadCalibrationData", "file", "readFileSync", "logHook", "saveCalibrationData", "data", "writeFileSync", "err", "hashPrompt", "prompt", "createHash", "recordOutcome", "agent", "matchedKeywords", "confidence", "outcome", "durationMs", "feedback", "record", "getSessionId", "updateAdjustments", "updateStats", "isPositive", "isNegative", "adjustmentDelta", "keyword", "existing", "applyDecay", "now", "dayMs", "adj", "age", "a", "records", "successful", "r", "avgConf", "sum", "agentStats", "stat", "b", "getAdjustments", "getAgentSuccessRate", "agentRecords", "getCalibrationStats", "hasMinimalCalibrationData", "existsSync", "statSync", "resolve", "AGENT_DOMAINS", "getAgentDomain", "agentType", "MIN_GRAPH_SIZE", "graphMemoryInject", "input", "logHook", "graphDataFile", "getProjectDir", "outputSilentSuccess", "graphSize", "agentId", "domainKeywords", "memoryLoadMsg", "systemMsg", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "dirname", "MAX_CONCURRENT_BACKGROUND", "MAX_AGENTS_PER_RESPONSE", "WARNING_THRESHOLD", "EXPENSIVE_TYPES", "isInWorktree", "cwd", "getEffectiveLimits", "getStateFile", "getProjectDir", "getSpawnLog", "initState", "stateFile", "dir", "dirname", "mkdirSync", "existsSync", "initialState", "writeFileSync", "countActiveBackground", "spawnLog", "recentLines", "readFileSync", "fiveMinutesAgo", "count", "line", "entry", "countCurrentResponseAgents", "twoSecondsAgo", "incrementBlockedCount", "state", "incrementSessionTotal", "contextGate", "input", "toolInput", "subagentType", "description", "runInBackground", "logHook", "activeCount", "responseCount", "limits", "outputDeny", "outputWarning", "outputSilentSuccess", "existsSync", "readFileSync", "readdirSync", "homedir", "join", "getSessionState", "getProjectDir", "getDecisionsFile", "getIssueDir", "extractPendingTasks", "sessionState", "existsSync", "tasksPending", "readFileSync", "count", "summary", "t", "extractRelevantDecisions", "_taskDescription", "category", "decisionsFile", "d", "findIssueDoc", "issueNum", "issueDir", "match", "readdirSync", "entry", "extractCriticalRules", "rules", "globalPath", "join", "homedir", "globalRules", "safeReadFile", "extracted", "extractRulesFromMarkdown", "projectPath", "projectRules", "r", "filePath", "content", "_source", "lines", "line", "trimmed", "bullet", "truncated", "directive", "subagentContextStager", "input", "toolInput", "subagentType", "taskDescription", "logHook", "stagedContext", "criticalRules", "pendingCount", "taskSummary", "taskLower", "backendDecisions", "frontendDecisions", "issueMatch", "issueDoc", "systemMessage", "lineCount", "outputSilentSuccess", "existsSync", "readFileSync", "mkdirSync", "readdirSync", "join", "dirname", "BUILTIN_TYPES", "getTrackingLog", "join", "getProjectDir", "getPluginJson", "getAgentsDir", "getClaudeAgentsDir", "getSkillsDir", "getValidAgentTypes", "validTypes", "pluginJson", "existsSync", "agents", "readFileSync", "agent", "agentsDirs", "agentsDir", "files", "readdirSync", "file", "extractAgentSkills", "agentType", "skills", "agentFiles", "agentFile", "lines", "inFrontmatter", "inSkills", "line", "match", "skillName", "validateAgentSkills", "missingSkills", "skillsDir", "skill", "skillPath", "extractAgentTools", "tools", "inTools", "getPermissionProfile", "readOnly", "t", "hasBash", "hasWrite", "riskLevel", "logSpawn", "subagentType", "description", "sessionId", "trackingLog", "dir", "dirname", "mkdirSync", "entry", "bufferWrite", "subagentValidator", "input", "toolInput", "logHook", "agentTypeOnly", "missingList", "agentTools", "permissionProfile", "outputWithContext", "outputSilentSuccess", "mkdirSync", "existsSync", "readFileSync", "join", "dirname", "HIGH_COMPLEXITY_SIGNALS", "LOW_COMPLEXITY_SIGNALS", "agentModelCache", "agentComplexityCache", "getAgentModel", "agentType", "pluginRoot", "getPluginRoot", "agentFile", "join", "existsSync", "fmMatch", "readFileSync", "modelMatch", "model", "getAgentSkillComplexity", "skillsMatch", "skills", "s", "complexityOrder", "maxComplexity", "skill", "skillFile", "skillFm", "cMatch", "c", "analyzeComplexity", "description", "skillComplexity", "highMatches", "p", "agentModel", "resolveEffectiveModel", "getModelAdvice", "complexity", "current", "logModelUsage", "advice", "logFile", "getProjectDir", "mkdirSync", "dirname", "bufferWrite", "modelCostAdvisor", "input", "toolInput", "outputSilentSuccess", "currentModel", "logHook", "outputWarning", "existsSync", "readFileSync", "writeFileSync", "statSync", "mkdirSync", "execFileSync", "tmpdir", "join", "CACHE_DIR", "join", "tmpdir", "CACHE_TTL_MS", "GH_TIMEOUT_MS", "extractIssueNumber", "branch", "match", "ensureCacheDir", "mkdirSync", "getCachedIssue", "issueNum", "cachePath", "existsSync", "stats", "statSync", "readFileSync", "fetchAndCacheIssue", "projectDir", "output", "execFileSync", "data", "writeFileSync", "buildContextMessage", "issue", "parts", "labelNames", "l", "issueContextInjector", "_input", "getProjectDir", "getCachedBranch", "logHook", "outputSilentSuccess", "contextMsg", "HOOK_NAME", "MAX_OUTPUT_TOKENS", "CONTEXT_HOOKS", "subagentContextStager", "graphMemoryInject", "modelCostAdvisor", "issueContextInjector", "unifiedSubagentStartDispatcher", "input", "gateResult", "contextGate", "logHook", "HOOK_NAME", "error", "message", "validatorContext", "validatorResult", "subagentValidator", "extractContext", "contextParts", "systemMessages", "totalTokens", "tokens", "estimateTokenCount", "hook", "CONTEXT_HOOKS", "result", "context", "contextTokens", "MAX_OUTPUT_TOKENS", "hasContext", "hasSystemMessage", "outputSilentSuccess", "consolidated", "existsSync", "mkdirSync", "unlinkSync", "basename", "dirname", "DECISION_PATTERNS", "SCOPE_DECISIONS", "getPatternsLog", "getProjectDir", "getAgentTrackingDir", "getProjectId", "projectDir", "basename", "scopedId", "scope", "detectPatternCategory", "text", "textLower", "lineContainsAll", "extractPatterns", "output", "patterns", "pattern", "patternLower", "matches", "line", "match", "cleaned", "agentMemoryStore", "input", "logHook", "toolInput", "agentType", "rawResult", "agentOutput", "success", "outputSilentSuccess", "agentId", "trackingFile", "existsSync", "unlinkSync", "extractedPatterns", "patternsLog", "logDir", "dirname", "mkdirSync", "projectId", "timestamp", "decisionsId", "category", "entry", "bufferWrite", "existsSync", "writeFileSync", "mkdirSync", "readFileSync", "dirname", "SENSITIVE_PATTERNS", "getSpawnLog", "logDir", "getProjectDir", "mkdirSync", "getSpawnQueue", "logSpawn", "message", "logFile", "timestamp", "bufferWrite", "containsSensitiveFiles", "output", "lowerOutput", "pattern", "queueSpawn", "agentType", "targetAgent", "triggerReason", "priority", "sessionId", "spawnId", "spawnQueue", "queueDir", "dirname", "queue", "existsSync", "readFileSync", "request", "writeFileSync", "writeSpawnSuggestion", "handoffDir", "suggestionFile", "suggestion", "checkAutoSpawnConditions", "agentOutput", "error", "autoSpawnQuality", "input", "outputSilentSuccess", "spawnInfo", "existsSync", "writeFileSync", "mkdirSync", "readFileSync", "dirname", "getDecisionsFile", "getProjectDir", "getSessionState", "getLogDir", "ensureDir", "dirPath", "mkdirSync", "readJsonFile", "filePath", "defaultValue", "existsSync", "readFileSync", "writeJsonFile", "data", "dir", "dirname", "writeFileSync", "MAX_COMPLETED_TASKS", "contextPublisher", "input", "agentName", "timestamp", "output", "summary", "hasContent", "agentKey", "decisionsFile", "decisionsDir", "decisions", "decisionEntry", "sessionStateFile", "sessionDir", "sessionState", "taskEntry", "logDir", "dateStr", "logFile", "logContent", "outputSilentSuccess", "existsSync", "writeFileSync", "mkdirSync", "readFileSync", "dirname", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "getRegistryFile", "sessionId", "getSessionId", "getProjectDir", "ensureDir", "dir", "existsSync", "mkdirSync", "loadRegistry", "file", "readFileSync", "saveRegistry", "registry", "writeFileSync", "err", "logHook", "updateTaskStatus", "taskId", "status", "registry", "loadRegistry", "task", "t", "saveRegistry", "logHook", "getTaskByAgent", "agent", "getActivePipeline", "loadRegistry", "p", "isAgentTeamsActive", "PIPELINES", "getDecisionLog", "getProjectDir", "getFeedbackLog", "logDir", "mkdirSync", "logFeedback", "message", "logFile", "timestamp", "bufferWrite", "getDownstreamAgents", "agent", "activePipeline", "getActivePipeline", "pipelineDef", "PIPELINES", "p", "currentStepIdx", "s", "nextAgents", "idx", "getFeedbackCategory", "getInstanceId", "extractFindingsSummary", "output", "summary", "writeDecision", "decisionId", "agentType", "category", "downstreamAgents", "status", "taskId", "decisionLog", "dirname", "log", "existsSync", "readFileSync", "decisionEntry", "writeFileSync", "createHandoffContext", "sessionId", "handoffDir", "agents", "dateStr", "downstream", "handoffFile", "handoff", "feedbackLoop", "input", "isAgentTeamsActive", "outputSilentSuccess", "agentOutput", "error", "randomNum", "getTaskByAgent", "updateTaskStatus", "writeFileSync", "mkdirSync", "VALID_AGENTS", "NEXT_AGENT_MAP", "SUGGESTIONS_MAP", "getNextAgent", "agentName", "getSuggestions", "writeHandoffFile", "nextAgent", "timestamp", "summary", "suggestions", "handoffDir", "getProjectDir", "mkdirSync", "dateStr", "handoffFile", "handoff", "writeFileSync", "writeLogFile", "logDir", "logFile", "logContent", "handoffPreparer", "input", "outputSilentSuccess", "agentOutput", "outputLength", "writeFileSync", "mkdirSync", "SENSITIVE_PATTERNS", "getLogDir", "logDir", "getProjectDir", "mkdirSync", "logAction", "agentName", "action", "details", "date", "logFile", "timestamp", "bufferWrite", "containsSensitiveFiles", "output", "outputLower", "pattern", "multiClaudeVerifier", "input", "projectDir", "agentOutput", "verificationActions", "v", "queueDir", "dateStr", "queueFile", "verificationsQueue", "writeFileSync", "recommendationMsg", "outputSilentSuccess", "writeFileSync", "mkdirSync", "getLogDir", "logDir", "getProjectDir", "mkdirSync", "outputValidator", "input", "agentName", "timestamp", "output", "validationErrors", "validationWarnings", "outputLength", "jsonMatch", "validationStatus", "lastMsgLength", "systemMessage", "dateStr", "logFile", "logContent", "writeFileSync", "existsSync", "writeFileSync", "readFileSync", "join", "METRICS_FILE", "getMetricsFile", "DEFAULT_THRESHOLDS", "extractScores", "text", "scores", "slashPattern", "match", "dimension", "value", "max", "jsonPattern", "key", "loadPolicy", "projectDir", "getProjectDir", "policyPath", "join", "existsSync", "readFileSync", "logHook", "getThreshold", "policy", "thresholds", "dimKey", "hasStructuredOutput", "p", "updateMetrics", "type", "metrics", "writeFileSync", "subagentQualityGate", "input", "agentId", "subagentType", "error", "outputText", "outputWarning", "score", "normalized", "threshold", "label", "outputSilentSuccess", "executionHistory", "addToHistory", "agent", "attempt", "history", "getTriedAgents", "tried", "attempts", "a", "detectOutcome", "input", "error", "exitCode", "output", "rejectionPatterns", "pattern", "partialPatterns", "retryHandler", "agentType", "outputSilentSuccess", "outcome", "logHook", "config", "loadConfig", "dispatchedAgent", "loadState", "currentRetryCount", "createAttempt", "completedAttempt", "completeAttempt", "triedAgents", "decision", "makeRetryDecision", "updateAgentStatus", "task", "getTaskByAgent", "updateTaskStatus", "message", "formatRetryDecision", "outputWithContext", "existsSync", "mkdirSync", "readFileSync", "writeFileSync", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "execSync", "createHash", "os", "IDENTITY_CONFIG_FILE", "SALT", "cachedIdentity", "generateAnonymousId", "input", "createHash", "SALT", "getMachineId", "readUserConfig", "projectDir", "configPath", "IDENTITY_CONFIG_FILE", "existsSync", "content", "readFileSync", "error", "logHook", "getGitIdentity", "result", "execSync", "getEnvIdentity", "resolveUserIdentity", "cachedIdentity", "dir", "getProjectDir", "machineId", "config", "git", "env", "userId", "anonId", "getIdentityContext", "identity", "resolveUserIdentity", "getSessionId", "SESSION_ID_PATTERN", "isValidSessionId", "sessionId", "getSessionDir", "projectDir", "sid", "getSessionId", "pDir", "getProjectDir", "getEventsPath", "ensureSessionDir", "dir", "existsSync", "mkdirSync", "eventCounter", "counterLoaded", "counterDirty", "lastPersistTime", "PERSIST_INTERVAL", "getCounterPath", "loadPersistedCounter", "counterPath", "data", "readFileSync", "logHook", "persistCounter", "now", "writeFileSync", "generateEventId", "trackEvent", "eventType", "name", "options", "event", "generateEventId", "getIdentityContext", "sanitizeForStorage", "truncate", "ensureSessionDir", "eventsPath", "getEventsPath", "bufferWrite", "logHook", "error", "truncate", "str", "maxLen", "sanitizeForStorage", "obj", "sanitized", "sensitiveKeys", "key", "value", "s", "mkdirSync", "statSync", "renameSync", "createHash", "getAnalyticsDir", "joinPath", "getHomeDir", "hashProject", "projectDir", "createHash", "getTeamContext", "team", "rotateIfNeeded", "filePath", "maxBytes", "statSync", "month", "rotated", "renameSync", "isTestEnv", "appendAnalytics", "file", "entry", "dir", "mkdirSync", "bufferWrite", "HOOKS", "contextPublisher", "handoffPreparer", "feedbackLoop", "agentMemoryStore", "trackAgentResult", "input", "agentType", "agentName", "success", "durationMs", "output", "outputLength", "trackEvent", "model", "appendAnalytics", "hashProject", "getTeamContext", "unifiedSubagentStopDispatcher", "errors", "HOOKS", "hook", "result", "error", "message", "logHook", "outputSilentSuccess", "HOOK_NAME", "SYNC_HOOKS", "outputValidator", "autoSpawnQuality", "multiClaudeVerifier", "subagentQualityGate", "retryHandler", "syncSubagentStopDispatcher", "input", "messages", "hook", "result", "logHook", "context", "extractContext", "error", "msg", "outputSilentSuccess", "merged", "hooks", "graphMemoryInject", "contextGate", "subagentContextStager", "subagentValidator", "modelCostAdvisor", "issueContextInjector", "unifiedSubagentStartDispatcher", "agentMemoryStore", "autoSpawnQuality", "contextPublisher", "feedbackLoop", "handoffPreparer", "multiClaudeVerifier", "outputValidator", "subagentQualityGate", "retryHandler", "unifiedSubagentStopDispatcher", "syncSubagentStopDispatcher", "getHook", "name", "listHooks"]
}
