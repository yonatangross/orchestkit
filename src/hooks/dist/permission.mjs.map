{
  "version": 3,
  "sources": ["../src/types.ts", "../src/lib/common.ts", "../src/lib/analytics-buffer.ts", "../src/lib/paths.ts", "../src/lib/session-id-generator.ts", "../src/lib/agent-teams.ts", "../src/lib/guards.ts", "../src/lib/normalize-command.ts", "../src/permission/auto-approve-safe-bash.ts", "../src/permission/auto-approve-project-writes.ts", "../src/permission/learning-tracker.ts", "../src/permission/unified-dispatcher.ts", "../src/entries/permission.ts"],
  "sourcesContent": ["/**\n * TypeScript type definitions for Claude Code hooks\n * CC 2.1.9 compliant with additionalContext support\n */\n\n/**\n * Hook events supported by Claude Code\n */\nexport type HookEvent =\n  | 'PreToolUse'\n  | 'PostToolUse'\n  | 'PostToolUseFailure'\n  | 'PermissionRequest'\n  | 'UserPromptSubmit'\n  | 'SessionStart'\n  | 'SessionEnd'\n  | 'Stop'\n  | 'SubagentStart'\n  | 'SubagentStop'\n  | 'Setup'\n  | 'Notification'\n  | 'PreCompact'\n  | 'TeammateIdle'\n  | 'TaskCompleted';\n\n/**\n * Hook input envelope from Claude Code (sent via stdin as JSON)\n */\nexport interface HookInput {\n  /** The hook event type */\n  hook_event?: HookEvent;\n  /** The tool being invoked */\n  tool_name: string;\n  /** Session ID (CC 2.1.9 guarantees availability) */\n  session_id: string;\n  /** Tool-specific input parameters */\n  tool_input: ToolInput;\n  /** Tool output (PostToolUse only) */\n  tool_output?: unknown;\n  /** Tool error message if any */\n  tool_error?: string;\n  /** Tool exit code */\n  exit_code?: number;\n  /** Whether a stop hook is currently active (prevents re-entry) */\n  stop_hook_active?: boolean;\n  /** Permission mode (CC 2.1.25: dontAsk mode makes quality gates warn-only) */\n  permissionMode?: 'default' | 'acceptEdits' | 'dontAsk';\n  /** User prompt (UserPromptSubmit only) */\n  prompt?: string;\n  /** Project directory */\n  project_dir?: string;\n\n  // SubagentStart/SubagentStop specific fields\n  /** Agent type for subagent hooks */\n  subagent_type?: string;\n  /** Agent type (alternative field name) */\n  agent_type?: string;\n  /** Agent ID */\n  agent_id?: string;\n  /** Agent output (SubagentStop) */\n  agent_output?: string;\n  /** Output (alternative field name) */\n  output?: string;\n  /** Error from subagent */\n  error?: string;\n  /** Duration in milliseconds */\n  duration_ms?: number;\n  /** Tool result \u2014 string from most hooks, object from Skill PostToolUse */\n  tool_result?: string | { is_error?: boolean; content?: string };\n\n  // TeammateIdle specific fields (CC 2.1.33)\n  /** Teammate agent ID */\n  teammate_id?: string;\n  /** Teammate agent type */\n  teammate_type?: string;\n  /** How long the teammate has been idle (ms) */\n  idle_duration_ms?: number;\n\n  // TaskCompleted specific fields (CC 2.1.33)\n  /** Completed task ID */\n  task_id?: string;\n  /** Task subject */\n  task_subject?: string;\n  /** Task result status */\n  task_status?: string;\n  /** Token count consumed by the task (CC 2.1.30) */\n  token_count?: number;\n  /** Number of tool invocations in the task (CC 2.1.30) */\n  tool_uses?: number;\n\n  // Notification specific fields\n  /** Notification message */\n  message?: string;\n  /** Notification type */\n  notification_type?: string;\n\n  // Stop/SubagentStop specific fields (CC 2.1.47)\n  /** The final assistant message text (Stop and SubagentStop, CC 2.1.47+) */\n  last_assistant_message?: string;\n\n  // Workspace/statusline fields (CC 2.1.47)\n  /** Directories added via /add-dir, from statusline workspace section (CC 2.1.47+) */\n  added_dirs?: string[];\n}\n\n/**\n * Tool input types - union of all tool inputs\n */\nexport interface ToolInput {\n  /** Bash command (Bash tool) */\n  command?: string;\n  /** Timeout in ms (Bash tool) */\n  timeout?: number;\n  /** File path (Write/Edit/Read tools) */\n  file_path?: string;\n  /** File content (Write tool) */\n  content?: string;\n  /** Old text to replace (Edit tool) */\n  old_string?: string;\n  /** New text (Edit tool) */\n  new_string?: string;\n  /** Pattern (Glob/Grep tools) */\n  pattern?: string;\n  /** Allow additional properties */\n  [key: string]: unknown;\n}\n\n/**\n * Hook-specific output for CC 2.1.9\n */\nexport interface HookSpecificOutput {\n  /** Hook event name for context */\n  hookEventName?: 'PreToolUse' | 'PostToolUse' | 'PostToolUseFailure' | 'PermissionRequest' | 'UserPromptSubmit';\n  /** Permission decision (PermissionRequest hooks) */\n  permissionDecision?: 'allow' | 'deny';\n  /** Reason for permission decision */\n  permissionDecisionReason?: string;\n  /** Additional context injected before tool execution (CC 2.1.9) */\n  additionalContext?: string;\n  /** Modified tool input (CC 2.1.25: canonical way to modify tool inputs) */\n  updatedInput?: Record<string, unknown>;\n}\n\n/**\n * Hook result - output JSON to stdout\n * CC 2.1.7+ compliant\n */\nexport interface HookResult {\n  /** Whether to continue execution */\n  continue: boolean;\n  /** Suppress hook output from user */\n  suppressOutput?: boolean;\n  /** System message shown to user */\n  systemMessage?: string;\n  /** Reason for stopping (when continue is false) */\n  stopReason?: string;\n  /** Hook-specific output fields */\n  hookSpecificOutput?: HookSpecificOutput;\n}\n\n/**\n * Hook function signature\n */\nexport type HookFn = (input: HookInput) => Promise<HookResult> | HookResult;\n\n/**\n * Hook metadata for auto-discovery and governance\n * Co-export alongside hook functions for single-source-of-truth registration\n */\nexport interface HookMeta {\n  /** Full hook name path (e.g., 'pretool/bash/dangerous-command-blocker') */\n  name: string;\n  /** Human-readable description */\n  description: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher patterns for hooks.json (e.g., 'Bash', 'Write|Edit') */\n  matchers?: string[];\n  /** Run asynchronously (non-blocking) */\n  async?: boolean;\n  /** Only run once per session */\n  once?: boolean;\n  /** Timeout in seconds (async hooks only) */\n  timeout?: number;\n  /** Risk category for prioritization */\n  tier?: 'security-critical' | 'data-loss' | 'quality-gate' | 'standard';\n}\n\n/**\n * Hook overrides configuration for per-project toggle/customization\n * Stored at .claude/hook-overrides.json (gitignored)\n */\nexport interface HookOverrides {\n  /** Hook names to disable entirely */\n  disabled?: string[];\n  /** Per-hook timeout overrides (seconds) */\n  timeouts?: Record<string, number>;\n}\n\n/**\n * Hook registration entry\n */\nexport interface HookRegistration {\n  /** Hook name (e.g., 'permission/auto-approve-readonly') */\n  name: string;\n  /** Hook event type */\n  event: HookEvent;\n  /** Tool matcher (string pattern or regex) */\n  matcher?: string | RegExp;\n  /** Hook implementation function */\n  fn: HookFn;\n}\n\n/**\n * Bash tool input (type guard helper)\n */\nexport interface BashToolInput extends ToolInput {\n  command: string;\n  timeout?: number;\n}\n\n/**\n * Write tool input (type guard helper)\n */\nexport interface WriteToolInput extends ToolInput {\n  file_path: string;\n  content: string;\n}\n\n/**\n * Edit tool input (type guard helper)\n */\nexport interface EditToolInput extends ToolInput {\n  file_path: string;\n  old_string: string;\n  new_string: string;\n}\n\n/**\n * Read tool input (type guard helper)\n */\nexport interface ReadToolInput extends ToolInput {\n  file_path: string;\n  offset?: number;\n  limit?: number;\n}\n\n/**\n * Type guards for tool inputs\n */\nexport function isBashInput(input: ToolInput): input is BashToolInput {\n  return typeof input.command === 'string';\n}\n\nexport function isWriteInput(input: ToolInput): input is WriteToolInput {\n  return typeof input.file_path === 'string' && typeof input.content === 'string';\n}\n\nexport function isEditInput(input: ToolInput): input is EditToolInput {\n  return (\n    typeof input.file_path === 'string' &&\n    typeof input.old_string === 'string' &&\n    typeof input.new_string === 'string'\n  );\n}\n\nexport function isReadInput(input: ToolInput): input is ReadToolInput {\n  return typeof input.file_path === 'string' && input.content === undefined;\n}\n", "/**\n * Common utilities for TypeScript hooks\n * Ported from hooks/_lib/common.sh\n */\n\nimport { existsSync, statSync, renameSync, mkdirSync, readSync } from 'node:fs';\nimport { bufferWrite } from './analytics-buffer.js';\nimport { execSync } from 'node:child_process';\nimport type { HookResult, HookInput } from '../types.js';\nimport {\n  getLogDir as getLogDirFromPaths,\n  getProjectDir as getProjectDirFromPaths,\n  getPluginRoot as getPluginRootFromPaths,\n} from './paths.js';\nimport { getOrGenerateSessionId } from './session-id-generator.js';\n\n// -----------------------------------------------------------------------------\n// Environment and Paths\n// All functions read env vars dynamically to support testing\n// Re-export from paths.ts for cross-platform compatibility\n// -----------------------------------------------------------------------------\n\n/**\n * Get the log directory path (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getLogDir(): string {\n  return getLogDirFromPaths();\n}\n\n/**\n * Get the project directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getProjectDir(): string {\n  return getProjectDirFromPaths();\n}\n\n/**\n * Get the plugin root directory (cross-platform)\n * Delegates to paths.ts for correct path handling on all platforms\n */\nexport function getPluginRoot(): string {\n  return getPluginRootFromPaths();\n}\n\n/**\n * Get the environment file path (CC 2.1.25: CLAUDE_ENV_FILE support)\n * Falls back to .instance_env for backward compatibility\n */\nexport function getEnvFile(): string {\n  if (process.env.CLAUDE_ENV_FILE) {\n    return process.env.CLAUDE_ENV_FILE;\n  }\n  // Fallback to legacy .instance_env\n  const pluginRoot = getPluginRoot();\n  return `${pluginRoot}/.claude/.instance_env`;\n}\n\n/**\n * Get the session ID\n *\n * Resolution order:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime - preferred)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate smart session ID: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n *\n * Example smart ID: \"orchestkit-main-0130-1745-a3f2\"\n *\n * The old fallback format \"fallback-{pid}-{timestamp}\" was confusing and unhelpful.\n * Smart IDs are human-readable, showing project, branch, and time context.\n */\nexport function getSessionId(): string {\n  return getOrGenerateSessionId();\n}\n\n/**\n * Get cached git branch (set at session start or first call)\n * Caches result in process.env to avoid repeated execSync calls\n */\nexport function getCachedBranch(projectDir?: string): string {\n  if (process.env.ORCHESTKIT_BRANCH) {\n    return process.env.ORCHESTKIT_BRANCH;\n  }\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: projectDir || getProjectDir(),\n      encoding: 'utf8',\n      timeout: 5000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n    process.env.ORCHESTKIT_BRANCH = branch;\n    return branch;\n  } catch {\n    return 'unknown';\n  }\n}\n\n/**\n * Get log level (debug|info|warn|error, default: warn)\n */\nexport function getLogLevel(): string {\n  return process.env.ORCHESTKIT_LOG_LEVEL || 'warn';\n}\n\n/**\n * Normalize line endings from CRLF to LF for cross-platform compatibility.\n * Windows uses \\r\\n (CRLF) while Unix uses \\n (LF).\n * This is critical for parsing YAML frontmatter where we match '---' exactly.\n */\nexport function normalizeLineEndings(content: string): string {\n  return content.replace(/\\r\\n/g, '\\n');\n}\n\n/**\n * Check if should log at given level\n */\nexport function shouldLog(level: 'debug' | 'info' | 'warn' | 'error'): boolean {\n  const levels = ['debug', 'info', 'warn', 'error'];\n  return levels.indexOf(level) >= levels.indexOf(getLogLevel());\n}\n\n// -----------------------------------------------------------------------------\n// Output Helpers (CC 2.1.7+ compliant)\n// -----------------------------------------------------------------------------\n\n/**\n * Output silent success - hook completed without errors, no user-visible output\n */\nexport function outputSilentSuccess(): HookResult {\n  return { continue: true, suppressOutput: true };\n}\n\n/**\n * Output silent allow - permission hook approves silently\n */\nexport function outputSilentAllow(): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: { permissionDecision: 'allow' },\n  };\n}\n\n/**\n * Output block - stops the operation with an error\n */\nexport function outputBlock(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with additionalContext - injects context before tool execution (CC 2.1.9)\n * For PostToolUse hooks (hookEventName optional)\n */\nexport function outputWithContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PostToolUse',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with additionalContext for UserPromptSubmit hooks (CC 2.1.9)\n * hookEventName is REQUIRED for UserPromptSubmit\n */\nexport function outputPromptContext(ctx: string): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: ctx,\n    },\n  };\n}\n\n/**\n * Output with user notification + Claude context (CC 2.1.9+)\n * Issue #278: Dual-channel output for three-tier UX\n *\n * @param userMessage - Brief message shown to user via systemMessage (optional)\n * @param claudeContext - Full context for Claude via additionalContext (optional)\n * @returns HookResult with appropriate channels set\n *\n * Usage:\n * - Both set: User sees notification, Claude gets context\n * - Only claudeContext: Silent injection (Claude-only)\n * - Only userMessage: User notification without context\n */\nexport function outputWithNotification(\n  userMessage: string | undefined,\n  claudeContext: string | undefined\n): HookResult {\n  const result: HookResult = {\n    continue: true,\n    suppressOutput: true,\n  };\n\n  if (userMessage) {\n    result.systemMessage = userMessage;\n  }\n\n  if (claudeContext) {\n    result.hookSpecificOutput = {\n      hookEventName: 'UserPromptSubmit',\n      additionalContext: claudeContext,\n    };\n  }\n\n  return result;\n}\n\n/**\n * Output allow with additionalContext - permission hook approves with context (CC 2.1.9)\n */\nexport function outputAllowWithContext(ctx: string, systemMessage?: string): HookResult {\n  const result: HookResult = {\n    continue: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      additionalContext: ctx,\n      permissionDecision: 'allow',\n    },\n  };\n\n  if (systemMessage) {\n    result.systemMessage = systemMessage;\n  } else {\n    result.suppressOutput = true;\n  }\n\n  return result;\n}\n\n/**\n * Output error message - only use when there's an actual problem\n */\nexport function outputError(message: string): HookResult {\n  return { continue: true, systemMessage: message };\n}\n\n/**\n * Output warning message via JSON stdout \u2014 visible to both user and Claude (CC 2.1.7+).\n * Use this when Claude needs to see and act on the warning (e.g., cost advice, quality gates).\n * For user-only warnings where Claude should NOT see the message, use outputStderrWarning.\n */\nexport function outputWarning(message: string): HookResult {\n  return { continue: true, systemMessage: `\\u26a0 ${message}` };\n}\n\n/**\n * Output warning via stderr + exit(2) \u2014 visible to user only, Claude does NOT see it (CC 2.1.39).\n * Use this for informational warnings that should not influence Claude's behavior\n * (e.g., deprecation notices, non-actionable advisories).\n *\n * IMPORTANT: This function calls process.exit(2) and never returns.\n * Do NOT use inside unified dispatchers \u2014 it will crash the dispatcher process.\n * Only use in standalone hook entry points.\n */\nexport function outputStderrWarning(message: string): never {\n  process.stderr.write(`\\u26a0 ${message}\\n`);\n  process.exit(2);\n}\n\n/**\n * Output deny with feedback logging (CC 2.1.7)\n */\nexport function outputDeny(reason: string): HookResult {\n  return {\n    continue: false,\n    stopReason: reason,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      permissionDecision: 'deny',\n      permissionDecisionReason: reason,\n    },\n  };\n}\n\n/**\n * Output with updatedInput - modifies tool input before execution (CC 2.1.25)\n * Canonical way to modify tool inputs from PreToolUse hooks\n */\nexport function outputWithUpdatedInput(updatedInput: Record<string, unknown>): HookResult {\n  return {\n    continue: true,\n    suppressOutput: true,\n    hookSpecificOutput: {\n      hookEventName: 'PreToolUse',\n      updatedInput,\n    },\n  };\n}\n\n// -----------------------------------------------------------------------------\n// Logging (with log level guard for performance)\n// -----------------------------------------------------------------------------\n\nconst LOG_ROTATION_MAX_SIZE = 200 * 1024; // 200KB\nconst PERMISSION_LOG_MAX_SIZE = 100 * 1024; // 100KB\n\n/**\n * Rotate log file if it exceeds size limit\n */\nfunction rotateLogFile(logFile: string, maxSize: number): void {\n  if (!existsSync(logFile)) return;\n\n  try {\n    const stats = statSync(logFile);\n    if (stats.size > maxSize) {\n      const rotated = `${logFile}.old.${Date.now()}`;\n      renameSync(logFile, rotated);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Ensure directory exists\n */\nfunction ensureDir(dir: string): void {\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\n/**\n * Log to hook log file with automatic rotation\n * Respects ORCHESTKIT_LOG_LEVEL (default: warn, skips debug logs in production)\n */\nexport function logHook(hookName: string, message: string, level: 'debug' | 'info' | 'warn' | 'error' = 'debug'): void {\n  // Skip if below log level threshold (big perf win - avoids I/O)\n  if (!shouldLog(level)) {\n    return;\n  }\n\n  const logDir = getLogDir();\n  const logFile = `${logDir}/hooks.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, LOG_ROTATION_MAX_SIZE);\n\n    const timestamp = new Date().toISOString().replace('T', ' ').slice(0, 19);\n    bufferWrite(logFile, `[${timestamp}] [${level.toUpperCase()}] [${hookName}] ${message}\\n`);\n  } catch {\n    // Ignore logging errors - don't block hook execution\n  }\n}\n\n/**\n * Log permission decision for audit trail (CC 2.1.7 feature)\n * Always logs (security audit trail) - not affected by log level\n */\nexport function logPermissionFeedback(\n  decision: 'allow' | 'deny' | 'warn',\n  reason: string,\n  input?: HookInput | Record<string, unknown>\n): void {\n  const logDir = getLogDir();\n  const logFile = `${logDir}/permission-feedback.log`;\n\n  try {\n    ensureDir(logDir);\n    rotateLogFile(logFile, PERMISSION_LOG_MAX_SIZE);\n\n    const timestamp = new Date().toISOString();\n    const toolName = (input as HookInput)?.tool_name || process.env.HOOK_TOOL_NAME || 'unknown';\n    const sessionId = (input as HookInput)?.session_id || getSessionId();\n\n    bufferWrite(\n      logFile,\n      `${timestamp} | ${decision} | ${reason} | tool=${toolName} | session=${sessionId}\\n`\n    );\n  } catch {\n    // Ignore logging errors\n  }\n}\n\n// -----------------------------------------------------------------------------\n// Context Extraction (shared by all sync dispatchers)\n// -----------------------------------------------------------------------------\n\n/**\n * Extract additionalContext from a hook result.\n * Handles both the correct hookSpecificOutput.additionalContext format\n * and the legacy bare systemMessage format.\n *\n * Issue #682: Deduplicated from 5 dispatchers into shared utility.\n */\nexport function extractContext(result: HookResult): string | null {\n  // Standard format: hookSpecificOutput.additionalContext\n  if (result.hookSpecificOutput?.additionalContext) {\n    return result.hookSpecificOutput.additionalContext as string;\n  }\n\n  // Legacy format: bare systemMessage (antipattern-detector bug)\n  if (result.systemMessage && typeof result.systemMessage === 'string') {\n    return result.systemMessage;\n  }\n\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Token Estimation\n// -----------------------------------------------------------------------------\n\n/**\n * Content-aware token estimation (~80% accuracy without external tokenizer).\n * Code-heavy content averages ~2.8 chars/token; prose ~3.5 chars/token.\n */\nexport function estimateTokenCount(content: string): number {\n  if (!content) return 0;\n  const codeIndicators = (content.match(/[{};()=><]/g) || []).length;\n  const codeRatio = codeIndicators / content.length;\n  const charsPerToken = codeRatio > 0.03 ? 2.8 : 3.5;\n  return Math.ceil(content.length / charsPerToken);\n}\n\n// -----------------------------------------------------------------------------\n// Budgeted Output Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Output prompt context with token budget awareness.\n * Checks if the category is over budget before injecting.\n * Falls back to silent success when budget exhausted.\n *\n * Accepts budget checker and tracker as parameters to avoid circular deps.\n * If not provided, falls back to unchecked injection.\n */\nexport function outputPromptContextBudgeted(\n  ctx: string,\n  hookName: string,\n  category: string,\n  budgetChecker?: { isOverBudget: (cat: string) => boolean },\n  tokenTracker?: { trackTokenUsage: (hook: string, cat: string, tokens: number) => void },\n): HookResult {\n  const tokens = estimateTokenCount(ctx);\n\n  if (budgetChecker?.isOverBudget(category)) {\n    logHook(hookName, `Budget exhausted for ${category}, suppressing ${tokens}t`);\n    return outputSilentSuccess();\n  }\n\n  if (tokenTracker) {\n    tokenTracker.trackTokenUsage(hookName, category, tokens);\n  }\n\n  return outputPromptContext(ctx);\n}\n\n// -----------------------------------------------------------------------------\n// Input Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Read hook input from stdin synchronously\n * Returns parsed JSON or empty object on failure\n */\nexport function readHookInput(): HookInput {\n  try {\n    // Read from stdin synchronously\n    const chunks: Buffer[] = [];\n    const BUFSIZE = 256;\n    const buf = Buffer.allocUnsafe(BUFSIZE);\n\n    let bytesRead: number;\n    const fd = 0; // stdin\n\n    while (true) {\n      try {\n        bytesRead = readSync(fd, buf, 0, BUFSIZE, null);\n        if (bytesRead === 0) break;\n        chunks.push(Buffer.from(buf.subarray(0, bytesRead)));\n      } catch {\n        break;\n      }\n    }\n\n    const input = Buffer.concat(chunks).toString('utf8').trim();\n    if (!input) {\n      return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n    }\n\n    return JSON.parse(input);\n  } catch {\n    return { tool_name: '', session_id: getSessionId(), tool_input: {} };\n  }\n}\n\n/**\n * Get field from hook input using optional chaining\n */\nexport function getField<T>(input: HookInput, path: string): T | undefined {\n  const parts = path.replace(/^\\./, '').split('.');\n  let value: unknown = input;\n\n  for (const part of parts) {\n    if (value === null || value === undefined) return undefined;\n    value = (value as Record<string, unknown>)[part];\n  }\n\n  return value as T;\n}\n\n// -----------------------------------------------------------------------------\n// ReDoS-Safe String Matching\n// -----------------------------------------------------------------------------\n\n/**\n * Check if any single line contains all specified substrings (ReDoS-safe O(n)).\n * Use instead of polynomial regexes like /A.*B.*C/.test(content).\n */\nexport function lineContainsAll(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => terms.every(t => line.includes(t)));\n}\n\n/**\n * Check if any single line contains all specified substrings (case-insensitive, ReDoS-safe O(n)).\n */\nexport function lineContainsAllCI(content: string, ...terms: string[]): boolean {\n  return content.split('\\n').some(line => {\n    const lower = line.toLowerCase();\n    return terms.every(t => lower.includes(t.toLowerCase()));\n  });\n}\n\n// -----------------------------------------------------------------------------\n// String Utilities\n// -----------------------------------------------------------------------------\n\n/**\n * Normalize command: remove line continuations and collapse whitespace\n * Prevents bypassing detection with backslash-newline tricks (CC 2.1.6 fix)\n */\nexport function normalizeCommand(command: string): string {\n  return command\n    .replace(/\\\\\\s*[\\r\\n]+/g, ' ') // Remove line continuations\n    .replace(/\\n/g, ' ') // Replace newlines with spaces\n    .replace(/\\s+/g, ' ') // Collapse whitespace\n    .trim();\n}\n\n/**\n * Escape string for use in regex\n */\nexport function escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Analytics Write Buffer \u2014 Batches appendFileSync calls and flushes on exit\n *\n * Reduces per-hook I/O overhead by buffering analytics/metrics/log writes\n * and flushing them in a single batch per file path. Registered process\n * handlers ensure data is written before the process terminates.\n *\n * Issue #688: Buffer analytics writes and flush on process exit\n */\n\nimport { appendFileSync, mkdirSync } from 'node:fs';\nimport { dirname } from 'node:path';\n\ninterface BufferEntry {\n  filePath: string;\n  content: string;\n}\n\nconst buffer: BufferEntry[] = [];\nlet flushing = false;\nlet handlersRegistered = false;\n\n/**\n * Queue an analytics/log write for batched flushing.\n * Call this instead of appendFileSync for non-essential writes.\n */\nexport function bufferWrite(filePath: string, content: string): void {\n  buffer.push({ filePath, content });\n  ensureHandlers();\n}\n\n/**\n * Flush all buffered writes to disk immediately.\n * Groups entries by file path to minimize syscalls.\n */\nexport function flush(): void {\n  if (flushing || buffer.length === 0) return;\n  flushing = true;\n\n  // Group by filePath to write each file once\n  const grouped = new Map<string, string[]>();\n  for (const entry of buffer) {\n    const arr = grouped.get(entry.filePath);\n    if (arr) {\n      arr.push(entry.content);\n    } else {\n      grouped.set(entry.filePath, [entry.content]);\n    }\n  }\n\n  for (const [path, contents] of grouped) {\n    try {\n      mkdirSync(dirname(path), { recursive: true });\n      appendFileSync(path, contents.join(''));\n    } catch {\n      // Ignore flush errors \u2014 never block process exit\n    }\n  }\n\n  buffer.length = 0;\n  flushing = false;\n}\n\n/** Number of entries currently buffered (for testing) */\nexport function pendingCount(): number {\n  return buffer.length;\n}\n\n/** Clear buffer without writing (for testing) */\nexport function _resetForTesting(): void {\n  buffer.length = 0;\n  flushing = false;\n}\n\nfunction ensureHandlers(): void {\n  if (handlersRegistered) return;\n  handlersRegistered = true;\n\n  process.on('exit', flush);\n  process.on('SIGTERM', () => { flush(); process.exit(0); });\n  process.on('SIGINT', () => { flush(); process.exit(0); });\n}\n", "/**\n * Cross-platform path utilities for TypeScript hooks\n *\n * Provides consistent path handling across Windows, macOS, and Linux.\n * All path construction uses path.join() for correct separators.\n * All temp directories use os.tmpdir() for platform awareness.\n */\n\nimport os from 'node:os';\nimport path from 'node:path';\n\n/**\n * Get the user's home directory (cross-platform)\n * Prefers explicit env vars, falls back to os.homedir()\n */\nexport function getHomeDir(): string {\n  return process.env.HOME || process.env.USERPROFILE || os.homedir();\n}\n\n/**\n * Get the system temp directory (cross-platform)\n * Returns /tmp on Unix, C:\\Users\\X\\AppData\\Local\\Temp on Windows\n */\nexport function getTempDir(): string {\n  return os.tmpdir();\n}\n\n/**\n * Get the project directory from environment\n */\nexport function getProjectDir(): string {\n  return process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the plugin root directory from environment\n */\nexport function getPluginRoot(): string {\n  return process.env.CLAUDE_PLUGIN_ROOT || process.env.CLAUDE_PROJECT_DIR || '.';\n}\n\n/**\n * Get the log directory path (cross-platform)\n * Uses path.join() for correct separators on all platforms\n */\nexport function getLogDir(): string {\n  if (process.env.CLAUDE_PLUGIN_ROOT) {\n    return path.join(getHomeDir(), '.claude', 'logs', 'ork');\n  }\n  return path.join(getProjectDir(), '.claude', 'logs');\n}\n\n/**\n * Get the memory directory path (cross-platform)\n */\nexport function getMemoryDir(): string {\n  return path.join(getProjectDir(), '.claude', 'memory');\n}\n\n/**\n * Get the coordination directory path (cross-platform)\n */\nexport function getCoordinationDir(): string {\n  return path.join(getProjectDir(), '.claude', 'coordination');\n}\n\n/**\n * Get the session metrics file path (cross-platform)\n * Uses CLAUDE_METRICS_FILE env var if set (for test isolation), otherwise temp dir.\n */\nexport function getMetricsFile(): string {\n  return process.env.CLAUDE_METRICS_FILE || path.join(getTempDir(), 'claude-session-metrics.json');\n}\n\n/**\n * Get the session error metrics file path (cross-platform)\n */\nexport function getSessionErrorsFile(): string {\n  return process.env.CLAUDE_SESSION_ERRORS_FILE || path.join(getTempDir(), 'claude-session-errors.json');\n}\n\n/**\n * Get the error suggestions dedup file path for a session (cross-platform)\n */\nexport function getErrorSuggestionsDedupFile(sessionId: string): string {\n  return path.join(getTempDir(), `claude-error-suggestions-${sessionId}.json`);\n}\n\n/**\n * Get the MCP defer state file path for a session (cross-platform)\n */\nexport function getMcpDeferStateFile(sessionId: string): string {\n  return path.join(getTempDir(), `claude-mcp-defer-state-${sessionId}.json`);\n}\n\n/**\n * Get the session temp directory for a given session ID (cross-platform)\n */\nexport function getSessionTempDir(sessionId: string): string {\n  return path.join(getTempDir(), `claude-session-${sessionId}`);\n}\n\n/**\n * Get the active todos file path (cross-platform)\n */\nexport function getActiveTodosFile(): string {\n  return path.join(getTempDir(), 'claude-active-todos.json');\n}\n\n/**\n * Get the context tracking state file path for a session (cross-platform)\n */\nexport function getContextTrackingFile(sessionId: string): string {\n  return path.join(getTempDir(), `claude-context-tracking-${sessionId}.json`);\n}\n\n/**\n * Get the read count temp file path (cross-platform)\n */\nexport function getReadCountFile(): string {\n  return path.join(getTempDir(), 'claude-read-count');\n}\n\n/**\n * Normalize a path for consistent comparison\n * Converts backslashes to forward slashes and removes trailing slashes\n */\nexport function normalizePath(p: string): string {\n  return path.normalize(p).replace(/\\\\/g, '/').replace(/\\/$/, '');\n}\n\n/**\n * Check if a path is absolute\n */\nexport function isAbsolutePath(p: string): boolean {\n  return path.isAbsolute(p);\n}\n\n/**\n * Join path segments (cross-platform)\n * Re-export for convenience\n */\nexport const joinPath = path.join;\n\n/**\n * Get path separator for current platform\n */\nexport const pathSeparator = path.sep;\n", "/**\n * Smart Session ID Generator\n * Generates human-readable session IDs when CLAUDE_SESSION_ID is not available.\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * Benefits:\n * - Human-readable at a glance\n * - Contains project context\n * - Contains branch info\n * - Chronologically sortable (date-time)\n * - Short unique suffix prevents collisions\n * - Valid file path characters only\n */\n\nimport { execSync } from 'node:child_process';\nimport { createHash } from 'node:crypto';\nimport { existsSync, readFileSync, writeFileSync, mkdirSync } from 'node:fs';\nimport { join, basename } from 'node:path';\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\n/** Maximum length for project name component */\nconst MAX_PROJECT_LENGTH = 20;\n\n/** Maximum length for branch name component */\nconst MAX_BRANCH_LENGTH = 15;\n\n/** Characters allowed in session ID (safe for file paths) */\nconst SAFE_CHARS = /[^a-z0-9-]/g;\n\n// =============================================================================\n// SESSION ID GENERATION\n// =============================================================================\n\n/**\n * Get project name from directory path\n * Sanitizes to lowercase alphanumeric with dashes\n */\nexport function getProjectName(projectDir?: string): string {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const name = basename(dir);\n  return sanitizeName(name, MAX_PROJECT_LENGTH);\n}\n\n/**\n * Get git branch name (cached for performance)\n * Returns 'nobranch' if git is not available or not in a repo\n */\nexport function getGitBranchForSession(projectDir?: string): string {\n  // Check cache first\n  if (process.env.ORCHESTKIT_SESSION_BRANCH) {\n    return process.env.ORCHESTKIT_SESSION_BRANCH;\n  }\n\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n\n  try {\n    const branch = execSync('git branch --show-current', {\n      cwd: dir,\n      encoding: 'utf8',\n      timeout: 2000,\n      stdio: ['pipe', 'pipe', 'pipe'],\n    }).trim();\n\n    const sanitized = sanitizeName(branch || 'detached', MAX_BRANCH_LENGTH);\n    process.env.ORCHESTKIT_SESSION_BRANCH = sanitized;\n    return sanitized;\n  } catch {\n    return 'nobranch';\n  }\n}\n\n/**\n * Format current date as MMDD\n */\nexport function formatDateComponent(date?: Date): string {\n  const d = date || new Date();\n  const month = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  return `${month}${day}`;\n}\n\n/**\n * Format current time as HHMM (24-hour)\n */\nexport function formatTimeComponent(date?: Date): string {\n  const d = date || new Date();\n  const hours = String(d.getHours()).padStart(2, '0');\n  const minutes = String(d.getMinutes()).padStart(2, '0');\n  return `${hours}${minutes}`;\n}\n\n/**\n * Generate short hash for uniqueness (4 hex chars)\n * Uses PID + timestamp + random for entropy\n */\nexport function generateShortHash(): string {\n  const entropy = `${process.pid}-${Date.now()}-${Math.random()}`;\n  return createHash('sha256')\n    .update(entropy)\n    .digest('hex')\n    .slice(0, 4);\n}\n\n/**\n * Sanitize a name for use in session ID\n * - Lowercase\n * - Replace non-alphanumeric with dashes\n * - Collapse multiple dashes\n * - Trim dashes from ends\n * - Truncate to max length\n */\nexport function sanitizeName(name: string, maxLength: number): string {\n  return name\n    .toLowerCase()\n    .replace(SAFE_CHARS, '-')\n    .replace(/-+/g, '-')\n    .replace(/^-|-$/g, '')\n    .slice(0, maxLength);\n}\n\n/**\n * Generate a smart session ID\n *\n * Format: {project}-{branch}-{MMDD}-{HHMM}-{hash4}\n * Example: \"orchestkit-main-0130-1745-a3f2\"\n *\n * @param projectDir - Optional project directory (defaults to env or cwd)\n * @param date - Optional date for testing (defaults to now)\n */\nexport function generateSmartSessionId(projectDir?: string, date?: Date): string {\n  const project = getProjectName(projectDir);\n  const branch = getGitBranchForSession(projectDir);\n  const dateStr = formatDateComponent(date);\n  const timeStr = formatTimeComponent(date);\n  const hash = generateShortHash();\n\n  return `${project}-${branch}-${dateStr}-${timeStr}-${hash}`;\n}\n\n// =============================================================================\n// SESSION ID CACHING\n// =============================================================================\n\n/**\n * Get cached session ID from .instance directory\n * Returns undefined if not cached\n */\nexport function getCachedSessionId(projectDir?: string): string | undefined {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const cachePath = join(dir, '.instance', 'session-id.json');\n\n  if (!existsSync(cachePath)) {\n    return undefined;\n  }\n\n  try {\n    const data = JSON.parse(readFileSync(cachePath, 'utf8'));\n    // Validate the cached ID hasn't expired (24 hours)\n    if (data.session_id && data.created_at) {\n      const age = Date.now() - new Date(data.created_at).getTime();\n      const maxAge = 24 * 60 * 60 * 1000; // 24 hours\n      if (age < maxAge) {\n        return data.session_id;\n      }\n    }\n  } catch {\n    // Ignore read/parse errors\n  }\n\n  return undefined;\n}\n\n/**\n * Cache session ID to .instance directory\n */\nexport function cacheSessionId(sessionId: string, projectDir?: string): void {\n  const dir = projectDir || process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const instanceDir = join(dir, '.instance');\n  const cachePath = join(instanceDir, 'session-id.json');\n\n  try {\n    if (!existsSync(instanceDir)) {\n      mkdirSync(instanceDir, { recursive: true });\n    }\n\n    writeFileSync(cachePath, JSON.stringify({\n      session_id: sessionId,\n      created_at: new Date().toISOString(),\n    }, null, 2));\n  } catch {\n    // Ignore write errors - caching is optional\n  }\n}\n\n/**\n * Get or generate session ID with caching\n *\n * Priority:\n * 1. CLAUDE_SESSION_ID env var (from CC runtime)\n * 2. Cached session ID (from .instance/session-id.json)\n * 3. Generate new smart session ID (and cache it)\n */\nexport function getOrGenerateSessionId(projectDir?: string): string {\n  // 1. Try CLAUDE_SESSION_ID first (preferred)\n  if (process.env.CLAUDE_SESSION_ID) {\n    return process.env.CLAUDE_SESSION_ID;\n  }\n\n  // 2. Try cached session ID\n  const cached = getCachedSessionId(projectDir);\n  if (cached) {\n    return cached;\n  }\n\n  // 3. Generate new smart session ID\n  const newId = generateSmartSessionId(projectDir);\n  cacheSessionId(newId, projectDir);\n  return newId;\n}\n", "/**\n * Agent Teams Detection & Configuration Utility\n * Issue #362: Deprecate coordination hooks redundant with CC Agent Teams\n *\n * CC Agent Teams (CC 2.1.33+) provides native multi-instance coordination:\n * - Teammate lifecycle management\n * - 5-minute runtime heartbeat\n * - Idle notifications\n * - Cleanup on session end\n *\n * When Agent Teams is active, OrchestKit's custom coordination hooks\n * should yield to CC's native implementation to avoid duplication.\n */\n\nimport { existsSync, readFileSync, readdirSync, statSync, rmSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Check if CC Agent Teams is active.\n *\n * Detection signals:\n * - CLAUDE_CODE_TEAM_NAME: Set when running as part of an Agent Teams team\n * - CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS: Feature flag for Agent Teams\n */\nexport function isAgentTeamsActive(): boolean {\n  return !!(\n    process.env.CLAUDE_CODE_TEAM_NAME ||\n    process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS === '1'\n  );\n}\n\n/** Check if current session is a teammate in a team */\nexport function isTeammate(): boolean {\n  return !!process.env.CLAUDE_CODE_TEAM_NAME;\n}\n\n/** Get current team name */\nexport function getTeamName(): string | null {\n  return process.env.CLAUDE_CODE_TEAM_NAME || null;\n}\n\nexport interface TeamMember {\n  name: string;\n  agentType: string;\n}\n\n/**\n * Read team config to get member list.\n * Reads from ~/.claude/teams/{team-name}/config.json\n */\nexport function getTeamMembers(): TeamMember[] {\n  const teamName = getTeamName();\n  if (!teamName) return [];\n\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n\n  const configPath = join(homeDir, '.claude', 'teams', teamName, 'config.json');\n  if (!existsSync(configPath)) return [];\n\n  try {\n    const config = JSON.parse(readFileSync(configPath, 'utf-8'));\n    const members = config.members;\n    if (!Array.isArray(members)) return [];\n\n    return members.map((m: { name?: string; agentType?: string }) => ({\n      name: m.name || 'unknown',\n      agentType: m.agentType || 'unknown',\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/** Count current team members */\nexport function getTeamSize(): number {\n  return getTeamMembers().length;\n}\n\n/** List all team directories */\nexport function listAllTeams(): string[] {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return [];\n  const teamsDir = join(homeDir, '.claude', 'teams');\n  if (!existsSync(teamsDir)) return [];\n  try {\n    return readdirSync(teamsDir).filter(name => {\n      try { return statSync(join(teamsDir, name)).isDirectory(); } catch { return false; }\n    });\n  } catch { return []; }\n}\n\n/** Check if team is stale (no config, or dir older than maxAgeHours) */\nexport function isStaleTeam(teamName: string, maxAgeHours: number = 4): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  const teamPath = join(homeDir, '.claude', 'teams', teamName);\n  if (!existsSync(teamPath)) return false;\n  const configPath = join(teamPath, 'config.json');\n  if (!existsSync(configPath)) return true;  // no config = orphaned\n  try {\n    const ageMs = Date.now() - statSync(teamPath).mtimeMs;\n    return ageMs > maxAgeHours * 3600_000;\n  } catch { return true; }\n}\n\n/** Remove team + task directories */\nexport function cleanupTeam(teamName: string): boolean {\n  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n  if (!homeDir) return false;\n  let ok = true;\n  for (const sub of ['teams', 'tasks']) {\n    const dir = join(homeDir, '.claude', sub, teamName);\n    if (existsSync(dir)) {\n      try { rmSync(dir, { recursive: true, force: true }); } catch { ok = false; }\n    }\n  }\n  return ok;\n}\n", "/**\n * Self-guard helpers for TypeScript hooks\n * Ported from hooks/_lib/common.sh guard functions\n *\n * Guards are predicates that determine if a hook should run.\n * They return `true` to run the hook, `false` to skip it.\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess } from './common.js';\nimport { isAgentTeamsActive } from './agent-teams.js';\n\n/**\n * Simple glob matcher using indexOf with position tracking.\n * Splits glob on `*`, checks each literal part appears in order.\n * `?` matches any single character via single-char skip.\n * Avoids polynomial regex from chained `.*` patterns.\n */\nfunction globMatch(glob: string, str: string): boolean {\n  // Split on * to get literal segments\n  const parts = glob.split('*');\n  let pos = 0;\n\n  for (const part of parts) {\n    if (part === '') continue;\n    // Handle ? by replacing with single-char search\n    const searchPart = part;\n    const qIdx = searchPart.indexOf('?');\n    if (qIdx >= 0) {\n      // For segments with ?, match char-by-char\n      let matched = false;\n      for (let i = pos; i <= str.length - searchPart.length; i++) {\n        let ok = true;\n        for (let j = 0; j < searchPart.length; j++) {\n          if (searchPart[j] !== '?' && searchPart[j] !== str[i + j]) {\n            ok = false;\n            break;\n          }\n        }\n        if (ok) {\n          pos = i + searchPart.length;\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) return false;\n    } else {\n      const idx = str.indexOf(searchPart, pos);\n      if (idx === -1) return false;\n      pos = idx + searchPart.length;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Guard result type - either continue (null) or skip with result\n */\nexport type GuardResult = HookResult | null;\n\n/**\n * Create a guard that returns silent success if predicate fails\n */\nexport function createGuard(\n  predicate: (input: HookInput) => boolean\n): (input: HookInput) => GuardResult {\n  return (input: HookInput) => (predicate(input) ? null : outputSilentSuccess());\n}\n\n// -----------------------------------------------------------------------------\n// File Extension Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for specific file extensions\n */\nexport function guardFileExtension(\n  input: HookInput,\n  ...extensions: string[]\n): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  const ext = filePath.split('.').pop()?.toLowerCase() || '';\n  const normalizedExtensions = extensions.map((e) => e.toLowerCase().replace(/^\\./, ''));\n\n  if (normalizedExtensions.includes(ext)) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Only run for code files\n */\nexport function guardCodeFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'py', 'ts', 'tsx', 'js', 'jsx', 'go', 'rs', 'java');\n}\n\n/**\n * Guard: Only run for Python files\n */\nexport function guardPythonFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'py');\n}\n\n/**\n * Guard: Only run for TypeScript/JavaScript files\n */\nexport function guardTypescriptFiles(input: HookInput): GuardResult {\n  return guardFileExtension(input, 'ts', 'tsx', 'js', 'jsx');\n}\n\n// -----------------------------------------------------------------------------\n// Path Pattern Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for test files\n */\nexport function guardTestFiles(input: HookInput): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  const testPatterns = [/test/i, /spec/i, /__tests__/i];\n  if (testPatterns.some((p) => p.test(filePath))) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Skip internal/generated files\n */\nexport function guardSkipInternal(input: HookInput): GuardResult {\n  const filePath = input.tool_input.file_path || '';\n  if (!filePath) return null; // No file path, continue\n\n  // Skip these directories/patterns\n  const skipPatterns = [\n    /\\/\\.claude\\//,\n    /\\/node_modules\\//,\n    /\\/\\.git\\//,\n    /\\/dist\\//,\n    /\\/build\\//,\n    /\\/__pycache__\\//,\n    /\\/\\.venv\\//,\n    /\\/venv\\//,\n    /\\.lock$/,\n  ];\n\n  if (skipPatterns.some((p) => p.test(filePath))) {\n    return outputSilentSuccess();\n  }\n\n  return null; // Continue with hook\n}\n\n/**\n * Guard: Only run for files matching path patterns\n */\nexport function guardPathPattern(input: HookInput, ...patterns: (string | RegExp)[]): GuardResult {\n  const filePath = input.tool_input.file_path;\n  if (!filePath) return outputSilentSuccess();\n\n  for (const pattern of patterns) {\n    if (typeof pattern === 'string') {\n      // Simple glob-like matching using indexOf with position tracking\n      // Avoids polynomial regex from .* chains\n      if (globMatch(pattern, filePath)) return null;\n    } else {\n      if (pattern.test(filePath)) return null;\n    }\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Tool Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for specific tool names\n */\nexport function guardTool(input: HookInput, ...tools: string[]): GuardResult {\n  const toolName = input.tool_name;\n  if (!toolName) return outputSilentSuccess();\n\n  if (tools.includes(toolName)) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n/**\n * Guard: Only run for Write or Edit tools\n */\nexport function guardWriteEdit(input: HookInput): GuardResult {\n  return guardTool(input, 'Write', 'Edit');\n}\n\n/**\n * Guard: Only run for Bash tool\n */\nexport function guardBash(input: HookInput): GuardResult {\n  return guardTool(input, 'Bash');\n}\n\n// -----------------------------------------------------------------------------\n// Command Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run for non-trivial bash commands\n */\nexport function guardNontrivialBash(input: HookInput): GuardResult {\n  const command = input.tool_input.command || '';\n\n  // Skip trivial commands\n  const trivialPatterns = [\n    /^echo\\s/,\n    /^ls(\\s|$)/,\n    /^pwd$/,\n    /^cat\\s/,\n    /^head\\s/,\n    /^tail\\s/,\n    /^wc\\s/,\n    /^date$/,\n    /^whoami$/,\n  ];\n\n  if (trivialPatterns.some((p) => p.test(command))) {\n    return outputSilentSuccess();\n  }\n\n  return null; // Continue with hook\n}\n\n/**\n * Guard: Only run for git commands\n */\nexport function guardGitCommand(input: HookInput): GuardResult {\n  const command = input.tool_input.command || '';\n\n  if (command.startsWith('git')) {\n    return null; // Continue with hook\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Environment Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Guard: Only run if multi-instance coordination is enabled.\n * Issue #362: Yields when Agent Teams is active \u2014 Teams provides native\n * multi-instance coordination, making custom .claude/coordination redundant.\n */\nexport function guardMultiInstance(input: HookInput): GuardResult {\n  if (isAgentTeamsActive()) {\n    return outputSilentSuccess(); // Teams handles coordination natively\n  }\n\n  const projectDir = input.project_dir || process.env.CLAUDE_PROJECT_DIR || '.';\n  const dbPath = `${projectDir}/.claude/coordination/.claude.db`;\n\n  try {\n    const { existsSync } = require('node:fs');\n    if (existsSync(dbPath)) {\n      return null; // Continue with hook\n    }\n  } catch {\n    // Ignore errors\n  }\n\n  return outputSilentSuccess();\n}\n\n// -----------------------------------------------------------------------------\n// Composite Guards\n// -----------------------------------------------------------------------------\n\n/**\n * Run multiple guards in sequence, return first skip result or null to continue\n */\nexport function runGuards(input: HookInput, ...guards: ((input: HookInput) => GuardResult)[]): GuardResult {\n  for (const guard of guards) {\n    const result = guard(input);\n    if (result !== null) {\n      return result; // Skip with this result\n    }\n  }\n  return null; // All guards passed, continue\n}\n\n// -----------------------------------------------------------------------------\n// Permission Mode Helpers\n// -----------------------------------------------------------------------------\n\n/**\n * Check if Claude Code is running in dontAsk mode (CC 2.1.25)\n * In dontAsk mode, quality gates should warn instead of blocking\n */\nexport function isDontAskMode(input: HookInput): boolean {\n  return input.permissionMode === 'dontAsk';\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-18\n\n/**\n * Normalize shell commands for safe pattern matching.\n * Prevents bypass via quoting, escapes, and compound operators.\n *\n * Issue #687: centralizes normalization that was previously ad-hoc\n * across dangerous-command-blocker, auto-approve-safe-bash, and learning-tracker.\n */\n\n/**\n * Expand hex escapes: \\x72\\x6d -> rm\n */\nfunction expandHexEscapes(cmd: string): string {\n  return cmd.replace(/\\\\x([0-9a-fA-F]{2})/g, (_match, hex) =>\n    String.fromCharCode(parseInt(hex, 16))\n  );\n}\n\n/**\n * Expand octal escapes: \\162\\155 -> rm\n */\nfunction expandOctalEscapes(cmd: string): string {\n  return cmd.replace(/\\\\([0-7]{3})/g, (_match, oct) =>\n    String.fromCharCode(parseInt(oct, 8))\n  );\n}\n\n/**\n * Strip backslash escapes from individual characters: r\\m -> rm, r\\\\m -> rm\n * Runs AFTER hex/octal expansion so those are already resolved.\n */\nfunction stripBackslashEscapes(cmd: string): string {\n  // Remove backslash before any non-whitespace character (escape bypass)\n  return cmd.replace(/\\\\([^\\s])/g, '$1');\n}\n\n/**\n * Strip wrapping quotes from tokens: \"rm\" -> rm, 'rm' -> rm\n * Handles full-token quoting and inline quoting like r\"m\" -> rm\n */\nfunction stripQuotes(cmd: string): string {\n  // Remove matched single or double quotes around content\n  let result = cmd;\n  // Strip double-quoted segments: \"...\" -> content\n  result = result.replace(/\"([^\"]*)\"/g, '$1');\n  // Strip single-quoted segments: '...' -> content\n  result = result.replace(/'([^']*)'/g, '$1');\n  return result;\n}\n\n/**\n * Split a command string on compound operators: && || ; | and newlines.\n * Pipe (|) is included because `safe | dangerous` should not auto-approve\n * based on the safe prefix alone.\n *\n * Does NOT split inside quotes (simplified: quotes are already stripped).\n */\nfunction _splitCompound(cmd: string): string[] {\n  // Split on &&, ||, ;, |, or newlines\n  // Order matters: && and || before single & and |\n  return cmd.split(/\\s*(?:&&|\\|\\||\\||;|\\n)\\s*/);\n}\n\n/**\n * Normalize a single sub-command (no splitting, just cleaning).\n * - Expand hex/octal escapes\n * - Strip backslash escapes\n * - Strip quotes\n * - Remove line continuations\n * - Collapse whitespace\n */\nexport function normalizeSingle(cmd: string): string {\n  let result = cmd;\n  result = expandHexEscapes(result);\n  result = expandOctalEscapes(result);\n  result = stripBackslashEscapes(result);\n  result = stripQuotes(result);\n  // Remove line continuations (backslash + newline)\n  result = result.replace(/\\\\\\s*[\\r\\n]+/g, ' ');\n  // Replace remaining newlines\n  result = result.replace(/\\n/g, ' ');\n  // Collapse whitespace\n  result = result.replace(/\\s+/g, ' ');\n  return result.trim();\n}\n\n/**\n * Normalize a shell command for safe matching.\n * Strips quoting, expands escapes, splits compound operators.\n * Returns array of individual normalized sub-commands.\n */\nexport function normalizeCommand(cmd: string): string[] {\n  if (!cmd || !cmd.trim()) return [];\n\n  // Pre-process: expand escapes and strip quotes on the raw input,\n  // but preserve newlines and compound operators for splitting.\n  let preprocessed = cmd;\n  preprocessed = expandHexEscapes(preprocessed);\n  preprocessed = expandOctalEscapes(preprocessed);\n  preprocessed = stripBackslashEscapes(preprocessed);\n  preprocessed = stripQuotes(preprocessed);\n  // Remove line continuations (backslash + newline) \u2014 these join lines\n  preprocessed = preprocessed.replace(/\\\\\\s*[\\r\\n]+/g, ' ');\n\n  // Split on compound operators (&&, ||, |, ;) AND newlines\n  const parts = preprocessed.split(/\\s*(?:&&|\\|\\||\\||;|\\n)\\s*/);\n\n  // Normalize whitespace in each part and filter empties\n  return parts\n    .map((p) => p.replace(/\\s+/g, ' ').trim())\n    .filter(Boolean);\n}\n\n/**\n * Check if any sub-command in a compound command matches a dangerous pattern.\n * Patterns are matched as lowercase substrings against each normalized sub-command.\n */\nexport function containsDangerousCommand(\n  cmd: string,\n  patterns: string[]\n): { matches: boolean; matched?: string; subCommand?: string } {\n  const subCommands = normalizeCommand(cmd);\n\n  for (const sub of subCommands) {\n    const lowerSub = sub.toLowerCase();\n    for (const pattern of patterns) {\n      if (lowerSub.includes(pattern.toLowerCase())) {\n        return { matches: true, matched: pattern, subCommand: sub };\n      }\n    }\n  }\n\n  return { matches: false };\n}\n\n/**\n * Check if a command is a compound command (contains operators like &&, ||, ;, |, or newlines).\n */\nexport function isCompoundCommand(cmd: string): boolean {\n  // Check for newlines BEFORE normalization (normalization converts \\n to space)\n  // But ignore line continuations (backslash + newline) which join lines\n  const withoutContinuations = cmd.replace(/\\\\\\s*[\\r\\n]+/g, ' ');\n  if (/\\n/.test(withoutContinuations)) return true;\n\n  // Check the normalized form for compound operators\n  const normalized = normalizeSingle(cmd);\n  return /(?:&&|\\|\\||[|;])/.test(normalized);\n}\n", "/**\n * Auto-Approve Safe Bash - Automatically approves safe bash commands\n * Hook: PermissionRequest (Bash)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentAllow,\n  outputSilentSuccess,\n  logHook,\n  logPermissionFeedback,\n} from '../lib/common.js';\nimport { isCompoundCommand, normalizeSingle } from '../lib/normalize-command.js';\n\n/**\n * Patterns that should NEVER be auto-approved even if they match SAFE_PATTERNS.\n * SEC: These destructive git operations discard work without warning.\n */\nconst REJECT_PATTERNS: RegExp[] = [\n  /^git\\s+checkout\\s+--\\s+\\./,    // git checkout -- . (discard all unstaged changes)\n  /^git\\s+checkout\\s+\\.\\s*$/,      // git checkout . (same effect)\n  /^git\\s+checkout\\s+(-f|--force)/, // git checkout -f (force, discards local changes)\n  /^git\\s+clean/,                   // git clean (deletes untracked files)\n  /^git\\s+reset\\s+--hard/,          // git reset --hard (discards all changes)\n  /^git\\s+push\\s+.*--force/,        // git push --force (rewrites remote history)\n  /^git\\s+push\\s+-f\\b/,             // git push -f (short form of --force)\n];\n\n/**\n * Safe command patterns that should be auto-approved.\n *\n * SEC AUDIT (#662): Each pattern is safe because:\n * - Compound commands (pipes, &&, ||, ;) are rejected BEFORE pattern matching\n * - normalizeSingle() expands hex/octal escapes and strips quotes before matching\n * - REJECT_PATTERNS are checked BEFORE SAFE_PATTERNS\n */\nconst SAFE_PATTERNS: RegExp[] = [\n  // Git read operations \u2014 safe: read-only, no data loss\n  /^git (status|log|diff|branch|show|fetch|pull)/,\n  // SEC: git checkout <branch/file> is safe for switching branches/restoring files.\n  // Destructive forms (checkout -f, checkout --, checkout .) are caught by REJECT_PATTERNS.\n  /^git checkout\\s+\\S/,\n\n  // Package managers \u2014 safe: read/run operations, no install/publish\n  /^npm (list|ls|outdated|audit|run|test)/,\n  /^pnpm (list|ls|outdated|audit|run|test)/,\n  /^yarn (list|outdated|audit|run|test)/,\n  /^poetry (show|run|env)/,\n\n  // Docker \u2014 safe: read-only inspection commands\n  /^docker (ps|images|logs|inspect)/,\n  /^docker-compose (ps|logs)/,\n  /^docker compose (ps|logs)/,\n\n  // Basic shell commands \u2014 safe: read-only or output-only\n  /^ls(\\s|$)/,\n  /^pwd$/,\n  // SEC: echo is safe \u2014 no file writes (pipes/redirects are compound, rejected above)\n  /^echo\\s/,\n  // SEC: cat/head/tail/wc are read-only (pipes/redirects rejected as compound)\n  /^cat\\s/,\n  /^head\\s/,\n  /^tail\\s/,\n  /^wc\\s/,\n  // SEC: find with -exec uses ; which triggers isCompoundCommand -> manual review\n  /^find\\s/,\n  /^which\\s/,\n  /^type\\s/,\n  /^env$/,\n  /^printenv/,\n\n  // GitHub CLI \u2014 safe: read-only operations only\n  /^gh (issue|pr|repo|workflow) (list|view|status)/,\n  // SEC (#662): Restrict gh milestone to read operations only.\n  // Previously /^gh milestone/ matched create/edit/delete too.\n  /^gh milestone (list|view)/,\n\n  // Testing and linting \u2014 safe: read-only analysis\n  /^pytest/,\n  /^poetry run pytest/,\n  /^npm run (test|lint|typecheck|format)/,\n  /^ruff (check|format)/,\n  /^ty check/,\n  /^mypy/,\n];\n\n/**\n * Auto-approve safe bash commands\n */\nexport function autoApproveSafeBash(input: HookInput): HookResult {\n  const command = input.tool_input.command || '';\n\n  logHook('auto-approve-safe-bash', `Evaluating bash command: ${command.slice(0, 50)}...`);\n\n  // SEC: Reject compound commands \u2014 \"git status && rm -rf /\" must NOT auto-approve\n  if (command && isCompoundCommand(command)) {\n    logHook('auto-approve-safe-bash', 'Compound command detected, requiring manual approval');\n    return outputSilentSuccess();\n  }\n\n  // Normalize the command (expand escapes, strip quotes) for pattern matching\n  const normalized = command ? normalizeSingle(command) : '';\n\n  // SEC: Check reject patterns first (e.g., git checkout -- .)\n  for (const pattern of REJECT_PATTERNS) {\n    if (pattern.test(normalized)) {\n      logHook('auto-approve-safe-bash', `Rejected: matches reject pattern ${pattern}`);\n      return outputSilentSuccess();\n    }\n  }\n\n  // Check against safe patterns using normalized command\n  for (const pattern of SAFE_PATTERNS) {\n    if (pattern.test(normalized)) {\n      logHook('auto-approve-safe-bash', `Auto-approved: matches safe pattern ${pattern}`);\n      logPermissionFeedback('allow', `Matches safe pattern: ${pattern}`, input);\n      return outputSilentAllow();\n    }\n  }\n\n  // Not a recognized safe command - let user decide (silent passthrough)\n  logHook('auto-approve-safe-bash', 'Command requires manual approval');\n  return outputSilentSuccess();\n}\n", "/**\n * Auto-Approve Project Writes - Auto-approves writes within project directory\n * Hook: PermissionRequest (Write|Edit)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentAllow,\n  outputSilentSuccess,\n  logHook,\n  logPermissionFeedback,\n  getProjectDir,\n} from '../lib/common.js';\nimport { resolve, isAbsolute, relative, normalize, sep } from 'node:path';\n\n/**\n * Directories that should not be auto-approved for writes\n */\nconst EXCLUDED_DIRS = [\n  'node_modules',\n  '.git',\n  'dist',\n  'build',\n  '__pycache__',\n  '.venv',\n  'venv',\n];\n\n/**\n * Check if a file path is inside a given root directory (safe containment check).\n * Guards against prefix attacks (e.g. /project-evil vs /project).\n */\nfunction isInsideDir(filePath: string, rootDir: string): boolean {\n  const rel = relative(normalize(rootDir), normalize(filePath));\n  return !rel.startsWith('..') && !isAbsolute(rel);\n}\n\n/**\n * Check if a file path contains an excluded directory segment.\n */\nfunction hasExcludedDir(filePath: string): boolean {\n  for (const dir of EXCLUDED_DIRS) {\n    if (filePath.includes(`${sep}${dir}${sep}`)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Auto-approve writes within project directory or any /add-dir added directories\n * (excluding sensitive directories). CC 2.1.47: respects added_dirs from statusline.\n */\nexport function autoApproveProjectWrites(input: HookInput): HookResult {\n  let filePath = input.tool_input.file_path || '';\n  const projectDir = input.project_dir || getProjectDir();\n\n  logHook('auto-approve-project-writes', `Evaluating write to: ${filePath}`);\n\n  // Resolve to absolute path if relative\n  if (!isAbsolute(filePath)) {\n    filePath = resolve(projectDir, filePath);\n  }\n\n  // All directories to check: primary project dir + any /add-dir dirs (CC 2.1.47)\n  const rootDirs = [projectDir, ...(input.added_dirs ?? [])];\n\n  for (const rootDir of rootDirs) {\n    if (!isInsideDir(filePath, rootDir)) continue;\n\n    if (hasExcludedDir(filePath)) {\n      logHook('auto-approve-project-writes', `Write to excluded directory in: ${rootDir}`);\n      return outputSilentSuccess(); // Let user decide\n    }\n\n    const label = rootDir === projectDir ? 'project directory' : `added dir ${rootDir}`;\n    logHook('auto-approve-project-writes', `Auto-approved: within ${label}`);\n    logPermissionFeedback('allow', `In-project write: ${filePath}`, input);\n    return outputSilentAllow();\n  }\n\n  // Outside all known directories - let user decide\n  logHook('auto-approve-project-writes', 'Write outside project directory - manual approval required');\n  return outputSilentSuccess();\n}\n", "/**\n * Permission Learning Tracker - Learns from user approval patterns\n * Hook: PermissionRequest (Post-approval tracking)\n * CC 2.1.6 Compliant: includes continue field in all outputs\n *\n * This hook runs AFTER other permission hooks and tracks:\n * 1. Commands that are approved manually (potential auto-approve candidates)\n * 2. Patterns in approved commands for learning\n * 3. Frequency of command types\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport {\n  outputSilentSuccess,\n  outputSilentAllow,\n  logHook,\n  logPermissionFeedback,\n  getPluginRoot,\n} from '../lib/common.js';\nimport { isCompoundCommand, normalizeSingle } from '../lib/normalize-command.js';\nimport { existsSync, readFileSync } from 'node:fs';\nimport { join } from 'node:path';\n\n/**\n * Security blocklist - commands that should never be auto-approved\n */\nconst SECURITY_BLOCKLIST: Array<RegExp | { test: (cmd: string) => boolean }> = [\n  /rm\\s+-rf\\s+[/~]/,\n  /sudo\\s/,\n  /chmod\\s+-R\\s+777/,\n  />\\s*\\/dev\\/sd/,\n  /mkfs\\./,\n  /dd\\s+if=/,\n  // Fork bomb / dangerous shell function pattern \u2014 string-based to avoid ReDoS\n  { test: (cmd: string) => cmd.includes(':') && cmd.includes('()') && cmd.includes('{') && cmd.includes('|') && cmd.includes('&') && cmd.includes('}') },\n  { test: (cmd: string) => cmd.includes('curl') && /\\|\\s*sh/.test(cmd) },\n  { test: (cmd: string) => cmd.includes('wget') && /\\|\\s*sh/.test(cmd) },\n];\n\n/**\n * Check if command matches security blocklist\n */\nfunction isSecurityBlocked(command: string): boolean {\n  return SECURITY_BLOCKLIST.some((pattern) => pattern.test(command));\n}\n\n/**\n * Load learned patterns from feedback file\n */\nfunction loadLearnedPatterns(): string[] {\n  const pluginRoot = getPluginRoot();\n  const feedbackFile = join(pluginRoot, '.claude', 'feedback', 'learned-patterns.json');\n\n  try {\n    if (existsSync(feedbackFile)) {\n      const data = JSON.parse(readFileSync(feedbackFile, 'utf8'));\n      return data.autoApprovePatterns || [];\n    }\n  } catch {\n    // Ignore errors\n  }\n\n  return [];\n}\n\n/**\n * Check if command matches a learned auto-approve pattern.\n * SEC: Uses literal prefix matching only \u2014 never constructs RegExp from user data.\n * Each pattern is treated as a literal command prefix (case-insensitive).\n * SEC: Normalizes command before matching to prevent escape-based bypasses.\n */\nfunction shouldAutoApprove(command: string): boolean {\n  const patterns = loadLearnedPatterns();\n  const normalizedCommand = normalizeSingle(command).toLowerCase();\n\n  for (const pattern of patterns) {\n    // SEC: Only allow non-empty string patterns, no regex interpretation\n    if (typeof pattern !== 'string' || pattern.length === 0 || pattern.length > 200) {\n      continue;\n    }\n    // Literal prefix match only \u2014 safe from regex injection\n    if (normalizedCommand.startsWith(pattern.toLowerCase().trim())) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Learning tracker hook - observes permissions for learning, optionally auto-approves\n */\nexport function learningTracker(input: HookInput): HookResult {\n  const toolName = input.tool_name;\n  const command = input.tool_input.command || input.tool_input.file_path || '';\n\n  logHook('learning-tracker', `Processing permission for tool: ${toolName}, command: ${command.slice(0, 50)}...`);\n\n  // For Bash commands, check if we should auto-approve based on learned patterns\n  if (toolName === 'Bash' && command) {\n    // First check security blocklist - never auto-approve these\n    if (isSecurityBlocked(command)) {\n      logHook('learning-tracker', 'Command matches security blocklist, skipping');\n      return outputSilentSuccess();\n    }\n\n    // SEC: Never auto-approve compound commands \u2014 require manual review\n    if (isCompoundCommand(command)) {\n      logHook('learning-tracker', 'Compound command detected, skipping auto-approve');\n      return outputSilentSuccess();\n    }\n\n    // Check if this command matches a learned auto-approve pattern\n    if (shouldAutoApprove(command)) {\n      logHook('learning-tracker', 'Command matches learned auto-approve pattern');\n      logPermissionFeedback('allow', 'Learned pattern match', input);\n      return outputSilentAllow();\n    }\n  }\n\n  // Output: Silent pass-through (don't affect the permission decision)\n  // This hook observes for learning purposes\n  return outputSilentSuccess();\n}\n", "// Generated by OrchestKit Claude Plugin\n// Created: 2026-02-20\n\n/**\n * Unified PermissionRequest/Bash Dispatcher\n * Consolidates 2 PermissionRequest hooks for Bash into a single process spawn.\n *\n * Issue #683: Reduces 2 process spawns to 1 for PermissionRequest/Bash.\n *\n * Hooks consolidated (execution order):\n * 1. auto-approve-safe-bash \u2014 checks known-safe patterns, returns 'allow' or passthrough\n * 2. learning-tracker \u2014 checks learned patterns, returns 'allow' or passthrough\n *\n * Logic: If auto-approve-safe-bash returns an allow decision, skip learning-tracker.\n * If it passes through, try learning-tracker. If neither approves, pass through to user.\n *\n * CC 2.1.6 Compliant: includes continue field and permissionDecision in all outputs\n */\n\nimport type { HookInput, HookResult } from '../types.js';\nimport { outputSilentSuccess, logHook } from '../lib/common.js';\nimport { autoApproveSafeBash } from './auto-approve-safe-bash.js';\nimport { learningTracker } from './learning-tracker.js';\n\nconst HOOK_NAME = 'permission-bash-dispatcher';\n\n/** Exposed for testing */\nexport const registeredHookNames = () => [\n  'auto-approve-safe-bash',\n  'learning-tracker',\n];\n\n/**\n * Unified PermissionRequest dispatcher for Bash commands.\n * Runs safe-bash check first, falls back to learned patterns.\n */\nexport function unifiedPermissionBashDispatcher(input: HookInput): HookResult {\n  // --- Step 1: Check known-safe patterns ---\n  try {\n    const safeResult = autoApproveSafeBash(input);\n\n    // If auto-approve returned an 'allow' decision, use it immediately\n    if (safeResult.hookSpecificOutput?.permissionDecision === 'allow') {\n      logHook(HOOK_NAME, 'auto-approve-safe-bash: allowed');\n      return safeResult;\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    logHook(HOOK_NAME, `auto-approve-safe-bash failed: ${message}`, 'warn');\n  }\n\n  // --- Step 2: Check learned patterns ---\n  try {\n    const learnedResult = learningTracker(input);\n\n    // If learning-tracker returned an 'allow' decision, use it\n    if (learnedResult.hookSpecificOutput?.permissionDecision === 'allow') {\n      logHook(HOOK_NAME, 'learning-tracker: allowed via learned pattern');\n      return learnedResult;\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    logHook(HOOK_NAME, `learning-tracker failed: ${message}`, 'warn');\n  }\n\n  // --- Neither approved \u2014 pass through to user ---\n  return outputSilentSuccess();\n}\n", "/**\n * Permission Hooks Entry Point\n *\n * Hooks that handle permission decisions (PreToolUse with permissionDecision)\n * Bundle: permission.mjs (~15 KB estimated)\n */\n\n// Re-export types and utilities needed by permission hooks\nexport * from '../types.js';\nexport * from '../lib/common.js';\nexport * from '../lib/guards.js';\n\n// Import hook implementations\nimport { autoApproveSafeBash } from '../permission/auto-approve-safe-bash.js';\nimport { autoApproveProjectWrites } from '../permission/auto-approve-project-writes.js';\nimport { learningTracker } from '../permission/learning-tracker.js';\nimport { unifiedPermissionBashDispatcher } from '../permission/unified-dispatcher.js';\n\nimport type { HookFn } from '../types.js';\n\n/**\n * Permission hooks registry\n */\nexport const hooks: Record<string, HookFn> = {\n  'permission/auto-approve-safe-bash': autoApproveSafeBash,\n  'permission/auto-approve-project-writes': autoApproveProjectWrites,\n  'permission/learning-tracker': learningTracker,\n  'permission/unified-dispatcher': unifiedPermissionBashDispatcher,\n};\n\nexport function getHook(name: string): HookFn | undefined {\n  return hooks[name];\n}\n\nexport function listHooks(): string[] {\n  return Object.keys(hooks);\n}\n"],
  "mappings": "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",
  "names": ["isBashInput", "input", "isWriteInput", "isEditInput", "isReadInput", "existsSync", "statSync", "renameSync", "mkdirSync", "readSync", "appendFileSync", "mkdirSync", "dirname", "buffer", "flushing", "handlersRegistered", "bufferWrite", "filePath", "content", "ensureHandlers", "flush", "grouped", "entry", "arr", "path", "contents", "ensureHandlers", "handlersRegistered", "flush", "execSync", "os", "path", "getHomeDir", "getProjectDir", "getPluginRoot", "getLogDir", "path", "getHomeDir", "joinPath", "path", "pathSeparator", "execSync", "createHash", "existsSync", "readFileSync", "writeFileSync", "mkdirSync", "join", "basename", "MAX_PROJECT_LENGTH", "MAX_BRANCH_LENGTH", "SAFE_CHARS", "getProjectName", "projectDir", "dir", "name", "sanitizeName", "getGitBranchForSession", "branch", "sanitized", "formatDateComponent", "date", "d", "month", "day", "formatTimeComponent", "hours", "minutes", "generateShortHash", "entropy", "maxLength", "generateSmartSessionId", "project", "dateStr", "timeStr", "hash", "getCachedSessionId", "cachePath", "data", "age", "maxAge", "cacheSessionId", "sessionId", "instanceDir", "getOrGenerateSessionId", "cached", "newId", "getLogDir", "getProjectDir", "getPluginRoot", "getEnvFile", "getSessionId", "getOrGenerateSessionId", "getCachedBranch", "projectDir", "branch", "execSync", "getLogLevel", "normalizeLineEndings", "content", "shouldLog", "level", "levels", "outputSilentSuccess", "outputSilentAllow", "outputBlock", "reason", "outputWithContext", "ctx", "outputPromptContext", "outputWithNotification", "userMessage", "claudeContext", "result", "outputAllowWithContext", "systemMessage", "outputError", "message", "outputWarning", "outputStderrWarning", "outputDeny", "outputWithUpdatedInput", "updatedInput", "LOG_ROTATION_MAX_SIZE", "PERMISSION_LOG_MAX_SIZE", "rotateLogFile", "logFile", "maxSize", "existsSync", "statSync", "rotated", "renameSync", "ensureDir", "dir", "mkdirSync", "logHook", "hookName", "logDir", "timestamp", "bufferWrite", "logPermissionFeedback", "decision", "input", "toolName", "sessionId", "extractContext", "estimateTokenCount", "charsPerToken", "outputPromptContextBudgeted", "category", "budgetChecker", "tokenTracker", "tokens", "readHookInput", "chunks", "buf", "bytesRead", "fd", "readSync", "getField", "path", "parts", "value", "part", "lineContainsAll", "terms", "line", "t", "lineContainsAllCI", "lower", "normalizeCommand", "command", "escapeRegex", "str", "isAgentTeamsActive", "globMatch", "glob", "str", "parts", "pos", "part", "searchPart", "matched", "i", "ok", "j", "idx", "createGuard", "predicate", "input", "outputSilentSuccess", "guardFileExtension", "extensions", "filePath", "ext", "e", "guardCodeFiles", "guardPythonFiles", "guardTypescriptFiles", "guardTestFiles", "p", "guardSkipInternal", "guardPathPattern", "patterns", "pattern", "guardTool", "tools", "toolName", "guardWriteEdit", "guardBash", "guardNontrivialBash", "command", "guardGitCommand", "guardMultiInstance", "isAgentTeamsActive", "dbPath", "existsSync", "runGuards", "guards", "guard", "result", "isDontAskMode", "expandHexEscapes", "cmd", "_match", "hex", "expandOctalEscapes", "oct", "stripBackslashEscapes", "stripQuotes", "result", "normalizeSingle", "cmd", "result", "expandHexEscapes", "expandOctalEscapes", "stripBackslashEscapes", "stripQuotes", "isCompoundCommand", "cmd", "withoutContinuations", "normalized", "normalizeSingle", "REJECT_PATTERNS", "SAFE_PATTERNS", "autoApproveSafeBash", "input", "command", "logHook", "isCompoundCommand", "outputSilentSuccess", "normalized", "normalizeSingle", "pattern", "logPermissionFeedback", "outputSilentAllow", "resolve", "isAbsolute", "relative", "normalize", "sep", "EXCLUDED_DIRS", "isInsideDir", "filePath", "rootDir", "rel", "hasExcludedDir", "dir", "autoApproveProjectWrites", "input", "projectDir", "getProjectDir", "logHook", "rootDirs", "outputSilentSuccess", "label", "logPermissionFeedback", "outputSilentAllow", "existsSync", "readFileSync", "join", "SECURITY_BLOCKLIST", "cmd", "isSecurityBlocked", "command", "pattern", "loadLearnedPatterns", "pluginRoot", "getPluginRoot", "feedbackFile", "shouldAutoApprove", "patterns", "normalizedCommand", "normalizeSingle", "learningTracker", "input", "toolName", "logHook", "outputSilentSuccess", "isCompoundCommand", "logPermissionFeedback", "outputSilentAllow", "HOOK_NAME", "unifiedPermissionBashDispatcher", "input", "safeResult", "autoApproveSafeBash", "logHook", "HOOK_NAME", "error", "message", "learnedResult", "learningTracker", "outputSilentSuccess", "hooks", "autoApproveSafeBash", "autoApproveProjectWrites", "learningTracker", "unifiedPermissionBashDispatcher", "getHook", "name", "listHooks"]
}
