// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync SubagentStop Dispatcher — SubagentStop Hook
 * Consolidates 6 synchronous SubagentStop hooks into a single dispatcher.
 *
 * Consolidated hooks:
 * - output-validator (first — validates output before other hooks process it; may block)
 * - auto-spawn-quality (may return systemMessage)
 * - multi-claude-verifier (may return systemMessage)
 * - subagent-quality-gate (may block via outputWarning)
 * - retry-handler (may return additionalContext via outputWithContext)
 *
 * NOT consolidated (remains separate in hooks.json):
 * - unified-dispatcher (async — fire-and-forget analytics)
 *
 * CC 2.1.9 Compliant: Short-circuits on continue: false; merges additionalContext + systemMessage
 */

import type { HookInput, HookResult } from '../types.js';
import { outputSilentSuccess, logHook, extractContext } from '../lib/common.js';

// Import consolidated hook implementations
import { outputValidator } from './output-validator.js';
import { autoSpawnQuality } from './auto-spawn-quality.js';
import { multiClaudeVerifier } from './multi-claude-verifier.js';
import { subagentQualityGate } from './subagent-quality-gate.js';
import { retryHandler } from './retry-handler.js';

const HOOK_NAME = 'sync-subagent-stop-dispatcher';

interface SyncHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult;
}

/**
 * Registry of sync SubagentStop hooks, executed sequentially.
 * Order matters — output-validator runs first to validate output before other hooks process it.
 */
const SYNC_HOOKS: SyncHookConfig[] = [
  { name: 'output-validator', fn: outputValidator },
  { name: 'auto-spawn-quality', fn: autoSpawnQuality },
  { name: 'multi-claude-verifier', fn: multiClaudeVerifier },
  { name: 'subagent-quality-gate', fn: subagentQualityGate },
  { name: 'retry-handler', fn: retryHandler },
];

/**
 * Consolidated sync SubagentStop dispatcher.
 * Runs all sync hooks sequentially. If any hook returns continue: false,
 * short-circuits immediately and returns that block result.
 * Merges systemMessage and additionalContext from all passing hooks.
 */
export function syncSubagentStopDispatcher(input: HookInput): HookResult {
  const messages: string[] = [];

  for (const hook of SYNC_HOOKS) {
    try {
      const result = hook.fn(input);

      // Short-circuit immediately if any hook blocks
      if (result.continue === false) {
        logHook(HOOK_NAME, `${hook.name}: blocked (continue: false) — short-circuiting`);
        return result;
      }

      // Collect systemMessage
      if (result.systemMessage) {
        messages.push(result.systemMessage);
        logHook(HOOK_NAME, `${hook.name}: systemMessage collected`);
      }

      // Collect additionalContext (retry-handler uses outputWithContext)
      const context = extractContext(result);
      if (context && !result.systemMessage) {
        messages.push(context);
        logHook(HOOK_NAME, `${hook.name}: additionalContext collected`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
    }
  }

  if (messages.length === 0) {
    logHook(HOOK_NAME, 'All sync hooks silent');
    return outputSilentSuccess();
  }

  const merged = messages.join('\n');
  logHook(HOOK_NAME, `Merged ${messages.length} messages from sync hooks`);

  return {
    continue: true,
    systemMessage: merged,
  };
}
