// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync Setup Dispatcher — Setup Hook
 * Consolidates 6 Setup hooks into a single dispatcher.
 *
 * Consolidated hooks:
 * - unified-dispatcher (was async — becomes internal sub-hook, runs dependency-version-check)
 * - setup-check (once: true — fast path validation, triggers maintenance/repair)
 * - first-run-setup (once: true — full first-run initialization)
 * - setup-maintenance (periodic maintenance tasks)
 * - setup-repair (self-healing for broken installations)
 * - monorepo-detector (once: true — detects monorepo structure)
 *
 * NOT consolidated (remain separate in hooks.json):
 * None — all Setup hooks are consolidated here.
 *
 * CC 2.1.11 Compliant: Single sync hook with merged systemMessage output.
 * Once-gate pattern: setup-check, first-run-setup, monorepo-detector run only once per install.
 */

import { existsSync, writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { homedir } from 'node:os';
import type { HookInput, HookResult } from '../types.js';
import { outputSilentSuccess, logHook, extractContext } from '../lib/common.js';

// Import consolidated hook implementations
import { unifiedSetupDispatcher } from './unified-dispatcher.js';
import { setupCheck } from './setup-check.js';
import { firstRunSetup } from './first-run-setup.js';
import { setupMaintenance } from './setup-maintenance.js';
import { setupRepair } from './setup-repair.js';
import { monorepoDetector } from './monorepo-detector.js';

const HOOK_NAME = 'sync-setup-dispatcher';

// -----------------------------------------------------------------------------
// Once-gate helpers
// -----------------------------------------------------------------------------

function hasRunOnce(hookName: string): boolean {
  const markerDir = join(homedir(), '.claude', 'ork', 'once-markers');
  const marker = join(markerDir, `${hookName}.done`);
  return existsSync(marker);
}

function markAsRun(hookName: string): void {
  const markerDir = join(homedir(), '.claude', 'ork', 'once-markers');
  mkdirSync(markerDir, { recursive: true });
  writeFileSync(join(markerDir, `${hookName}.done`), new Date().toISOString());
}

// -----------------------------------------------------------------------------
// Hook registry
// -----------------------------------------------------------------------------

interface SyncHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult | Promise<HookResult>;
  once?: boolean;
}

/**
 * Registry of Setup hooks, executed sequentially.
 * Order matters — unified-dispatcher runs first (dep checks), then setup-check,
 * first-run-setup, maintenance, repair, and monorepo-detector last.
 */
const SYNC_HOOKS: SyncHookConfig[] = [
  { name: 'unified-dispatcher', fn: unifiedSetupDispatcher },
  { name: 'setup-check', fn: setupCheck, once: true },
  { name: 'first-run-setup', fn: firstRunSetup, once: true },
  { name: 'setup-maintenance', fn: setupMaintenance },
  { name: 'setup-repair', fn: setupRepair },
  { name: 'monorepo-detector', fn: monorepoDetector, once: true },
];

// -----------------------------------------------------------------------------
// Dispatcher implementation
// -----------------------------------------------------------------------------

/**
 * Consolidated sync Setup dispatcher.
 * Runs all Setup hooks sequentially, respecting once-gate for hooks marked once: true.
 * Merges systemMessage/additionalContext outputs.
 */
export async function syncSetupDispatcher(input: HookInput): Promise<HookResult> {
  const messages: string[] = [];

  for (const hook of SYNC_HOOKS) {
    // Skip once-gated hooks that have already run
    if (hook.once && hasRunOnce(hook.name)) {
      logHook(HOOK_NAME, `${hook.name}: skipped (already ran once)`);
      continue;
    }

    try {
      const resultOrPromise = hook.fn(input);
      const result = resultOrPromise instanceof Promise ? await resultOrPromise : resultOrPromise;

      // Mark once-gated hooks after successful run
      if (hook.once) {
        markAsRun(hook.name);
      }

      // Collect systemMessage (primary output channel for Setup)
      if (result.systemMessage) {
        messages.push(result.systemMessage);
        logHook(HOOK_NAME, `${hook.name}: systemMessage collected`);
      }

      // Fallback: extract additionalContext
      const context = extractContext(result);
      if (context && !result.systemMessage) {
        messages.push(context);
        logHook(HOOK_NAME, `${hook.name}: additionalContext converted to systemMessage`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
    }
  }

  if (messages.length === 0) {
    logHook(HOOK_NAME, 'All Setup hooks silent');
    return outputSilentSuccess();
  }

  const merged = messages.join('\n');
  logHook(HOOK_NAME, `Merged ${messages.length} messages from Setup hooks`);

  return {
    continue: true,
    systemMessage: merged,
  };
}
