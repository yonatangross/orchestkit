// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Unified Prompt Dispatcher — UserPromptSubmit Hook
 * Issue #448: Consolidate UserPromptSubmit hooks to reduce context bloat
 *
 * Problem: 13 separate UserPromptSubmit hooks = 13 system-reminder tags per turn,
 * consuming 1500-3200 tokens/turn. Many are no-ops, duplicates, or silent analytics.
 *
 * Solution: Single dispatcher that runs all every-turn hooks internally,
 * collects their additionalContext outputs, merges into one consolidated response.
 * Reduces system-reminders from 13 to 4-5 per turn (3 once-only + 1 dispatcher + 1 silent).
 *
 * Hooks consolidated here:
 * - context-injector (removed — no-op, only logs)
 * - todo-enforcer (removed — no-op, only logs)
 * - satisfaction-detector (silent analytics)
 * - communication-style-tracker (silent analytics)
 * - antipattern-detector (merged with antipattern-warning)
 * - antipattern-warning (merged — deduplicated logic)
 * - memory-context (context injection)
 * - context-pruning-advisor (context injection)
 * - pipeline-detector (context injection)
 *
 * NOT consolidated (remain separate in hooks.json):
 * - profile-injector (once: true)
 * - memory-context-loader (once: true)
 * - queue-recovery (once: true)
 * - capture-user-intent (uses run-hook-silent.mjs for background execution)
 *
 * CC 2.1.9 Compliant: Single additionalContext output
 */

import type { HookInput, HookResult } from '../types.js';
import {
  outputSilentSuccess,
  outputPromptContext,
  logHook,
  estimateTokenCount,
} from '../lib/common.js';

// Import hook implementations
import { satisfactionDetector } from './satisfaction-detector.js';
import { communicationStyleTracker } from './communication-style-tracker.js';
import { antipatternWarning } from './antipattern-warning.js';
import { memoryContext } from './memory-context.js';
import { contextPruningAdvisor } from './context-pruning-advisor.js';
import { pipelineDetector } from './pipeline-detector.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'prompt-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

/**
 * Maximum prompt length to process (characters).
 * Image pastes can inject megabytes of base64 data into the prompt field.
 * Running toLowerCase() + includes() + regex on megabytes across 6 sub-hooks
 * causes severe latency and can effectively kill the context window.
 * Guard: skip all processing if prompt exceeds this threshold.
 */
const MAX_PROMPT_LENGTH = 50_000;

/**
 * Detect if prompt contains image/binary data.
 * CC may send base64-encoded images or data URIs in the prompt field
 * when users paste screenshots. These are useless for text analysis hooks
 * and extremely expensive to process with regex/string ops.
 */
function isImageOrBinaryPrompt(prompt: string): boolean {
  // Data URI for images (data:image/png;base64,...)
  if (/^data:image\//.test(prompt)) return true;

  // Long base64 block (>1KB of continuous base64 chars = likely binary)
  if (/[A-Za-z0-9+/=]{1024,}/.test(prompt.slice(0, 5000))) return true;

  // Prompt is mostly non-printable or non-ASCII
  const sample = prompt.slice(0, 2000);
  const nonText = sample.replace(/[\x20-\x7E\n\r\t]/g, '').length;
  if (nonText / sample.length > 0.3) return true;

  return false;
}

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface PromptHookConfig {
  name: string;
  fn: HookFn;
  /** Whether this hook produces context output (vs silent analytics) */
  producesContext: boolean;
}

// -----------------------------------------------------------------------------
// Hook Registry
// -----------------------------------------------------------------------------

/**
 * Registry of every-turn UserPromptSubmit hooks.
 *
 * Order matters for context producers — higher priority first.
 * Silent analytics hooks run but their output is discarded.
 */
const HOOKS: PromptHookConfig[] = [
  // --- Silent analytics (fire-and-forget, no context output) ---
  { name: 'satisfaction-detector', fn: satisfactionDetector, producesContext: false },
  { name: 'communication-style-tracker', fn: communicationStyleTracker, producesContext: false },

  // --- Context producers (output merged into single additionalContext) ---
  { name: 'context-pruning-advisor', fn: contextPruningAdvisor, producesContext: true },
  { name: 'antipattern-warning', fn: antipatternWarning, producesContext: true },
  { name: 'memory-context', fn: memoryContext, producesContext: true },
  { name: 'pipeline-detector', fn: pipelineDetector, producesContext: true },
];

/** Exposed for testing */
export const registeredHookNames = () => HOOKS.map(h => h.name);

// -----------------------------------------------------------------------------
// Context Extraction
// -----------------------------------------------------------------------------

/**
 * Extract additionalContext from a hook result.
 * Handles both the correct outputPromptContext format and the bare systemMessage format.
 */
function extractContext(result: HookResult): string | null {
  // Standard format: hookSpecificOutput.additionalContext
  if (result.hookSpecificOutput?.additionalContext) {
    return result.hookSpecificOutput.additionalContext as string;
  }

  // Legacy format: bare systemMessage (antipattern-detector bug)
  if (result.systemMessage && typeof result.systemMessage === 'string') {
    return result.systemMessage;
  }

  return null;
}

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher that runs all every-turn UserPromptSubmit hooks
 * and consolidates their output into a single additionalContext response.
 */
export function unifiedPromptDispatcher(input: HookInput): HookResult {
  // Guard: skip all processing for oversized or binary prompts (image paste, base64 data)
  const prompt = input.prompt || '';
  if (prompt.length > MAX_PROMPT_LENGTH) {
    logHook(HOOK_NAME, `Prompt too large (${prompt.length} chars > ${MAX_PROMPT_LENGTH}), skipping — likely image/binary data`);
    return outputSilentSuccess();
  }
  if (prompt.length > 500 && isImageOrBinaryPrompt(prompt)) {
    logHook(HOOK_NAME, `Image/binary content detected in prompt (${prompt.length} chars), skipping text analysis hooks`);
    return outputSilentSuccess();
  }

  const contextParts: string[] = [];
  let totalTokens = 0;

  for (const hook of HOOKS) {
    try {
      const result = hook.fn(input);

      // Skip silent analytics hooks — they've done their work (logging/tracking)
      if (!hook.producesContext) {
        continue;
      }

      // Extract context from the result
      const context = extractContext(result);
      if (!context) {
        continue;
      }

      // Budget check: don't exceed max output tokens
      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;

      logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // No context produced — return silent
  if (contextParts.length === 0) {
    return outputSilentSuccess();
  }

  // Single consolidated output
  const consolidated = contextParts.join('\n\n---\n\n');
  logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);

  return outputPromptContext(consolidated);
}
