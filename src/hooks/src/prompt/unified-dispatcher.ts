// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Unified Prompt Dispatcher — UserPromptSubmit Hook
 * Issue #448: Consolidate UserPromptSubmit hooks to reduce context bloat
 *
 * Problem: 13 separate UserPromptSubmit hooks = 13 system-reminder tags per turn,
 * consuming 1500-3200 tokens/turn. Many are no-ops, duplicates, or silent analytics.
 *
 * Solution: Single dispatcher that runs all hooks internally (both every-turn and
 * once-per-session), collects their additionalContext outputs, merges into one
 * consolidated response. Reduces UserPromptSubmit hooks.json entries from 5 to 2.
 *
 * Every-turn hooks consolidated here:
 * - context-injector (removed — no-op, only logs)
 * - todo-enforcer (removed — no-op, only logs)
 * - satisfaction-detector (silent analytics)
 * - communication-style-tracker (silent analytics)
 * - antipattern-detector (merged with antipattern-warning)
 * - antipattern-warning (merged — deduplicated logic)
 * - memory-context (context injection)
 * - context-pruning-advisor (context injection)
 * - pipeline-detector (context injection)
 *
 * Once-per-session hooks consolidated here (file-based flag tracking):
 * - profile-injector (run once via session flag)
 * - memory-context-loader (run once via session flag)
 * - queue-recovery (removed — no source file, was a ghost no-op)
 *
 * NOT consolidated (remain separate in hooks.json):
 * - capture-user-intent (async: true in hooks.json — CC handles background execution natively)
 *
 * CC 2.1.9 Compliant: Single additionalContext output
 */

import type { HookInput, HookResult } from '../types.js';
import {
  outputSilentSuccess,
  outputPromptContext,
  logHook,
  estimateTokenCount,
  getProjectDir,
  getSessionId,
  extractContext,
} from '../lib/common.js';
import { isImageOrBinaryPrompt, MAX_PROMPT_LENGTH } from '../lib/prompt-guards.js';
import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';

// Import hook implementations — every-turn
import { satisfactionDetector } from './satisfaction-detector.js';
import { communicationStyleTracker } from './communication-style-tracker.js';
import { antipatternWarning } from './antipattern-warning.js';
import { memoryContext } from './memory-context.js';
import { contextPruningAdvisor } from './context-pruning-advisor.js';
import { pipelineDetector } from './pipeline-detector.js';
import { skillNudgePrompt } from './skill-nudge.js';

// Import hook implementations — once-per-session
import { profileInjector } from './profile-injector.js';
import { memoryContextLoader } from './memory-context-loader.js';
import { agentationContext } from './agentation-context.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'prompt-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface PromptHookConfig {
  name: string;
  fn: HookFn;
  /** Whether this hook produces context output (vs silent analytics) */
  producesContext: boolean;
  /** If true, this hook runs only once per session (file-based flag tracking) */
  runOnce?: boolean;
}

// -----------------------------------------------------------------------------
// Hook Registry
// -----------------------------------------------------------------------------

/**
 * Registry of all UserPromptSubmit hooks managed by this dispatcher.
 *
 * Order matters for context producers — higher priority first.
 * Silent analytics hooks run but their output is discarded.
 * runOnce hooks execute only on the first turn (file-based session flag).
 */
const HOOKS: PromptHookConfig[] = [
  // --- Once-per-session hooks (run on first turn only, file-flag gated) ---
  { name: 'profile-injector', fn: profileInjector, producesContext: true, runOnce: true },
  { name: 'memory-context-loader', fn: memoryContextLoader, producesContext: true, runOnce: true },
  { name: 'agentation-context', fn: agentationContext, producesContext: true, runOnce: true },

  // --- Silent analytics (fire-and-forget, no context output) ---
  { name: 'satisfaction-detector', fn: satisfactionDetector, producesContext: false },
  { name: 'communication-style-tracker', fn: communicationStyleTracker, producesContext: false },

  // --- Context producers (output merged into single additionalContext) ---
  { name: 'context-pruning-advisor', fn: contextPruningAdvisor, producesContext: true },
  { name: 'antipattern-warning', fn: antipatternWarning, producesContext: true },
  { name: 'memory-context', fn: memoryContext, producesContext: true },
  { name: 'pipeline-detector', fn: pipelineDetector, producesContext: true },
  { name: 'skill-nudge-prompt', fn: skillNudgePrompt, producesContext: true },
];

/** Exposed for testing */
export const registeredHookNames = () => HOOKS.map(h => h.name);

// -----------------------------------------------------------------------------
// Once-per-session Flag Tracking
// -----------------------------------------------------------------------------

/**
 * Check if a once-per-session hook has already run.
 * Uses file-based flags at: {project}/.claude/memory/sessions/{session_id}/once-flags/{hook}.done
 */
function hasOnceFlagRun(hookName: string, sessionId: string, projectDir: string): boolean {
  const flagPath = join(projectDir, '.claude', 'memory', 'sessions', sessionId, 'once-flags', `${hookName}.done`);
  return existsSync(flagPath);
}

/**
 * Mark a once-per-session hook as having run.
 */
function setOnceFlagDone(hookName: string, sessionId: string, projectDir: string): void {
  const flagDir = join(projectDir, '.claude', 'memory', 'sessions', sessionId, 'once-flags');
  if (!existsSync(flagDir)) {
    mkdirSync(flagDir, { recursive: true });
  }
  writeFileSync(join(flagDir, `${hookName}.done`), Date.now().toString(), 'utf8');
}

// extractContext imported from ../lib/common.js (Issue #682)

// -----------------------------------------------------------------------------
// Noise Filter
// -----------------------------------------------------------------------------

/**
 * Detect noisy/low-value context that shouldn't consume token budget.
 * Returns true if the context is only bracket-enclosed markers or
 * cross-project context lines with no actionable content.
 */
function isNoisyOutput(context: string): boolean {
  const lines = context.split('\n').filter(l => l.trim().length > 0);
  if (lines.length === 0) return true;

  return lines.every(line => {
    const trimmed = line.trim();
    // [Cross-project context:...] lines
    if (/^\[Cross-project context:.*\]$/.test(trimmed)) return true;
    // Bracket-enclosed timestamp markers like [2026-02-28 08:45]
    if (/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}.*\]$/.test(trimmed)) return true;
    return false;
  });
}

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher that runs all every-turn UserPromptSubmit hooks
 * and consolidates their output into a single additionalContext response.
 */
export function unifiedPromptDispatcher(input: HookInput): HookResult {
  // Guard: skip all processing for oversized or binary prompts (image paste, base64 data)
  const prompt = input.prompt || '';
  if (prompt.length > MAX_PROMPT_LENGTH) {
    logHook(HOOK_NAME, `Prompt too large (${prompt.length} chars > ${MAX_PROMPT_LENGTH}), skipping — likely image/binary data`);
    return outputSilentSuccess();
  }
  if (prompt.length > 500 && isImageOrBinaryPrompt(prompt)) {
    logHook(HOOK_NAME, `Image/binary content detected in prompt (${prompt.length} chars), skipping text analysis hooks`);
    return outputSilentSuccess();
  }

  const contextParts: string[] = [];
  let totalTokens = 0;

  // Resolve session/project for once-flag tracking
  const sessionId = input.session_id || getSessionId();
  const projectDir = input.project_dir || getProjectDir();

  for (const hook of HOOKS) {
    try {
      // Once-per-session gate: skip if already run this session
      if (hook.runOnce) {
        if (!sessionId) {
          // No session_id available — allow re-run (same as legacy behavior)
          logHook(HOOK_NAME, `${hook.name}: no session_id, running without once-gate`);
        } else if (hasOnceFlagRun(hook.name, sessionId, projectDir)) {
          logHook(HOOK_NAME, `${hook.name}: already ran this session, skipping`);
          continue;
        }
      }

      const result = hook.fn(input);

      // Mark once-per-session hook as done after successful execution
      if (hook.runOnce && sessionId) {
        try {
          setOnceFlagDone(hook.name, sessionId, projectDir);
        } catch (flagErr) {
          logHook(HOOK_NAME, `${hook.name}: failed to write once-flag: ${flagErr}`, 'warn');
        }
      }

      // Skip silent analytics hooks — they've done their work (logging/tracking)
      if (!hook.producesContext) {
        continue;
      }

      // Extract context from the result
      const context = extractContext(result);
      if (!context) {
        continue;
      }

      // Filter noisy/low-value context before consuming budget
      if (isNoisyOutput(context)) {
        logHook(HOOK_NAME, `${hook.name}: noisy output filtered`);
        continue;
      }

      // Budget check: don't exceed max output tokens
      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;

      logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // No context produced — return silent
  if (contextParts.length === 0) {
    return outputSilentSuccess();
  }

  // Single consolidated output
  const consolidated = contextParts.join('\n\n---\n\n');
  logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);

  return outputPromptContext(consolidated);
}
