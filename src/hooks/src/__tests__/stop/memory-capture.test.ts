// Generated by OrchestKit Claude Plugin
// Created: 2026-02-19

/**
 * Unit tests for memory-capture stop hook
 * Tests classifySessionOutcome, JSONL record fields, and session outcome logic.
 */

import { describe, test, expect, beforeEach, vi } from 'vitest';

// Mock node:fs
vi.mock('node:fs', () => ({
  existsSync: vi.fn(),
  statSync: vi.fn(),
  mkdirSync: vi.fn(),
  appendFileSync: vi.fn(),
  renameSync: vi.fn(),
}));

// Mock node:os
vi.mock('node:os', () => ({
  homedir: vi.fn(() => '/home/testuser'),
}));

// Mock common utilities
vi.mock('../../lib/common.js', () => ({
  logHook: vi.fn(),
  outputSilentSuccess: vi.fn(() => ({ continue: true, suppressOutput: true })),
  getProjectDir: vi.fn(() => '/test/project'),
}));

// Mock metrics
vi.mock('../../lib/metrics.js', () => ({
  getTotalTools: vi.fn(),
}));

import { memoryCapture } from '../../stop/memory-capture.js';
import { existsSync, statSync, mkdirSync, appendFileSync } from 'node:fs';
import { outputSilentSuccess } from '../../lib/common.js';
import { getTotalTools } from '../../lib/metrics.js';
import type { HookInput } from '../../types.js';

const mockExistsSync = vi.mocked(existsSync);
const mockStatSync = vi.mocked(statSync);
const mockMkdirSync = vi.mocked(mkdirSync);
const mockAppendFileSync = vi.mocked(appendFileSync);
const mockGetTotalTools = vi.mocked(getTotalTools);
const _mockOutputSilentSuccess = vi.mocked(outputSilentSuccess);

function createHookInput(overrides: Partial<HookInput> = {}): HookInput {
  return {
    tool_name: '',
    session_id: 'test-session-abc123',
    project_dir: '/test/project',
    tool_input: {},
    ...overrides,
  };
}

beforeEach(() => {
  vi.clearAllMocks();
  // Default: memory dir exists, decisions file is small
  mockExistsSync.mockReturnValue(true);
  mockStatSync.mockReturnValue({ size: 1024 } as ReturnType<typeof statSync>);
  mockGetTotalTools.mockReturnValue(25);
});

// =============================================================================
// classifySessionOutcome (tested indirectly via record written to JSONL)
// =============================================================================

describe('memory-capture', () => {
  describe('classifySessionOutcome — question', () => {
    test('returns "question" when last_assistant_message ends with ?', () => {
      const input = createHookInput({ last_assistant_message: 'Would you like to proceed?' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('question');
    });

    test('returns "question" for message ending with ? after trailing whitespace trimmed', () => {
      const input = createHookInput({ last_assistant_message: 'Should I fix it?  ' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('question');
    });
  });

  describe('classifySessionOutcome — code', () => {
    test('returns "code" when last_assistant_message contains triple backticks', () => {
      const input = createHookInput({ last_assistant_message: 'Here is the fix:\n```ts\nconst x = 1;\n```' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('code');
    });

    test('returns "code" even when message also ends with ? (code check runs second)', () => {
      // endsWith('?') is checked first, so a message ending with ? wins over code
      // This documents the priority order
      const input = createHookInput({ last_assistant_message: 'Does this work?\n```js\nconsole.log(1)\n```' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      // ends with backtick block, not '?' after trimEnd — so 'code' wins
      expect(record.session_outcome).toBe('code');
    });
  });

  describe('classifySessionOutcome — summary', () => {
    test('returns "summary" when message contains "completed"', () => {
      const input = createHookInput({ last_assistant_message: 'I completed the task.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('returns "summary" when message contains "done"', () => {
      const input = createHookInput({ last_assistant_message: 'All tests are done.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('returns "summary" when message contains "fixed"', () => {
      const input = createHookInput({ last_assistant_message: 'The bug has been fixed.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('returns "summary" when message contains "implemented"', () => {
      const input = createHookInput({ last_assistant_message: 'I implemented the feature.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('returns "summary" when message contains "finished"', () => {
      const input = createHookInput({ last_assistant_message: 'The refactor is finished.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('returns "summary" when message contains "summary"', () => {
      const input = createHookInput({ last_assistant_message: 'Here is a summary of changes.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });

    test('summary match is case-insensitive', () => {
      const input = createHookInput({ last_assistant_message: 'COMPLETED the migration.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('summary');
    });
  });

  describe('classifySessionOutcome — unknown', () => {
    test('returns "unknown" for a generic message', () => {
      const input = createHookInput({ last_assistant_message: 'The deployment target is production.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('unknown');
    });

    test('returns "unknown" for an empty message', () => {
      const input = createHookInput({ last_assistant_message: '' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.session_outcome).toBe('unknown');
    });
  });

  // =============================================================================
  // JSONL record fields
  // =============================================================================

  describe('JSONL record fields', () => {
    test('added_dirs_count field appears in record (no added_dirs)', () => {
      const input = createHookInput();

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record).toHaveProperty('added_dirs_count', 0);
    });

    test('added_dirs_count reflects length of added_dirs array', () => {
      const input = createHookInput({ added_dirs: ['/dir/a', '/dir/b', '/dir/c'] });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record.added_dirs_count).toBe(3);
    });

    test('session_outcome field appears when last_assistant_message is provided', () => {
      const input = createHookInput({ last_assistant_message: 'All done.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record).toHaveProperty('session_outcome');
    });

    test('session_outcome field is absent when last_assistant_message is not provided', () => {
      const input = createHookInput(); // no last_assistant_message

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record).not.toHaveProperty('session_outcome');
    });

    test('last_assistant_message field appears in record when provided', () => {
      const input = createHookInput({ last_assistant_message: 'Short message.' });

      memoryCapture(input);

      const written = mockAppendFileSync.mock.calls[0]?.[1] as string;
      const record = JSON.parse(written.trim());
      expect(record).toHaveProperty('last_assistant_message', 'Short message.');
    });
  });

  // =============================================================================
  // Tool count threshold
  // =============================================================================

  describe('tool count threshold', () => {
    test('skips capture and returns silent success when totalTools < 20', () => {
      mockGetTotalTools.mockReturnValue(10);
      const input = createHookInput();

      const result = memoryCapture(input);

      expect(mockAppendFileSync).not.toHaveBeenCalled();
      expect(result).toEqual({ continue: true, suppressOutput: true });
    });

    test('captures and returns silent success when totalTools is exactly 20', () => {
      mockGetTotalTools.mockReturnValue(20);
      const input = createHookInput();

      memoryCapture(input);

      expect(mockAppendFileSync).toHaveBeenCalled();
    });

    test('nudges /ork:remember when totalTools > 50', () => {
      mockGetTotalTools.mockReturnValue(51);
      const input = createHookInput();

      const result = memoryCapture(input);

      expect(result.hookSpecificOutput?.additionalContext).toContain('/ork:remember');
    });

    test('does not nudge /ork:remember when totalTools == 50', () => {
      mockGetTotalTools.mockReturnValue(50);
      const input = createHookInput();

      const result = memoryCapture(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
    });
  });

  // =============================================================================
  // Memory dir creation
  // =============================================================================

  describe('memory directory creation', () => {
    test('creates memory dir when it does not exist', () => {
      mockExistsSync.mockImplementation((p) => {
        if (String(p).endsWith('.claude/memory')) return false;
        return false; // decisions.jsonl also doesn't exist
      });
      const input = createHookInput();

      memoryCapture(input);

      expect(mockMkdirSync).toHaveBeenCalledWith(
        '/home/testuser/.claude/memory',
        { recursive: true }
      );
    });
  });
});
