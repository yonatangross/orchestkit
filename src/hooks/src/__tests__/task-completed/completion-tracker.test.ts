// Generated by OrchestKit Claude Plugin
// Created: 2026-02-06

/**
 * Unit tests for completion-tracker TaskCompleted hook
 *
 * Tests the CC 2.1.33 TaskCompleted event handler that:
 * 1. Logs task completion metrics to JSONL
 * 2. Suggests verification for implementation tasks
 *
 * @since CC 2.1.33
 */

import { describe, test, expect, beforeEach, vi } from 'vitest';

// Mock dependencies before imports
vi.mock('../../lib/common.js', () => ({
  getProjectDir: vi.fn(() => '/test/project'),
}));

vi.mock('../../lib/event-logger.js', () => ({
  appendEventLog: vi.fn(),
}));

import { completionTracker } from '../../task-completed/completion-tracker.js';
import { getProjectDir } from '../../lib/common.js';
import { appendEventLog } from '../../lib/event-logger.js';
import type { HookInput } from '../../types.js';

// =============================================================================
// Helpers
// =============================================================================

function createTaskInput(overrides: Partial<HookInput> = {}): HookInput {
  return {
    tool_name: '',
    session_id: 'test-session-123',
    project_dir: '/test/project',
    tool_input: {},
    task_id: 'task-abc',
    task_subject: 'Fix authentication bug',
    task_status: 'completed',
    duration_ms: 5000,
    ...overrides,
  };
}

// =============================================================================
// Tests
// =============================================================================

describe('completion-tracker', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(getProjectDir).mockReturnValue('/test/project');
  });

  describe('basic behavior', () => {
    test('always returns continue: true', async () => {
      // Arrange
      const input = createTaskInput();

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.continue).toBe(true);
    });

    test('returns early when project dir is not available', async () => {
      // Arrange
      vi.mocked(getProjectDir).mockReturnValue('');
      const input = createTaskInput();

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(appendEventLog).not.toHaveBeenCalled();
    });
  });

  describe('event logging', () => {
    test('logs task completion to task-completions.jsonl', async () => {
      // Arrange
      const input = createTaskInput({
        task_id: 'task-123',
        task_subject: 'Refactor user service',
        task_status: 'completed',
        duration_ms: 12000,
        session_id: 'session-abc',
      });

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          event: 'task_completed',
          task_id: 'task-123',
          task_subject: 'Refactor user service',
          task_status: 'completed',
          duration_ms: 12000,
          session_id: 'session-abc',
        }),
      );
    });

    test('includes ISO timestamp in log entry', async () => {
      // Arrange
      const input = createTaskInput();

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          timestamp: expect.stringMatching(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/),
        }),
      );
    });

    test('defaults task_id to "unknown" when not provided', async () => {
      // Arrange
      const input = createTaskInput({ task_id: undefined });

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          task_id: 'unknown',
        }),
      );
    });

    test('defaults task_subject to empty string when not provided', async () => {
      // Arrange
      const input = createTaskInput({ task_subject: undefined });

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          task_subject: '',
        }),
      );
    });

    test('defaults task_status to "completed" when not provided', async () => {
      // Arrange
      const input = createTaskInput({ task_status: undefined });

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          task_status: 'completed',
        }),
      );
    });

    test('defaults duration_ms to 0 when not provided', async () => {
      // Arrange
      const input = createTaskInput({ duration_ms: undefined });

      // Act
      await completionTracker(input);

      // Assert
      expect(appendEventLog).toHaveBeenCalledWith(
        'task-completions.jsonl',
        expect.objectContaining({
          duration_ms: 0,
        }),
      );
    });
  });

  describe('implementation task detection', () => {
    test.each([
      ['implement user authentication flow'],
      ['Implement the new API endpoint'],
      ['refactor database connection pooling'],
      ['Refactor service layer to use repository pattern'],
      ['build notification microservice'],
      ['Build the admin dashboard'],
      ['migrate legacy codebase to TypeScript'],
      ['Migrate database from MySQL to PostgreSQL'],
    ])('suggests verification for implementation task: "%s"', async (subject) => {
      // Arrange
      const input = createTaskInput({
        task_subject: subject,
        task_status: 'completed',
        duration_ms: 15000,
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput).toBeDefined();
      expect(result.hookSpecificOutput?.additionalContext).toContain(
        'Consider running tests to verify',
      );
    });

    test.each([
      ['Fix typo in docs'],
      ['Update README'],
      ['Add comments to code'],
      ['Read file content'],
      ['review PR changes'],
    ])('does NOT suggest verification for non-implementation task: "%s"', async (subject) => {
      // Arrange
      const input = createTaskInput({
        task_subject: subject,
        task_status: 'completed',
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput).toBeUndefined();
    });

    test('does not suggest verification when task status is not completed', async () => {
      // Arrange
      const input = createTaskInput({
        task_subject: 'implement user auth flow',
        task_status: 'in_progress',
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput).toBeUndefined();
    });

    test('requires minimum 5 chars after keyword to avoid false positives', async () => {
      // Arrange - "build" alone is only 5 chars, need 5+ after keyword
      const input = createTaskInput({
        task_subject: 'build',  // Too short after keyword
        task_status: 'completed',
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput).toBeUndefined();
    });

    test('includes duration in seconds in verification message', async () => {
      // Arrange
      const input = createTaskInput({
        task_subject: 'implement new feature endpoint handler',
        task_status: 'completed',
        duration_ms: 45000,
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput?.additionalContext).toContain('45s');
    });

    test('includes task subject in verification message', async () => {
      // Arrange
      const input = createTaskInput({
        task_subject: 'refactor the payment service module',
        task_status: 'completed',
        duration_ms: 20000,
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.hookSpecificOutput?.additionalContext).toContain(
        'refactor the payment service module',
      );
    });
  });

  describe('edge cases', () => {
    test('handles zero duration gracefully', async () => {
      // Arrange
      const input = createTaskInput({
        task_subject: 'implement zero-duration task handler',
        task_status: 'completed',
        duration_ms: 0,
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.hookSpecificOutput?.additionalContext).toContain('0s');
    });

    test('handles very long task subject', async () => {
      // Arrange
      const longSubject = 'implement ' + 'a'.repeat(500);
      const input = createTaskInput({
        task_subject: longSubject,
        task_status: 'completed',
      });

      // Act
      const result = await completionTracker(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.hookSpecificOutput).toBeDefined();
    });
  });
});
