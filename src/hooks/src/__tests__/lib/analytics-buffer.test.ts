// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * Tests for Analytics Write Buffer
 * Issue #688: Buffer analytics writes and flush on process exit
 *
 * Validates:
 * - bufferWrite queues entries without writing to disk
 * - flush writes all buffered entries grouped by file path
 * - flush is idempotent (no-op when empty or already flushing)
 * - pendingCount reflects buffer state
 * - _resetForTesting clears buffer
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';

// Override global setup mock â€” test the real analytics-buffer module
vi.unmock('../../lib/analytics-buffer.js');

vi.mock('node:fs', async () => {
  const actual = await vi.importActual('node:fs');
  return {
    ...actual,
    appendFileSync: vi.fn(),
    mkdirSync: vi.fn(),
  };
});

import { appendFileSync, mkdirSync } from 'node:fs';
import { bufferWrite, flush, pendingCount, _resetForTesting } from '../../lib/analytics-buffer.js';

describe('analytics-buffer', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    _resetForTesting();
  });

  describe('bufferWrite', () => {
    it('queues entries without writing to disk', () => {
      bufferWrite('/tmp/test.log', 'line1\n');
      expect(appendFileSync).not.toHaveBeenCalled();
      expect(pendingCount()).toBe(1);
    });

    it('accumulates multiple entries', () => {
      bufferWrite('/tmp/a.log', 'a1\n');
      bufferWrite('/tmp/b.log', 'b1\n');
      bufferWrite('/tmp/a.log', 'a2\n');
      expect(pendingCount()).toBe(3);
      expect(appendFileSync).not.toHaveBeenCalled();
    });
  });

  describe('flush', () => {
    it('writes all buffered entries grouped by file path', () => {
      bufferWrite('/tmp/a.log', 'a1\n');
      bufferWrite('/tmp/b.log', 'b1\n');
      bufferWrite('/tmp/a.log', 'a2\n');

      flush();

      expect(mkdirSync).toHaveBeenCalledTimes(2);
      expect(appendFileSync).toHaveBeenCalledTimes(2);

      // Entries for /tmp/a.log are concatenated
      expect(appendFileSync).toHaveBeenCalledWith('/tmp/a.log', 'a1\na2\n');
      expect(appendFileSync).toHaveBeenCalledWith('/tmp/b.log', 'b1\n');
    });

    it('clears buffer after flush', () => {
      bufferWrite('/tmp/test.log', 'data\n');
      flush();
      expect(pendingCount()).toBe(0);
    });

    it('is no-op when buffer is empty', () => {
      flush();
      expect(appendFileSync).not.toHaveBeenCalled();
      expect(mkdirSync).not.toHaveBeenCalled();
    });

    it('handles write errors gracefully', () => {
      vi.mocked(appendFileSync).mockImplementation(() => {
        throw new Error('disk full');
      });

      bufferWrite('/tmp/test.log', 'data\n');

      // Should not throw
      expect(() => flush()).not.toThrow();
      expect(pendingCount()).toBe(0);
    });

    it('handles mkdirSync errors gracefully', () => {
      vi.mocked(mkdirSync).mockImplementation(() => {
        throw new Error('permission denied');
      });

      bufferWrite('/tmp/test.log', 'data\n');
      expect(() => flush()).not.toThrow();
    });

    it('creates parent directories with recursive option', () => {
      bufferWrite('/deep/nested/dir/file.log', 'content\n');
      flush();

      expect(mkdirSync).toHaveBeenCalledWith('/deep/nested/dir', { recursive: true });
    });
  });

  describe('pendingCount', () => {
    it('returns 0 when empty', () => {
      expect(pendingCount()).toBe(0);
    });

    it('reflects buffer size', () => {
      bufferWrite('/tmp/a.log', 'x');
      bufferWrite('/tmp/b.log', 'y');
      expect(pendingCount()).toBe(2);
    });
  });

  describe('_resetForTesting', () => {
    it('clears buffer without writing', () => {
      bufferWrite('/tmp/test.log', 'data\n');
      _resetForTesting();
      expect(pendingCount()).toBe(0);
      expect(appendFileSync).not.toHaveBeenCalled();
    });
  });
});
