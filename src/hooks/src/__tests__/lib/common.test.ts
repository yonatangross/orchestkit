// Generated by OrchestKit Claude Plugin
// Created: 2026-02-12

/**
 * Unit tests for common.ts utilities
 *
 * Tests outputStderrWarning (CC 2.1.39) and fnv1aHash/writeRulesFile (token-reduction)
 */

import { describe, test, expect, vi, beforeEach } from 'vitest';
import { fnv1aHash } from '../../lib/common.js';

describe('outputStderrWarning', () => {
  let mockExit: ReturnType<typeof vi.spyOn>;
  let mockStderrWrite: ReturnType<typeof vi.spyOn>;

  beforeEach(() => {
    mockExit = vi.spyOn(process, 'exit').mockImplementation((() => {}) as never);
    mockStderrWrite = vi.spyOn(process.stderr, 'write').mockImplementation(() => true);
  });

  test('writes warning message to stderr with newline', async () => {
    // Dynamic import to avoid hoisting issues with mocks
    const { outputStderrWarning } = await import('../../lib/common.js');

    // Act
    outputStderrWarning('Something is deprecated');

    // Assert
    expect(mockStderrWrite).toHaveBeenCalledWith('\u26a0 Something is deprecated\n');
  });

  test('exits with code 2', async () => {
    const { outputStderrWarning } = await import('../../lib/common.js');

    // Act
    outputStderrWarning('Test warning');

    // Assert
    expect(mockExit).toHaveBeenCalledWith(2);
  });

  test('calls stderr.write before process.exit', async () => {
    const { outputStderrWarning } = await import('../../lib/common.js');

    const callOrder: string[] = [];
    mockStderrWrite.mockImplementation(() => {
      callOrder.push('stderr');
      return true;
    });
    mockExit.mockImplementation((() => {
      callOrder.push('exit');
    }) as never);

    // Act
    outputStderrWarning('Order test');

    // Assert
    expect(callOrder).toEqual(['stderr', 'exit']);
  });
});

describe('fnv1aHash', () => {
  test('returns consistent 8-char hex string', () => {
    const hash = fnv1aHash('hello world');
    expect(hash).toMatch(/^[0-9a-f]{8}$/);
    expect(fnv1aHash('hello world')).toBe(hash);
  });

  test('different inputs produce different hashes', () => {
    expect(fnv1aHash('hello')).not.toBe(fnv1aHash('world'));
  });

  test('empty string produces valid hash', () => {
    const hash = fnv1aHash('');
    expect(hash).toMatch(/^[0-9a-f]{8}$/);
  });

  test('handles unicode content', () => {
    const hash = fnv1aHash('Hello \u4e16\u754c');
    expect(hash).toMatch(/^[0-9a-f]{8}$/);
  });
});
