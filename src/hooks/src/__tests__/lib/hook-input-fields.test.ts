// Generated by OrchestKit Claude Plugin
// Created: 2026-02-19

/**
 * Validates HookInput field contracts for CC 2.1.47+
 *
 * Confirms:
 * 1. HookInput includes the `added_dirs` field (CC 2.1.47+)
 * 2. `added_dirs` is typed as optional string[]
 * 3. No hook source files reference `enabledPlugins` (it is CC-internal, not a hook field)
 */

import { describe, it, expect } from 'vitest';
import { readFileSync, readdirSync, statSync } from 'node:fs';
import { join, resolve } from 'node:path';
import type { HookInput } from '../../types.js';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Recursively collect all .ts source files under a directory. */
function collectTsFiles(dir: string): string[] {
  const entries = readdirSync(dir).map((e) => ({ name: e, full: join(dir, e) }));
  const subdirFiles = entries
    .filter((e) => statSync(e.full).isDirectory())
    .flatMap((e) => collectTsFiles(e.full));
  const localFiles = entries.filter((e) => e.name.endsWith('.ts')).map((e) => e.full);
  return [...localFiles, ...subdirFiles];
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

describe('HookInput field contracts (CC 2.1.47+)', () => {
  describe('added_dirs field', () => {
    it('accepts undefined (field is optional)', () => {
      const input: HookInput = {
        tool_name: 'Bash',
        session_id: 'test-session',
        tool_input: { command: 'echo hello' },
      };
      expect(input.added_dirs).toBeUndefined();
    });

    it('accepts a string array value', () => {
      const input: HookInput = {
        tool_name: 'Bash',
        session_id: 'test-session',
        tool_input: { command: 'echo hello' },
        added_dirs: ['/workspace/frontend', '/workspace/backend'],
      };
      expect(Array.isArray(input.added_dirs)).toBe(true);
      expect(input.added_dirs).toHaveLength(2);
      expect(input.added_dirs?.[0]).toBe('/workspace/frontend');
    });

    it('accepts an empty array', () => {
      const input: HookInput = {
        tool_name: 'Bash',
        session_id: 'test-session',
        tool_input: {},
        added_dirs: [],
      };
      expect(input.added_dirs).toEqual([]);
    });

    it('each element is a string path', () => {
      const dirs = ['/home/user/project-a', '/tmp/scratch'];
      const input: HookInput = {
        tool_name: 'Read',
        session_id: 'test-session',
        tool_input: { file_path: '/some/file' },
        added_dirs: dirs,
      };
      input.added_dirs?.forEach((d) => expect(typeof d).toBe('string'));
    });
  });

  describe('enabledPlugins is NOT a hook field', () => {
    const hooksSourceDir = resolve(
      new URL(import.meta.url).pathname,
      '../../../..' // up from __tests__/lib â†’ src/hooks/src
    );

    it('no hook source file references enabledPlugins', () => {
      const tsFiles = collectTsFiles(hooksSourceDir).filter(
        // Exclude the test files themselves
        (f) => !f.includes('__tests__')
      );

      const offenders: string[] = [];
      for (const file of tsFiles) {
        const content = readFileSync(file, 'utf-8');
        if (content.includes('enabledPlugins')) {
          offenders.push(file);
        }
      }

      expect(offenders).toEqual([]);
    });

    it('HookInput type does not expose an enabledPlugins property at runtime', () => {
      // Construct a full HookInput and verify enabledPlugins is not a key
      const input: HookInput = {
        tool_name: 'Bash',
        session_id: 'test-session',
        tool_input: {},
        added_dirs: ['/some/dir'],
      };
      expect(Object.prototype.hasOwnProperty.call(input, 'enabledPlugins')).toBe(false);
    });
  });
});
