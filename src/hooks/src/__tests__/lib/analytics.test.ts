// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Tests for Cross-Project Analytics
 * Issue #459: Local Cross-Project Analytics System
 *
 * Validates:
 * - appendAnalytics creates dir and writes JSONL
 * - hashProject returns 12-char hex, is deterministic, and is irreversible
 * - getTeamContext extracts team from env vars
 * - rotateIfNeeded renames files over threshold
 * - Handles write errors gracefully (no throw)
 * - Doesn't write PII (no raw paths in output)
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

vi.mock('node:fs', async () => {
  const actual = await vi.importActual('node:fs');
  return {
    ...actual,
    appendFileSync: vi.fn(),
    mkdirSync: vi.fn(),
    statSync: vi.fn(() => ({ size: 100 })),
    renameSync: vi.fn(),
  };
});

vi.mock('../../lib/paths.js', () => ({
  getHomeDir: vi.fn(() => '/mock/home'),
  joinPath: (...args: string[]) => args.join('/'),
}));

import { appendFileSync, mkdirSync, statSync, renameSync } from 'node:fs';
import { hashProject, appendAnalytics, getTeamContext, rotateIfNeeded } from '../../lib/analytics.js';

describe('analytics', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    vi.clearAllMocks();
    process.env = { ...originalEnv };
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('hashProject', () => {
    it('returns a 12-character hex string', () => {
      const hash = hashProject('/Users/alice/projects/my-app');
      expect(hash).toMatch(/^[0-9a-f]{12}$/);
    });

    it('is deterministic â€” same input produces same output', () => {
      const path = '/Users/bob/code/secret-project';
      expect(hashProject(path)).toBe(hashProject(path));
    });

    it('produces different hashes for different paths', () => {
      const hash1 = hashProject('/project/a');
      const hash2 = hashProject('/project/b');
      expect(hash1).not.toBe(hash2);
    });

    it('does not contain the original path', () => {
      const path = '/Users/alice/projects/my-app';
      const hash = hashProject(path);
      expect(hash).not.toContain('alice');
      expect(hash).not.toContain('my-app');
      expect(hash).not.toContain('/');
    });

    it('handles empty string input', () => {
      const hash = hashProject('');
      expect(hash).toMatch(/^[0-9a-f]{12}$/);
    });
  });

  describe('getTeamContext', () => {
    it('returns team name when CLAUDE_CODE_TEAM_NAME is set', () => {
      process.env.CLAUDE_CODE_TEAM_NAME = 'my-swarm';
      expect(getTeamContext()).toEqual({ team: 'my-swarm' });
    });

    it('returns undefined when CLAUDE_CODE_TEAM_NAME is not set', () => {
      delete process.env.CLAUDE_CODE_TEAM_NAME;
      expect(getTeamContext()).toBeUndefined();
    });

    it('returns undefined when CLAUDE_CODE_TEAM_NAME is empty', () => {
      process.env.CLAUDE_CODE_TEAM_NAME = '';
      expect(getTeamContext()).toBeUndefined();
    });
  });

  describe('rotateIfNeeded', () => {
    it('does not rotate files under the threshold', () => {
      (statSync as ReturnType<typeof vi.fn>).mockReturnValueOnce({ size: 100 });
      rotateIfNeeded('/mock/path/agent-usage.jsonl');
      expect(renameSync).not.toHaveBeenCalled();
    });

    it('rotates files over the threshold', () => {
      (statSync as ReturnType<typeof vi.fn>).mockReturnValueOnce({ size: 11_000_000 });
      rotateIfNeeded('/mock/path/agent-usage.jsonl');
      expect(renameSync).toHaveBeenCalledWith(
        '/mock/path/agent-usage.jsonl',
        expect.stringMatching(/\/mock\/path\/agent-usage\.\d{4}-\d{2}\.jsonl$/),
      );
    });

    it('does not throw when file does not exist', () => {
      (statSync as ReturnType<typeof vi.fn>).mockImplementationOnce(() => {
        throw new Error('ENOENT');
      });
      expect(() => rotateIfNeeded('/mock/path/missing.jsonl')).not.toThrow();
    });

    it('respects custom maxBytes threshold', () => {
      (statSync as ReturnType<typeof vi.fn>).mockReturnValueOnce({ size: 500 });
      rotateIfNeeded('/mock/path/agent-usage.jsonl', 400);
      expect(renameSync).toHaveBeenCalled();
    });
  });

  describe('appendAnalytics', () => {
    it('creates the analytics directory and appends JSONL', () => {
      appendAnalytics('agent-usage.jsonl', { agent: 'test-agent', duration_ms: 100 });

      expect(mkdirSync).toHaveBeenCalledWith(
        '/mock/home/.claude/analytics',
        { recursive: true },
      );
      expect(appendFileSync).toHaveBeenCalledWith(
        '/mock/home/.claude/analytics/agent-usage.jsonl',
        expect.stringContaining('"agent":"test-agent"'),
      );
    });

    it('writes valid JSONL (line ends with newline)', () => {
      appendAnalytics('test.jsonl', { key: 'value' });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      expect(written.endsWith('\n')).toBe(true);
      expect(() => JSON.parse(written.trim())).not.toThrow();
    });

    it('does not throw when mkdirSync fails', () => {
      (mkdirSync as ReturnType<typeof vi.fn>).mockImplementationOnce(() => {
        throw new Error('EACCES');
      });

      expect(() => appendAnalytics('test.jsonl', { key: 'value' })).not.toThrow();
    });

    it('does not throw when appendFileSync fails', () => {
      (appendFileSync as ReturnType<typeof vi.fn>).mockImplementationOnce(() => {
        throw new Error('ENOSPC');
      });

      expect(() => appendAnalytics('test.jsonl', { key: 'value' })).not.toThrow();
    });

    it('does not include raw paths in written data', () => {
      const projectPath = '/Users/secret-user/private-project';
      appendAnalytics('test.jsonl', {
        pid: hashProject(projectPath),
        agent: 'backend-architect',
      });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      expect(written).not.toContain('secret-user');
      expect(written).not.toContain('private-project');
      expect(written).not.toContain(projectPath);
    });

    it('includes team field when team context is present', () => {
      process.env.CLAUDE_CODE_TEAM_NAME = 'test-swarm';
      appendAnalytics('agent-usage.jsonl', {
        agent: 'test-agent',
        ...getTeamContext(),
      });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      const parsed = JSON.parse(written.trim());
      expect(parsed.team).toBe('test-swarm');
    });

    it('omits team field when not in team context', () => {
      delete process.env.CLAUDE_CODE_TEAM_NAME;
      appendAnalytics('agent-usage.jsonl', {
        agent: 'test-agent',
        ...getTeamContext(),
      });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      const parsed = JSON.parse(written.trim());
      expect(parsed.team).toBeUndefined();
    });

    it('calls rotateIfNeeded before writing', () => {
      // statSync is mocked to return small file by default (100 bytes)
      appendAnalytics('agent-usage.jsonl', { agent: 'test' });
      // statSync should have been called (rotation check)
      expect(statSync).toHaveBeenCalled();
    });
  });
});
