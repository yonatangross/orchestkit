// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Tests for Cross-Project Analytics
 * Issue #459: Local Cross-Project Analytics System
 *
 * Validates:
 * - appendAnalytics creates dir and writes JSONL
 * - hashProject returns 12-char hex, is deterministic, and is irreversible
 * - Handles write errors gracefully (no throw)
 * - Doesn't write PII (no raw paths in output)
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';

vi.mock('node:fs', async () => {
  const actual = await vi.importActual('node:fs');
  return {
    ...actual,
    appendFileSync: vi.fn(),
    mkdirSync: vi.fn(),
  };
});

vi.mock('../../lib/paths.js', () => ({
  getHomeDir: vi.fn(() => '/mock/home'),
  joinPath: (...args: string[]) => args.join('/'),
}));

import { appendFileSync, mkdirSync } from 'node:fs';
import { hashProject, appendAnalytics } from '../../lib/analytics.js';

describe('analytics', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('hashProject', () => {
    it('returns a 12-character hex string', () => {
      const hash = hashProject('/Users/alice/projects/my-app');
      expect(hash).toMatch(/^[0-9a-f]{12}$/);
    });

    it('is deterministic â€” same input produces same output', () => {
      const path = '/Users/bob/code/secret-project';
      expect(hashProject(path)).toBe(hashProject(path));
    });

    it('produces different hashes for different paths', () => {
      const hash1 = hashProject('/project/a');
      const hash2 = hashProject('/project/b');
      expect(hash1).not.toBe(hash2);
    });

    it('does not contain the original path', () => {
      const path = '/Users/alice/projects/my-app';
      const hash = hashProject(path);
      expect(hash).not.toContain('alice');
      expect(hash).not.toContain('my-app');
      expect(hash).not.toContain('/');
    });

    it('handles empty string input', () => {
      const hash = hashProject('');
      expect(hash).toMatch(/^[0-9a-f]{12}$/);
    });
  });

  describe('appendAnalytics', () => {
    it('creates the analytics directory and appends JSONL', () => {
      appendAnalytics('agent-usage.jsonl', { agent: 'test-agent', duration_ms: 100 });

      expect(mkdirSync).toHaveBeenCalledWith(
        '/mock/home/.claude/analytics',
        { recursive: true },
      );
      expect(appendFileSync).toHaveBeenCalledWith(
        '/mock/home/.claude/analytics/agent-usage.jsonl',
        expect.stringContaining('"agent":"test-agent"'),
      );
    });

    it('writes valid JSONL (line ends with newline)', () => {
      appendAnalytics('test.jsonl', { key: 'value' });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      expect(written.endsWith('\n')).toBe(true);
      expect(() => JSON.parse(written.trim())).not.toThrow();
    });

    it('does not throw when mkdirSync fails', () => {
      (mkdirSync as ReturnType<typeof vi.fn>).mockImplementationOnce(() => {
        throw new Error('EACCES');
      });

      expect(() => appendAnalytics('test.jsonl', { key: 'value' })).not.toThrow();
    });

    it('does not throw when appendFileSync fails', () => {
      (appendFileSync as ReturnType<typeof vi.fn>).mockImplementationOnce(() => {
        throw new Error('ENOSPC');
      });

      expect(() => appendAnalytics('test.jsonl', { key: 'value' })).not.toThrow();
    });

    it('does not include raw paths in written data', () => {
      const projectPath = '/Users/secret-user/private-project';
      appendAnalytics('test.jsonl', {
        pid: hashProject(projectPath),
        agent: 'backend-architect',
      });

      const written = (appendFileSync as ReturnType<typeof vi.fn>).mock.calls[0][1] as string;
      expect(written).not.toContain('secret-user');
      expect(written).not.toContain('private-project');
      expect(written).not.toContain(projectPath);
    });
  });
});
