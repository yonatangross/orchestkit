// Generated by OrchestKit Claude Plugin
// Created: 2026-02-06

/**
 * Unit tests for event-logger shared utility
 *
 * Tests the appendEventLog function that writes structured JSONL
 * entries to .claude/logs/ for lifecycle hooks.
 */

import { describe, test, expect, beforeEach, vi } from 'vitest';

// Mock dependencies before imports
vi.mock('node:fs', () => ({
  existsSync: vi.fn(() => true),
  writeFileSync: vi.fn(),
  mkdirSync: vi.fn(),
}));

vi.mock('../../lib/common.js', () => ({
  getProjectDir: vi.fn(() => '/test/project'),
}));

import { appendEventLog } from '../../lib/event-logger.js';
import { getProjectDir } from '../../lib/common.js';
import { existsSync, writeFileSync, mkdirSync } from 'node:fs';

// =============================================================================
// Tests
// =============================================================================

describe('appendEventLog', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(getProjectDir).mockReturnValue('/test/project');
    vi.mocked(existsSync).mockReturnValue(true);
  });

  describe('basic functionality', () => {
    test('writes JSONL entry to specified file', () => {
      // Arrange
      const entry = { event: 'test', data: 'value' };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      expect(writeFileSync).toHaveBeenCalledWith(
        '/test/project/.claude/logs/test.jsonl',
        expect.stringContaining('"event":"test"'),
        { flag: 'a' },
      );
    });

    test('appends newline after JSON entry', () => {
      // Arrange
      const entry = { key: 'val' };

      // Act
      appendEventLog('output.jsonl', entry);

      // Assert
      const writtenContent = vi.mocked(writeFileSync).mock.calls[0][1] as string;
      expect(writtenContent.endsWith('\n')).toBe(true);
    });

    test('uses append flag for file writing', () => {
      // Arrange
      const entry = { test: true };

      // Act
      appendEventLog('events.jsonl', entry);

      // Assert
      expect(writeFileSync).toHaveBeenCalledWith(
        expect.any(String),
        expect.any(String),
        { flag: 'a' },
      );
    });

    test('writes valid JSON that can be parsed back', () => {
      // Arrange
      const entry = {
        timestamp: '2026-02-06T12:00:00.000Z',
        event: 'task_completed',
        nested: { value: 42 },
      };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      const writtenContent = vi.mocked(writeFileSync).mock.calls[0][1] as string;
      const parsed = JSON.parse(writtenContent.trim());
      expect(parsed).toEqual(entry);
    });
  });

  describe('directory creation', () => {
    test('creates logs directory when it does not exist', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(false);
      const entry = { test: true };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      expect(mkdirSync).toHaveBeenCalledWith(
        '/test/project/.claude/logs',
        { recursive: true },
      );
    });

    test('does not create directory when it already exists', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(true);
      const entry = { test: true };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      expect(mkdirSync).not.toHaveBeenCalled();
    });
  });

  describe('project dir handling', () => {
    test('does nothing when project dir is empty', () => {
      // Arrange
      vi.mocked(getProjectDir).mockReturnValue('');
      const entry = { test: true };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      expect(writeFileSync).not.toHaveBeenCalled();
    });

    test('does nothing when project dir is falsy', () => {
      // Arrange
      vi.mocked(getProjectDir).mockReturnValue(undefined as unknown as string);
      const entry = { test: true };

      // Act
      appendEventLog('test.jsonl', entry);

      // Assert
      expect(writeFileSync).not.toHaveBeenCalled();
    });
  });

  describe('error handling', () => {
    test('silently ignores write failures', () => {
      // Arrange
      vi.mocked(writeFileSync).mockImplementation(() => {
        throw new Error('EACCES: permission denied');
      });
      const entry = { test: true };

      // Act & Assert - should not throw
      expect(() => appendEventLog('test.jsonl', entry)).not.toThrow();
    });

    test('propagates mkdir failures (outside try/catch)', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(mkdirSync).mockImplementation(() => {
        throw new Error('EACCES');
      });
      const entry = { test: true };

      // Act & Assert
      // mkdirSync is outside the try/catch block in the implementation,
      // so mkdir failures will propagate. Only writeFileSync errors are caught.
      expect(() => appendEventLog('test.jsonl', entry)).toThrow('EACCES');
    });
  });

  describe('file path construction', () => {
    test('places log files under .claude/logs/', () => {
      // Arrange
      vi.mocked(getProjectDir).mockReturnValue('/my/project');
      const entry = { test: true };

      // Act
      appendEventLog('custom-log.jsonl', entry);

      // Assert
      expect(writeFileSync).toHaveBeenCalledWith(
        '/my/project/.claude/logs/custom-log.jsonl',
        expect.any(String),
        expect.any(Object),
      );
    });
  });
});
