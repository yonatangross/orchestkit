// Generated by OrchestKit Claude Plugin
// Created: 2026-02-19

/**
 * Unit tests for monorepo-detector setup hook
 * Tests added_dirs skip logic and monorepo detection.
 */

import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';

// Mock node:fs
vi.mock('node:fs', () => ({
  existsSync: vi.fn(),
  readdirSync: vi.fn(),
}));

// Mock common utilities
vi.mock('../../lib/common.js', () => ({
  logHook: vi.fn(),
  outputSilentSuccess: vi.fn(() => ({ continue: true, suppressOutput: true })),
  outputWithContext: vi.fn((msg: string) => ({
    continue: true,
    suppressOutput: false,
    hookSpecificOutput: { additionalContext: msg },
  })),
  getProjectDir: vi.fn(() => '/test/project'),
}));

import { monorepoDetector } from '../../setup/monorepo-detector.js';
import { existsSync, readdirSync } from 'node:fs';
import type { HookInput } from '../../types.js';

const mockExistsSync = vi.mocked(existsSync);
const mockReaddirSync = vi.mocked(readdirSync);

function createHookInput(overrides: Partial<HookInput> = {}): HookInput {
  return {
    tool_name: '',
    session_id: 'test-session-mono',
    project_dir: '/test/project',
    tool_input: {},
    ...overrides,
  };
}

beforeEach(() => {
  vi.clearAllMocks();
  // Default: no monorepo indicators, no nested packages
  mockExistsSync.mockReturnValue(false);
  mockReaddirSync.mockReturnValue([]);
  delete process.env.CLAUDE_CODE_ADDITIONAL_DIRECTORIES_CLAUDE_MD;
});

afterEach(() => {
  delete process.env.CLAUDE_CODE_ADDITIONAL_DIRECTORIES_CLAUDE_MD;
});

// =============================================================================
// CC 2.1.47: added_dirs skip
// =============================================================================

describe('monorepo-detector', () => {
  describe('CC 2.1.47 added_dirs skip', () => {
    test('returns silent success immediately when added_dirs has entries', () => {
      const input = createHookInput({ added_dirs: ['/some/other/dir'] });

      const result = monorepoDetector(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
      // Should not have called readdirSync — skipped detection entirely
      expect(mockReaddirSync).not.toHaveBeenCalled();
    });

    test('returns silent success when added_dirs has multiple entries', () => {
      const input = createHookInput({ added_dirs: ['/dir/a', '/dir/b', '/dir/c'] });

      const result = monorepoDetector(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
      expect(mockReaddirSync).not.toHaveBeenCalled();
    });

    test('still runs detection when added_dirs is empty array', () => {
      const input = createHookInput({ added_dirs: [] });

      monorepoDetector(input);

      // Detection proceeds — readdirSync is called to check for nested packages
      expect(mockReaddirSync).toHaveBeenCalled();
    });

    test('still runs detection when added_dirs is undefined', () => {
      const input = createHookInput(); // no added_dirs field

      monorepoDetector(input);

      expect(mockReaddirSync).toHaveBeenCalled();
    });
  });

  // =============================================================================
  // Monorepo detection via indicator files
  // =============================================================================

  describe('monorepo detection — indicator files', () => {
    test('detects monorepo via pnpm-workspace.yaml', () => {
      mockExistsSync.mockImplementation((p) => String(p).endsWith('pnpm-workspace.yaml'));
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result.continue).toBe(true);
      // With a monorepo indicator, outputWithContext is called — not silent
      expect(result.suppressOutput).toBeFalsy();
    });

    test('detects monorepo via turbo.json', () => {
      mockExistsSync.mockImplementation((p) => String(p).endsWith('turbo.json'));
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBeFalsy();
    });

    test('detects monorepo via nx.json', () => {
      mockExistsSync.mockImplementation((p) => String(p).endsWith('nx.json'));
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBeFalsy();
    });
  });

  // =============================================================================
  // Monorepo detection via nested package.json (>=3)
  // =============================================================================

  describe('monorepo detection — nested packages', () => {
    test('detects monorepo when 3 or more nested package.json files exist', () => {
      // Simulate 3 top-level subdirs each with package.json
      mockReaddirSync.mockReturnValue([
        { name: 'packages', isDirectory: () => true } as ReturnType<typeof readdirSync>[0],
        { name: 'apps', isDirectory: () => true } as ReturnType<typeof readdirSync>[0],
        { name: 'libs', isDirectory: () => true } as ReturnType<typeof readdirSync>[0],
      ]);
      mockExistsSync.mockImplementation((p) => {
        const s = String(p);
        return s.endsWith('/package.json');
      });
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBeFalsy();
    });

    test('does not detect monorepo when fewer than 3 nested package.json files', () => {
      // Only 2 top-level subdirs with package.json, no further nesting
      mockReaddirSync.mockImplementation((dir, _opts) => {
        // Top-level project dir: return 2 directories
        if (String(dir) === '/test/project') {
          return [
            { name: 'frontend', isDirectory: () => true } as ReturnType<typeof readdirSync>[0],
            { name: 'backend', isDirectory: () => true } as ReturnType<typeof readdirSync>[0],
          ];
        }
        // Sub-directories: return no children
        return [];
      });
      mockExistsSync.mockImplementation((p) => {
        const s = String(p);
        // frontend and backend each have package.json, but no deeper nesting
        return s === '/test/project/frontend/package.json' || s === '/test/project/backend/package.json';
      });
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
    });

    test('returns silent success when no nested packages and no indicator files', () => {
      mockReaddirSync.mockReturnValue([]);
      mockExistsSync.mockReturnValue(false);
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
    });
  });

  // =============================================================================
  // Env var short-circuit
  // =============================================================================

  describe('env var short-circuit', () => {
    test('returns silent success when CLAUDE_CODE_ADDITIONAL_DIRECTORIES_CLAUDE_MD is set', () => {
      process.env.CLAUDE_CODE_ADDITIONAL_DIRECTORIES_CLAUDE_MD = '1';
      const input = createHookInput();

      const result = monorepoDetector(input);

      expect(result).toEqual({ continue: true, suppressOutput: true });
    });
  });
});
