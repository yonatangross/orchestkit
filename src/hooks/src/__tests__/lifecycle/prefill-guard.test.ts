// Generated by OrchestKit Claude Plugin
// Created: 2026-02-06

/**
 * Unit tests for prefill-guard lifecycle hook
 *
 * Tests the Opus 4.6 breaking change guard that scans skills for:
 * 1. Prefilled assistant message patterns (return 400 on Opus 4.6)
 * 2. Deprecated output_format parameter (replaced by output_config.format)
 *
 * Version: 1.1.0 (Issue #325, #357)
 */

import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';

// Mock node:fs before import
vi.mock('node:fs', () => ({
  existsSync: vi.fn(() => false),
  readFileSync: vi.fn(() => ''),
  readdirSync: vi.fn(() => []),
  statSync: vi.fn(() => ({ isDirectory: () => true })),
}));

vi.mock('../../lib/common.js', () => ({
  logHook: vi.fn(),
  getPluginRoot: vi.fn(() => '/test/plugin'),
  outputSilentSuccess: vi.fn(() => ({ continue: true, suppressOutput: true })),
  outputWarning: vi.fn((msg: string) => ({
    continue: true,
    systemMessage: msg,
  })),
}));

import { prefillGuard } from '../../lifecycle/prefill-guard.js';
import { logHook, outputSilentSuccess, outputWarning } from '../../lib/common.js';
import { existsSync, readFileSync, readdirSync, statSync } from 'node:fs';
import type { HookInput } from '../../types.js';

// =============================================================================
// Helper
// =============================================================================

function createHookInput(): HookInput {
  return {
    tool_name: '',
    session_id: 'test-session',
    project_dir: '/test/project',
    tool_input: {},
  };
}

/**
 * Set up mocked filesystem with skill directories and content
 */
function setupSkills(skills: Record<string, string>) {
  const skillNames = Object.keys(skills);

  vi.mocked(existsSync).mockImplementation((p: unknown) => {
    const path = String(p);
    if (path.endsWith('/skills')) return true;
    for (const name of skillNames) {
      if (path.endsWith(`/${name}/SKILL.md`)) return true;
    }
    return false;
  });

  vi.mocked(readdirSync).mockReturnValue(
    skillNames as unknown as ReturnType<typeof readdirSync>,
  );

  vi.mocked(statSync).mockReturnValue({
    isDirectory: () => true,
  } as ReturnType<typeof statSync>);

  vi.mocked(readFileSync).mockImplementation((p: unknown) => {
    const path = String(p);
    for (const [name, content] of Object.entries(skills)) {
      if (path.includes(`/${name}/SKILL.md`)) return content;
    }
    return '';
  });
}

// =============================================================================
// Tests
// =============================================================================

describe('prefill-guard', () => {
  const originalModel = process.env.CLAUDE_MODEL;

  beforeEach(() => {
    vi.clearAllMocks();
    process.env.CLAUDE_MODEL = 'claude-opus-4-6';
  });

  afterEach(() => {
    if (originalModel !== undefined) {
      process.env.CLAUDE_MODEL = originalModel;
    } else {
      delete process.env.CLAUDE_MODEL;
    }
  });

  describe('model detection', () => {
    test('skips guard when not running on Opus model', () => {
      // Arrange
      process.env.CLAUDE_MODEL = 'claude-sonnet-4-20250514';
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(outputWarning).not.toHaveBeenCalled();
    });

    test('activates guard when CLAUDE_MODEL contains "opus"', () => {
      // Arrange
      process.env.CLAUDE_MODEL = 'claude-opus-4-6';
      setupSkills({});
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputSilentSuccess).toHaveBeenCalled();
    });

    test('activates guard for case-insensitive "Opus" match', () => {
      // Arrange
      process.env.CLAUDE_MODEL = 'Claude-Opus-4-6';
      setupSkills({});
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert - should not short-circuit
      expect(outputSilentSuccess).toHaveBeenCalled();
    });

    test('skips guard when CLAUDE_MODEL is empty', () => {
      // Arrange
      process.env.CLAUDE_MODEL = '';
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    test('skips guard when CLAUDE_MODEL is not set', () => {
      // Arrange
      delete process.env.CLAUDE_MODEL;
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });
  });

  describe('prefill pattern detection', () => {
    test('detects "prefill" keyword in skill content', () => {
      // Arrange
      setupSkills({
        'bad-skill': '# My Skill\n\nUse prefill to start the response.',
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('bad-skill'),
      );
    });

    test('detects "pre-fill" hyphenated form', () => {
      // Arrange
      setupSkills({
        'hyphen-skill': '# My Skill\n\nPre-fill the assistant response.',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('hyphen-skill'),
      );
    });

    test('detects assistant content pattern', () => {
      // Arrange
      setupSkills({
        'assistant-skill': '# My Skill\n\nassistant content: "Sure, I will"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('assistant-skill'),
      );
    });

    test('detects prefilled assistant message pattern', () => {
      // Arrange
      setupSkills({
        'prefilled-skill': '# My Skill\n\nUse a prefilled assistant message.',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('prefilled-skill'),
      );
    });

    test('returns silent success when no prefill patterns found', () => {
      // Arrange
      setupSkills({
        'clean-skill': '# Clean Skill\n\nNo deprecated patterns here.',
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(outputWarning).not.toHaveBeenCalled();
    });
  });

  describe('output_format deprecation detection (v1.1.0)', () => {
    test('detects output_format JSON key pattern', () => {
      // Arrange
      setupSkills({
        'format-skill': '# Skill\n\n"output_format": "json"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('format-skill'),
      );
    });

    test('detects output_format Python kwarg pattern', () => {
      // Arrange
      setupSkills({
        'python-skill': '# Skill\n\noutput_format="json"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('python-skill'),
      );
    });

    test('detects output_format with format values', () => {
      // Arrange
      setupSkills({
        'value-skill': '# Skill\n\nSet output_format to json for structured output.',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('value-skill'),
      );
    });

    test('excludes ElevenLabs third-party API references', () => {
      // Arrange
      setupSkills({
        'elevenlabs-skill': '# Audio\n\nElevenLabs API uses output_format="mp3_44100"',
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(outputWarning).not.toHaveBeenCalled();
    });

    test('excludes files with mp3 format references', () => {
      // Arrange
      setupSkills({
        'audio-skill': '# Audio\n\noutput_format="json"\nmp3_22050 format',
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(outputWarning).not.toHaveBeenCalled();
    });
  });

  describe('combined detection', () => {
    test('detects both prefill and output_format in same skill', () => {
      // Arrange
      setupSkills({
        'both-skill': '# Skill\n\nUse prefill.\n"output_format": "json"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('both-skill'),
      );
    });

    test('reports multiple affected skills', () => {
      // Arrange
      setupSkills({
        'skill-a': '# A\n\nUse prefill for responses.',
        'skill-b': '# B\n\n"output_format": "text"',
        'clean': '# C\n\nNo issues here.',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('2 skill(s)'),
      );
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('skill-a'),
      );
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('skill-b'),
      );
    });

    test('truncates affected skills list when more than 5', () => {
      // Arrange
      const skills: Record<string, string> = {};
      for (let i = 0; i < 7; i++) {
        skills[`skill-${i}`] = `# Skill ${i}\n\nUse prefill here.`;
      }
      setupSkills(skills);
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('7 skill(s)'),
      );
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('...'),
      );
    });
  });

  describe('warning message content', () => {
    test('includes migration guidance for prefilling', () => {
      // Arrange
      setupSkills({
        'prefill-skill': '# Skill\n\nUse prefill technique.',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('structured outputs instead of prefilling'),
      );
    });

    test('includes migration guidance for output_format', () => {
      // Arrange
      setupSkills({
        'format-skill': '# Skill\n\n"output_format": "json"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(outputWarning).toHaveBeenCalledWith(
        expect.stringContaining('output_config.format instead of output_format'),
      );
    });
  });

  describe('filesystem edge cases', () => {
    test('handles missing skills directory gracefully', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(false);
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    test('handles unreadable skill file gracefully', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(readdirSync).mockReturnValue(
        ['unreadable'] as unknown as ReturnType<typeof readdirSync>,
      );
      vi.mocked(statSync).mockReturnValue({
        isDirectory: () => true,
      } as ReturnType<typeof statSync>);
      vi.mocked(readFileSync).mockImplementation(() => {
        throw new Error('EACCES: permission denied');
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
    });

    test('handles non-directory entries in skills folder', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(readdirSync).mockReturnValue(
        ['file.txt'] as unknown as ReturnType<typeof readdirSync>,
      );
      vi.mocked(statSync).mockReturnValue({
        isDirectory: () => false,
      } as ReturnType<typeof statSync>);
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    test('handles statSync throwing for directory check', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(readdirSync).mockReturnValue(
        ['broken-dir'] as unknown as ReturnType<typeof readdirSync>,
      );
      vi.mocked(statSync).mockImplementation(() => {
        throw new Error('ENOENT');
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    test('handles readdirSync throwing', () => {
      // Arrange
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(readdirSync).mockImplementation(() => {
        throw new Error('EACCES');
      });
      const input = createHookInput();

      // Act
      const result = prefillGuard(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });
  });

  describe('logging', () => {
    test('logs when no patterns detected', () => {
      // Arrange
      setupSkills({ 'clean': '# Clean\n\nNothing deprecated.' });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(logHook).toHaveBeenCalledWith(
        'prefill-guard',
        'No prefilling patterns detected in skills',
      );
    });

    test('logs count of affected skills with warn level', () => {
      // Arrange
      setupSkills({
        'bad-a': '# A\n\nUse prefill.',
        'bad-b': '# B\n\n"output_format": "json"',
      });
      const input = createHookInput();

      // Act
      prefillGuard(input);

      // Assert
      expect(logHook).toHaveBeenCalledWith(
        'prefill-guard',
        expect.stringContaining('2 skills'),
        'warn',
      );
    });
  });
});
