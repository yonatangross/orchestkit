// Generated by OrchestKit Claude Plugin
// Created: 2026-02-15

/**
 * Unit tests for issue-context-injector hook
 * Tests GitHub issue context injection on subagent start
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { HookInput } from '../../types.js';

// Mock dependencies before imports
vi.mock('node:fs', () => ({
  existsSync: vi.fn(() => false),
  readFileSync: vi.fn(() => ''),
  writeFileSync: vi.fn(),
  statSync: vi.fn(() => ({ mtimeMs: Date.now() })),
  mkdirSync: vi.fn(),
}));

vi.mock('node:child_process', () => ({
  execFileSync: vi.fn(() => ''),
}));

vi.mock('../../lib/common.js', () => ({
  outputSilentSuccess: vi.fn(() => ({ continue: true, suppressOutput: true })),
  logHook: vi.fn(),
  getProjectDir: vi.fn(() => '/test/project'),
  getCachedBranch: vi.fn(() => 'main'),
}));

import { getCachedBranch } from '../../lib/common.js';
import { issueContextInjector } from '../../subagent-start/issue-context-injector.js';
import { existsSync, readFileSync, writeFileSync, statSync } from 'node:fs';
import { execFileSync } from 'node:child_process';

function createToolInput(): HookInput {
  return {
    tool_name: 'Task',
    session_id: 'test-session-123',
    project_dir: '/test/project',
    tool_input: {
      subagent_type: 'general-purpose',
      description: 'Test task',
    },
  };
}

describe('issue-context-injector', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  // -----------------------------------------------------------------------
  // 1. Non-issue branches
  // -----------------------------------------------------------------------

  describe('non-issue branches', () => {
    it('returns silent success when branch does not match issue pattern', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('main');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    it('returns silent success for dev branch', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('dev');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    it('returns silent success for feature branch without issue number', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('feature/add-auth');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });
  });

  // -----------------------------------------------------------------------
  // 2. Cache hit with issue title
  // -----------------------------------------------------------------------

  describe('cache hit scenarios', () => {
    it('injects context with issue title when cache hit', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-add-auth');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Add authentication module',
          body: 'Implement OAuth2 flow',
          labels: [],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.systemMessage).toContain('Working on GitHub Issue #123');
      expect(result.systemMessage).toContain('Add authentication module');
      expect(result.systemMessage).toContain('Reference #123 in all commits');
      expect(result.systemMessage).toContain("Use 'Closes #123' in PR description");
    });

    it('injects context with labels when available', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/456-bug-fix');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Fix memory leak',
          labels: [{ name: 'bug' }, { name: 'priority: high' }],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toContain('Working on GitHub Issue #456');
      expect(result.systemMessage).toContain('Fix memory leak');
      expect(result.systemMessage).toContain('Labels: bug, priority: high');
    });

    it('uses cached issue when cache is fresh (<5 min)', () => {
      // Arrange
      const freshTime = Date.now() - 2 * 60 * 1000; // 2 minutes ago
      vi.mocked(getCachedBranch).mockReturnValue('issue/789-feature');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: freshTime } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Add dark mode',
          labels: [],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toContain('Add dark mode');
      expect(execFileSync).not.toHaveBeenCalled(); // Should not fetch from gh
    });
  });

  // -----------------------------------------------------------------------
  // 3. Fallback to branch-name-only when gh fails
  // -----------------------------------------------------------------------

  describe('gh CLI fallback', () => {
    it('falls back to branch-name-only when gh fails', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-add-auth');
      vi.mocked(existsSync).mockReturnValue(false); // No cache
      vi.mocked(execFileSync).mockImplementation(() => {
        throw new Error('gh not installed');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.systemMessage).toContain('Working on GitHub Issue #123');
      expect(result.systemMessage).toContain('Reference #123 in all commits');
      expect(result.systemMessage).not.toContain('Labels:');
    });

    it('fetches from gh when cache is stale (>5 min)', () => {
      // Arrange
      const staleTime = Date.now() - 10 * 60 * 1000; // 10 minutes ago
      vi.mocked(getCachedBranch).mockReturnValue('issue/456-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: staleTime } as any);
      vi.mocked(execFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Fresh issue data',
          labels: [{ name: 'enhancement' }],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(execFileSync).toHaveBeenCalledWith(
        'gh',
        ['issue', 'view', '456', '--json', 'title,body,labels'],
        expect.objectContaining({
          cwd: '/test/project',
          encoding: 'utf8',
          timeout: 3000,
        })
      );
      expect(result.systemMessage).toContain('Fresh issue data');
      expect(result.systemMessage).toContain('Labels: enhancement');
    });
  });

  // -----------------------------------------------------------------------
  // 4. Branch pattern extraction
  // -----------------------------------------------------------------------

  describe('branch pattern extraction', () => {
    const patterns = [
      { branch: 'issue/123-desc', expectedIssue: '123' },
      { branch: 'fix/456-bug', expectedIssue: '456' },
      { branch: 'feat/789-thing', expectedIssue: '789' },
      { branch: 'bug/10-fix', expectedIssue: '10' },
      { branch: 'hotfix/11-patch', expectedIssue: '11' },
      { branch: 'feature/99-add', expectedIssue: '99' },
      { branch: '123-some-description', expectedIssue: '123' },
    ];

    it.each(patterns)('handles $branch pattern', ({ branch, expectedIssue }) => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue(branch);
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockImplementation(() => {
        throw new Error('gh fail');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toContain(`Working on GitHub Issue #${expectedIssue}`);
    });
  });

  // -----------------------------------------------------------------------
  // 5. Error handling
  // -----------------------------------------------------------------------

  describe('error handling', () => {
    it('returns silent success when getCachedBranch fails', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockImplementation(() => {
        throw new Error('git error');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });

    it('validates issue number is numeric before execFileSync', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/abc-desc');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(execFileSync).not.toHaveBeenCalled();
    });

    it('handles cache directory creation failure gracefully', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Test issue',
          labels: [],
        })
      );
      vi.mocked(writeFileSync).mockImplementation(() => {
        throw new Error('EACCES');
      });
      const input = createToolInput();

      // Act & Assert - should not throw
      expect(() => issueContextInjector(input)).not.toThrow();
      const result = issueContextInjector(input);
      expect(result.systemMessage).toContain('Test issue');
    });

    it('handles JSON.parse failure for cached data', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue('invalid json');
      vi.mocked(execFileSync).mockImplementation(() => {
        throw new Error('gh fail');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert - falls back to branch-name-only
      expect(result.systemMessage).toContain('Working on GitHub Issue #123');
    });

    it('handles malformed gh CLI output', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockReturnValue('not valid json');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert - falls back to branch-name-only
      expect(result.systemMessage).toContain('Working on GitHub Issue #123');
    });
  });

  // -----------------------------------------------------------------------
  // 6. Cache behavior
  // -----------------------------------------------------------------------

  describe('cache behavior', () => {
    it('writes fetched issue data to cache', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      const issueData = {
        title: 'Test issue',
        body: 'Test body',
        labels: [{ name: 'bug' }],
      };
      vi.mocked(execFileSync).mockReturnValue(JSON.stringify(issueData));
      const input = createToolInput();

      // Act
      issueContextInjector(input);

      // Assert
      expect(writeFileSync).toHaveBeenCalledWith(
        expect.stringContaining('123.json'),
        JSON.stringify(issueData),
        'utf8'
      );
    });

    it('handles cache write failure without blocking', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockReturnValue(
        JSON.stringify({ title: 'Test', labels: [] })
      );
      vi.mocked(writeFileSync).mockImplementation(() => {
        throw new Error('Disk full');
      });
      const input = createToolInput();

      // Act & Assert - should not throw
      expect(() => issueContextInjector(input)).not.toThrow();
      const result = issueContextInjector(input);
      expect(result.systemMessage).toContain('Test');
    });

    it('cache path includes issue number', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/456-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({ title: 'Cached', labels: [] })
      );
      const input = createToolInput();

      // Act
      issueContextInjector(input);

      // Assert
      expect(readFileSync).toHaveBeenCalledWith(
        expect.stringContaining('456.json'),
        'utf8'
      );
    });

    it('treats cache miss as stale', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false); // Cache miss
      vi.mocked(execFileSync).mockReturnValue(
        JSON.stringify({ title: 'Fresh', labels: [] })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(execFileSync).toHaveBeenCalled();
      expect(result.systemMessage).toContain('Fresh');
    });
  });

  // -----------------------------------------------------------------------
  // 7. Context message format
  // -----------------------------------------------------------------------

  describe('context message format', () => {
    it('includes issue number, title, and commit instructions', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Add feature X',
          labels: [],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toContain('Working on GitHub Issue #123: Add feature X');
      expect(result.systemMessage).toContain('Reference #123 in all commits');
      expect(result.systemMessage).toContain("Use 'Closes #123' in PR description");
    });

    it('formats labels correctly', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Test',
          labels: [
            { name: 'bug' },
            { name: 'priority: high' },
            { name: 'backend' },
          ],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toContain('Labels: bug, priority: high, backend');
    });

    it('omits labels section when no labels present', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(true);
      vi.mocked(statSync).mockReturnValue({ mtimeMs: Date.now() - 1000 } as any);
      vi.mocked(readFileSync).mockReturnValue(
        JSON.stringify({
          title: 'Test',
          labels: [],
        })
      );
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).not.toContain('Labels:');
    });

    it('builds context without title when only branch name available', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockImplementation(() => {
        throw new Error('gh fail');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.systemMessage).toBe(
        "Working on GitHub Issue #123\nReference #123 in all commits. Use 'Closes #123' in PR description."
      );
    });
  });

  // -----------------------------------------------------------------------
  // 8. CC 2.1.7 compliance
  // -----------------------------------------------------------------------

  describe('CC 2.1.7 compliance', () => {
    it('includes continue: true in success result', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('issue/123-test');
      vi.mocked(existsSync).mockReturnValue(false);
      vi.mocked(execFileSync).mockImplementation(() => {
        throw new Error('gh fail');
      });
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.systemMessage).toBeDefined();
    });

    it('includes continue: true in silent success result', () => {
      // Arrange
      vi.mocked(getCachedBranch).mockReturnValue('main');
      const input = createToolInput();

      // Act
      const result = issueContextInjector(input);

      // Assert
      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
    });
  });
});
