// Generated by OrchestKit Claude Plugin
// Created: 2026-02-17

/**
 * Unit tests for agentation-context hook
 * Tests UserPromptSubmit hook that injects annotation reminder when agentation MCP is configured
 *
 * Issue #638: Add prompt hook for annotation context injection.
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import type { HookInput } from '../../types.js';

// =============================================================================
// MOCK SETUP
// =============================================================================

vi.mock('../../lib/common.js', () => ({
  outputSilentSuccess: vi.fn(() => ({ continue: true, suppressOutput: true })),
  outputPromptContext: vi.fn((ctx: string) => ({
    continue: true,
    suppressOutput: true,
    hookSpecificOutput: {
      hookEventName: 'UserPromptSubmit',
      additionalContext: ctx,
    },
  })),
  getProjectDir: vi.fn(() => '/test/project'),
  logHook: vi.fn(),
}));

vi.mock('node:fs', async () => {
  const actual = await vi.importActual('node:fs');
  return {
    ...actual,
    existsSync: vi.fn(),
    readFileSync: vi.fn(),
  };
});

import {
  outputSilentSuccess,
  outputPromptContext,
  logHook,
} from '../../lib/common.js';
import { existsSync, readFileSync } from 'node:fs';

import { agentationContext } from '../../prompt/agentation-context.js';

// =============================================================================
// Test Utilities
// =============================================================================

function createInput(overrides: Partial<HookInput> = {}): HookInput {
  return {
    hook_event: 'UserPromptSubmit',
    tool_name: 'UserPromptSubmit',
    session_id: 'test-session',
    project_dir: '/test/project',
    tool_input: {},
    prompt: 'Hello world test prompt',
    ...overrides,
  };
}

function makeMcpConfig(agentationConfig: Record<string, unknown> | null = {}): string {
  const servers: Record<string, unknown> = {};
  if (agentationConfig !== null) {
    servers.agentation = {
      command: 'npx',
      args: ['-y', 'agentation-mcp', 'server'],
      disabled: false,
      ...agentationConfig,
    };
  }
  return JSON.stringify({ mcpServers: servers });
}

// =============================================================================
// Tests
// =============================================================================

describe('prompt/agentation-context', () => {
  const mockExistsSync = vi.mocked(existsSync);
  const mockReadFileSync = vi.mocked(readFileSync);
  const mockOutputSilentSuccess = vi.mocked(outputSilentSuccess);
  const mockOutputPromptContext = vi.mocked(outputPromptContext);
  const mockLogHook = vi.mocked(logHook);

  beforeEach(() => {
    vi.clearAllMocks();
    mockOutputSilentSuccess.mockReturnValue({ continue: true, suppressOutput: true });
    mockOutputPromptContext.mockImplementation((ctx: string) => ({
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: {
        hookEventName: 'UserPromptSubmit' as const,
        additionalContext: ctx,
      },
    }));
  });

  // ===========================================================================
  // No .mcp.json exists
  // ===========================================================================
  describe('no mcp.json file', () => {
    it('should return silent success when neither .mcp.json path exists', () => {
      mockExistsSync.mockReturnValue(false);

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
      expect(mockLogHook).toHaveBeenCalledWith(
        'agentation-context',
        'Agentation MCP not configured, skipping'
      );
    });
  });

  // ===========================================================================
  // Agentation configured and enabled
  // ===========================================================================
  describe('agentation configured', () => {
    it('should inject context when agentation is present and enabled', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(makeMcpConfig());

      const result = agentationContext(createInput());

      expect(mockOutputPromptContext).toHaveBeenCalledWith(
        expect.stringContaining('agentation_get_all_pending')
      );
      expect(result.continue).toBe(true);
      expect(result.hookSpecificOutput?.additionalContext).toContain('agentation_get_all_pending');
    });

    it('should mention Agentation in the context', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(makeMcpConfig());

      agentationContext(createInput());

      expect(mockOutputPromptContext).toHaveBeenCalledWith(
        expect.stringContaining('Agentation')
      );
    });

    it('should inject context when disabled field is absent (defaults to enabled)', () => {
      mockExistsSync.mockReturnValue(true);
      const config = JSON.stringify({
        mcpServers: {
          agentation: { command: 'npx', args: ['-y', 'agentation-mcp', 'server'] },
        },
      });
      mockReadFileSync.mockReturnValue(config);

      agentationContext(createInput());

      expect(mockOutputPromptContext).toHaveBeenCalled();
    });

    it('should log that agentation was detected', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(makeMcpConfig());

      agentationContext(createInput());

      expect(mockLogHook).toHaveBeenCalledWith(
        'agentation-context',
        'Agentation MCP detected â€” injecting annotation reminder'
      );
    });
  });

  // ===========================================================================
  // Agentation disabled
  // ===========================================================================
  describe('agentation disabled', () => {
    it('should return silent success when agentation is disabled: true', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(makeMcpConfig({ disabled: true }));

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
    });
  });

  // ===========================================================================
  // Agentation not in mcpServers
  // ===========================================================================
  describe('agentation not present', () => {
    it('should return silent success when mcpServers has no agentation key', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(JSON.stringify({
        mcpServers: { context7: { command: 'npx', disabled: false } },
      }));

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
    });

    it('should return silent success when mcpServers key is missing', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(JSON.stringify({ version: '1.0' }));

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
    });
  });

  // ===========================================================================
  // Malformed JSON
  // ===========================================================================
  describe('malformed JSON', () => {
    it('should return silent success when .mcp.json contains invalid JSON', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue('{ this is not valid json }}}');

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
    });
  });

  // ===========================================================================
  // Checks both candidate paths
  // ===========================================================================
  describe('candidate path resolution', () => {
    it('should check .mcp.json first, then .claude/mcp.json', () => {
      // First path doesn't exist, second does
      mockExistsSync
        .mockReturnValueOnce(false)   // .mcp.json
        .mockReturnValueOnce(true);   // .claude/mcp.json
      mockReadFileSync.mockReturnValue(makeMcpConfig());

      agentationContext(createInput());

      expect(mockExistsSync).toHaveBeenCalledTimes(2);
      expect(mockOutputPromptContext).toHaveBeenCalled();
    });

    it('should stop checking after finding agentation in the first file', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(makeMcpConfig());

      agentationContext(createInput());

      // readFileSync should be called once (found in first file)
      expect(mockReadFileSync).toHaveBeenCalledTimes(1);
    });
  });

  // ===========================================================================
  // Project directory handling
  // ===========================================================================
  describe('project directory', () => {
    it('should use project_dir from input when provided', () => {
      mockExistsSync.mockReturnValue(false);

      agentationContext(createInput({ project_dir: '/custom/project' }));

      expect(mockExistsSync).toHaveBeenCalledWith(
        expect.stringMatching(/[/\\]custom[/\\]project[/\\]\.mcp\.json/)
      );
    });

    it('should fallback to getProjectDir when project_dir not in input', () => {
      mockExistsSync.mockReturnValue(false);

      const input = createInput();
      delete (input as unknown as Record<string, unknown>).project_dir;
      agentationContext(input);

      expect(mockExistsSync).toHaveBeenCalledWith(
        expect.stringMatching(/[/\\]test[/\\]project[/\\]\.mcp\.json/)
      );
    });
  });

  // ===========================================================================
  // Error handling
  // ===========================================================================
  describe('error handling', () => {
    it('should return silent success when readFileSync throws', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockImplementation(() => {
        throw new Error('Permission denied');
      });

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      // The catch inside isAgentationConfigured skips the file,
      // so it falls through to "not configured"
      expect(mockOutputPromptContext).not.toHaveBeenCalled();
    });

    it('should return silent success when existsSync throws', () => {
      mockExistsSync.mockImplementation(() => {
        throw new Error('FS error');
      });

      const result = agentationContext(createInput());

      expect(result.continue).toBe(true);
      expect(result.suppressOutput).toBe(true);
      expect(mockLogHook).toHaveBeenCalledWith(
        'agentation-context',
        expect.stringContaining('Error checking agentation config'),
        'warn'
      );
    });
  });
});
