// Generated by OrchestKit Claude Plugin
// Created: 2026-02-19

/**
 * Hook Execution E2E Tests
 * Issue #748: E2E hook execution tests — actually fire unified dispatchers
 *
 * These tests import and call each unified dispatcher with minimal valid
 * HookInput, verifying that:
 * 1. The dispatcher returns continue: true
 * 2. No uncaught exceptions are thrown
 * 3. Registry exports are populated with expected hook names
 * 4. matchesTool routing logic is correct
 *
 * VITEST=1 is set by vitest itself, which causes isTestEnv() to return true
 * in analytics.ts — preventing any real file I/O during tests.
 */

import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { HookInput } from '../../types.js';

// ---------------------------------------------------------------------------
// Mocks — prevent file I/O from sub-hooks that write to disk
// ---------------------------------------------------------------------------

vi.mock('../../lib/common.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/common.js')>('../../lib/common.js');
  return {
    ...actual,
    logHook: vi.fn(),
    getProjectDir: vi.fn(() => '/tmp/orchestkit-e2e-test'),
    getCachedBranch: vi.fn(() => 'main'),
  };
});

// Prevent real analytics writes
vi.mock('../../lib/analytics.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/analytics.js')>('../../lib/analytics.js');
  return {
    ...actual,
    appendAnalytics: vi.fn(),
    hashProject: vi.fn(() => 'test-hash-abc123'),
    getTeamContext: vi.fn(() => ({})),
  };
});

// Prevent real session tracking writes
vi.mock('../../lib/session-tracker.js', async () => {
  const actual = await vi.importActual<typeof import('../../lib/session-tracker.js')>('../../lib/session-tracker.js');
  return {
    ...actual,
    trackEvent: vi.fn(),
  };
});

// Prevent all sub-hook implementations from doing real I/O
vi.mock('node:child_process', () => ({
  execSync: vi.fn(() => Buffer.from('')),
  spawnSync: vi.fn(() => ({ stdout: Buffer.from(''), stderr: Buffer.from(''), status: 0 })),
}));

vi.mock('node:fs', async () => {
  const actual = await vi.importActual<typeof import('node:fs')>('node:fs');
  return {
    ...actual,
    existsSync: vi.fn(() => false),
    mkdirSync: vi.fn(),
    writeFileSync: vi.fn(),
    appendFileSync: vi.fn(),
    readFileSync: vi.fn(() => ''),
  };
});

// ---------------------------------------------------------------------------
// Imports (after mocks)
// ---------------------------------------------------------------------------

import {
  unifiedDispatcher,
  registeredHookNames as posttoolHookNames,
  registeredHookMatchers,
  matchesTool,
} from '../../posttool/unified-dispatcher.js';

import {
  unifiedSubagentStopDispatcher,
  registeredHookNames as subagentHookNames,
} from '../../subagent-stop/unified-dispatcher.js';

import {
  unifiedPromptDispatcher,
  registeredHookNames as promptHookNames,
} from '../../prompt/unified-dispatcher.js';

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function makeInput(overrides: Partial<HookInput> = {}): HookInput {
  return {
    tool_name: 'Bash',
    session_id: 'e2e-test-session-748',
    tool_input: { command: 'echo hello' },
    ...overrides,
  };
}

// ---------------------------------------------------------------------------
// Tests: PostToolUse Unified Dispatcher
// ---------------------------------------------------------------------------

describe('PostToolUse Unified Dispatcher — execution', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns continue=true for Bash tool_name', async () => {
    const input = makeInput({ tool_name: 'Bash' });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for Read tool_name (wildcard matcher)', async () => {
    const input = makeInput({ tool_name: 'Read' });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for Write tool_name', async () => {
    const input = makeInput({ tool_name: 'Write', tool_input: { file_path: '/tmp/test.ts', content: 'export {}' } });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for Edit tool_name', async () => {
    const input = makeInput({ tool_name: 'Edit', tool_input: { file_path: '/tmp/test.ts', old_string: 'a', new_string: 'b' } });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for Skill tool_name', async () => {
    const input = makeInput({ tool_name: 'Skill', tool_input: { skill: 'implement' } });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for empty tool_name (no matching hooks)', async () => {
    const input = makeInput({ tool_name: '' });
    const result = await unifiedDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('never throws even if a sub-hook fails internally', async () => {
    const input = makeInput({ tool_name: 'Bash' });
    await expect(unifiedDispatcher(input)).resolves.toMatchObject({ continue: true });
  });
});

// ---------------------------------------------------------------------------
// Tests: PostToolUse Registry
// ---------------------------------------------------------------------------

describe('PostToolUse Unified Dispatcher — registry', () => {
  it('registeredHookNames returns a non-empty array', () => {
    const names = posttoolHookNames();
    expect(Array.isArray(names)).toBe(true);
    expect(names.length).toBeGreaterThan(0);
  });

  it('registeredHookNames includes required hooks', () => {
    const names = posttoolHookNames();
    const required = ['session-metrics', 'audit-logger', 'user-tracking'];
    for (const name of required) {
      expect(names, `Expected "${name}" to be registered`).toContain(name);
    }
  });

  it('registeredHookMatchers returns matchers for each hook', () => {
    const matchers = registeredHookMatchers();
    expect(Array.isArray(matchers)).toBe(true);
    expect(matchers.length).toBe(posttoolHookNames().length);
    for (const m of matchers) {
      expect(m).toHaveProperty('name');
      expect(m).toHaveProperty('matcher');
    }
  });
});

// ---------------------------------------------------------------------------
// Tests: matchesTool routing logic
// ---------------------------------------------------------------------------

describe('matchesTool — routing logic', () => {
  it.each([
    { tool: 'Bash', matcher: '*' as const, expected: true },
    { tool: 'Read', matcher: '*' as const, expected: true },
    { tool: 'Bash', matcher: 'Bash', expected: true },
    { tool: 'Read', matcher: 'Bash', expected: false },
    { tool: 'Edit', matcher: ['Write', 'Edit'], expected: true },
    { tool: 'Read', matcher: ['Write', 'Edit'], expected: false },
    { tool: 'Write', matcher: ['Write', 'Edit'], expected: true },
    { tool: 'Skill', matcher: 'Skill', expected: true },
    { tool: 'Task', matcher: 'Skill', expected: false },
  ])('matchesTool($tool, $matcher) === $expected', ({ tool, matcher, expected }) => {
    expect(matchesTool(tool, matcher)).toBe(expected);
  });
});

// ---------------------------------------------------------------------------
// Tests: SubagentStop Unified Dispatcher
// ---------------------------------------------------------------------------

describe('SubagentStop Unified Dispatcher — execution', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns continue=true with minimal input', async () => {
    const input = makeInput({
      tool_name: '',
      tool_input: {},
      subagent_type: 'test-agent',
      agent_id: 'agent-e2e-748',
    });
    const result = await unifiedSubagentStopDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true with full agent output', async () => {
    const input = makeInput({
      tool_name: '',
      tool_input: {},
      subagent_type: 'backend-system-architect',
      agent_id: 'agent-abc',
      agent_output: 'Created the API endpoint successfully.',
      duration_ms: 5000,
      last_assistant_message: 'Task complete.',
    });
    const result = await unifiedSubagentStopDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('never throws even when agent_output is missing', async () => {
    const input = makeInput({ tool_name: '', tool_input: {} });
    await expect(unifiedSubagentStopDispatcher(input)).resolves.toMatchObject({ continue: true });
  });
});

// ---------------------------------------------------------------------------
// Tests: SubagentStop Registry
// ---------------------------------------------------------------------------

describe('SubagentStop Unified Dispatcher — registry', () => {
  it('registeredHookNames returns exactly the 4 expected hooks', () => {
    const names = subagentHookNames();
    const expected = ['context-publisher', 'handoff-preparer', 'feedback-loop', 'agent-memory-store'];
    expect(names).toEqual(expected);
  });
});

// ---------------------------------------------------------------------------
// Tests: UserPromptSubmit Unified Dispatcher
// ---------------------------------------------------------------------------

describe('UserPromptSubmit Unified Dispatcher — execution', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('returns continue=true for a typical prompt', () => {
    const input = makeInput({
      tool_name: '',
      tool_input: {},
      prompt: 'Please help me write a function to sort a list.',
      project_dir: '/tmp/orchestkit-e2e-test',
    });
    const result = unifiedPromptDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true for an empty prompt', () => {
    const input = makeInput({ tool_name: '', tool_input: {}, prompt: '' });
    const result = unifiedPromptDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('returns continue=true when prompt is very long (triggers guard)', () => {
    // Prompt over MAX_PROMPT_LENGTH — dispatcher should skip hooks and return silentSuccess
    const input = makeInput({
      tool_name: '',
      tool_input: {},
      prompt: 'x'.repeat(200_001),
    });
    const result = unifiedPromptDispatcher(input);
    expect(result.continue).toBe(true);
  });

  it('is a synchronous function (not async)', () => {
    const input = makeInput({ tool_name: '', tool_input: {}, prompt: 'hello' });
    const result = unifiedPromptDispatcher(input);
    // If it were a Promise, .continue would not be accessible synchronously
    expect(result).not.toBeInstanceOf(Promise);
    expect(result.continue).toBe(true);
  });
});

// ---------------------------------------------------------------------------
// Tests: UserPromptSubmit Registry
// ---------------------------------------------------------------------------

describe('UserPromptSubmit Unified Dispatcher — registry', () => {
  it('registeredHookNames returns a non-empty array', () => {
    const names = promptHookNames();
    expect(Array.isArray(names)).toBe(true);
    expect(names.length).toBeGreaterThan(0);
  });

  it('registeredHookNames includes required hooks', () => {
    const names = promptHookNames();
    const required = ['profile-injector', 'antipattern-warning', 'memory-context'];
    for (const name of required) {
      expect(names, `Expected "${name}" to be registered`).toContain(name);
    }
  });
});
