// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Session End Reporter â€” Posts token usage + session metrics to HQ API
 *
 * Replaces the 2 HTTP hooks (session-end, pattern-sync) with a single
 * command hook that builds a proper HookPayload with HMAC signature.
 *
 * Fire-and-forget: always returns silent success regardless of POST outcome.
 * No-op when ORCHESTKIT_HOOK_URL or ORCHESTKIT_HOOK_TOKEN are missing.
 */

import { createHmac } from 'node:crypto';
import { existsSync, readFileSync } from 'node:fs';
import type { HookInput, HookResult } from '../types.js';
import { getSessionId, getCachedBranch, logHook, outputSilentSuccess } from '../lib/common.js';
import { getMetricsFile } from '../lib/paths.js';
import { getTokenState } from '../lib/token-tracker.js';

const HOOK_NAME = 'session-end-reporter';

interface SessionMetrics {
  tools?: Record<string, number>;
  errors?: number;
}

interface HookPayload {
  event: string;
  session_id: string;
  project: string;
  timestamp: string;
  data: Record<string, unknown>;
  metadata: Record<string, unknown>;
}

function loadSessionMetrics(): SessionMetrics | null {
  const metricsFile = getMetricsFile();
  if (!existsSync(metricsFile)) return null;

  try {
    return JSON.parse(readFileSync(metricsFile, 'utf8')) as SessionMetrics;
  } catch {
    return null;
  }
}

function getProjectSlug(): string {
  const dir = process.env.CLAUDE_PROJECT_DIR || process.cwd();
  return dir.split('/').pop() || 'unknown';
}

function signPayload(body: string, secret: string): string {
  const mac = createHmac('sha256', secret).update(body).digest('hex');
  return `sha256=${mac}`;
}

function buildPayload(input: HookInput): HookPayload {
  const sessionId = input.session_id || getSessionId();
  const tokenState = getTokenState();
  const sessionMetrics = loadSessionMetrics();

  return {
    event: 'Stop',
    session_id: sessionId,
    project: getProjectSlug(),
    timestamp: new Date().toISOString(),
    data: {
      token_usage: {
        totalTokensInjected: tokenState.totalTokensInjected,
        byHook: tokenState.byHook,
        byCategory: tokenState.byCategory,
      },
      ...(sessionMetrics && {
        session_metrics: {
          tools: sessionMetrics.tools || {},
          errors: sessionMetrics.errors || 0,
        },
      }),
    },
    metadata: {
      branch: getCachedBranch(),
      hook_version: '7.0.0',
    },
  };
}

async function postPayload(payload: HookPayload, hookUrl: string, hookToken: string): Promise<void> {
  const body = JSON.stringify(payload);
  const signature = signPayload(body, hookToken);
  const url = `${hookUrl.replace(/\/$/, '')}/ingest`;

  const injected = (payload.data.token_usage as { totalTokensInjected?: number })?.totalTokensInjected ?? 0;
  logHook(HOOK_NAME, `POSTing to ${url} (tokens: ${injected})`);

  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'X-CC-Hooks-Signature': signature },
    body,
    signal: AbortSignal.timeout(4000),
  });

  logHook(HOOK_NAME, `POST complete: ${response.status}`);
}

/**
 * Build HookPayload and POST to the HQ API ingest endpoint.
 */
export async function sessionEndReporter(input: HookInput): Promise<HookResult> {
  const hookUrl = process.env.ORCHESTKIT_HOOK_URL;
  const hookToken = process.env.ORCHESTKIT_HOOK_TOKEN;

  if (!hookUrl || !hookToken) {
    logHook(HOOK_NAME, 'No ORCHESTKIT_HOOK_URL/TOKEN, skipping');
    return outputSilentSuccess();
  }

  try {
    await postPayload(buildPayload(input), hookUrl, hookToken);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    logHook(HOOK_NAME, `POST failed (non-blocking): ${msg}`, 'warn');
  }

  return outputSilentSuccess();
}
