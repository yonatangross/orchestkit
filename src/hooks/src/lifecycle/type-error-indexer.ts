// Generated by OrchestKit Claude Plugin
// Created: 2026-02-14

/**
 * Type Error Cache Population Hook
 * Issue #304: [P0-B] Type error cache population
 *
 * Runs `tsc --noEmit` on SessionStart and caches results so agents
 * know about existing type errors before making edits.
 * Prevents 30-40% of failed edit attempts by surfacing existing errors.
 *
 * Runs inside the unified-dispatcher (async, fire-and-forget).
 */

import { execSync } from 'node:child_process';
import { writeFileSync, mkdirSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import type { HookInput, HookResult } from '../types.js';
import { logHook, getProjectDir, outputSilentSuccess } from '../lib/common.js';

interface TypeErrorEntry {
  file: string;
  line: number;
  column: number;
  code: string;
  message: string;
}

interface TypeErrorCache {
  timestamp: number;
  errorCount: number;
  errors: TypeErrorEntry[];
  summary: string;
}

const TSC_TIMEOUT_MS = 15_000;

/**
 * Parse tsc output into structured error entries.
 * Format: "src/file.ts(10,5): error TS2345: ..."
 */
function parseTscOutput(output: string): TypeErrorEntry[] {
  const errors: TypeErrorEntry[] = [];
  const errorRegex = /^(.+?)\((\d+),(\d+)\):\s+error\s+(TS\d+):\s+(.+)$/gm;

  let match;
  while ((match = errorRegex.exec(output)) !== null) {
    errors.push({
      file: match[1],
      line: parseInt(match[2], 10),
      column: parseInt(match[3], 10),
      code: match[4],
      message: match[5],
    });
  }

  return errors;
}

/**
 * Get the cache file path for the current session.
 */
function getCacheFilePath(sessionId: string): string {
  const cacheDir = join(getProjectDir(), '.claude', 'cache');
  if (!existsSync(cacheDir)) {
    mkdirSync(cacheDir, { recursive: true });
  }
  return join(cacheDir, `type-errors-${sessionId}.json`);
}

/**
 * Detect if the project uses TypeScript by checking for tsconfig.json.
 */
function hasTypeScript(projectDir: string): boolean {
  return existsSync(join(projectDir, 'tsconfig.json'));
}

/**
 * Type error indexer — runs tsc --noEmit and caches results.
 */
export function typeErrorIndexer(input: HookInput): HookResult {
  const projectDir = input.project_dir || getProjectDir();

  if (!hasTypeScript(projectDir)) {
    logHook('type-error-indexer', 'No tsconfig.json found, skipping');
    return outputSilentSuccess();
  }

  const sessionId = input.session_id || 'unknown';

  try {
    // Run tsc --noEmit with timeout
    execSync('npx tsc --noEmit 2>&1', {
      cwd: projectDir,
      timeout: TSC_TIMEOUT_MS,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    // No errors — write empty cache
    const cache: TypeErrorCache = {
      timestamp: performance.timeOrigin + performance.now(),
      errorCount: 0,
      errors: [],
      summary: 'No type errors found',
    };
    writeFileSync(getCacheFilePath(sessionId), JSON.stringify(cache, null, 2));
    logHook('type-error-indexer', 'No type errors found');
  } catch (err: unknown) {
    const execErr = err as { stdout?: string; stderr?: string; killed?: boolean; status?: number };

    if (execErr.killed) {
      logHook('type-error-indexer', `tsc timed out after ${TSC_TIMEOUT_MS}ms`, 'warn');
      return outputSilentSuccess();
    }

    // tsc exits non-zero when there are errors — parse them
    const output = (execErr.stdout || '') + (execErr.stderr || '');
    const errors = parseTscOutput(output);

    if (errors.length === 0) {
      logHook('type-error-indexer', 'tsc failed but no parseable errors', 'warn');
      return outputSilentSuccess();
    }

    // Dedupe by file and group
    const fileSet = new Set(errors.map(e => e.file));
    const summary = `${errors.length} type error${errors.length !== 1 ? 's' : ''} in ${fileSet.size} file${fileSet.size !== 1 ? 's' : ''}`;

    const cache: TypeErrorCache = {
      timestamp: performance.timeOrigin + performance.now(),
      errorCount: errors.length,
      errors: errors.slice(0, 50), // Cap at 50 to avoid huge cache files
      summary,
    };

    writeFileSync(getCacheFilePath(sessionId), JSON.stringify(cache, null, 2));
    logHook('type-error-indexer', `Cached: ${summary}`);
  }

  return outputSilentSuccess();
}
