// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync Session End Dispatcher — SessionEnd Hook
 * Consolidates 3 synchronous SessionEnd hooks into a single dispatcher.
 *
 * Consolidated hooks:
 * - session-metrics-summary (run_on_fail: true — runs even if session errored)
 * - session-cleanup (run_on_fail: true — runs even if session errored)
 * - pattern-sync-push (normal — skips if a run_on_fail hook returned continue: false)
 *
 * NOT consolidated (remain separate in hooks.json):
 * - HTTP: session-end webhook
 * - HTTP: pattern-sync webhook
 *
 * CC 2.1.9 Compliant: Single sync hook with merged systemMessage output.
 * run_on_fail semantics: metrics-summary and session-cleanup always run (try/catch + continue).
 * pattern-sync-push is skipped if a prior hook signals continue: false.
 */

import type { HookInput, HookResult } from '../types.js';
import { outputSilentSuccess, logHook } from '../lib/common.js';

// Import consolidated hook implementations
import { sessionMetricsSummary } from './session-metrics-summary.js';
import { sessionCleanup } from './session-cleanup.js';
import { patternSyncPush } from './pattern-sync-push.js';

const HOOK_NAME = 'sync-session-end-dispatcher';

interface SessionEndHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult;
  runOnFail: boolean;
}

/**
 * Registry of sync SessionEnd hooks, executed sequentially.
 * Order matters — metrics-summary first, then cleanup, then pattern sync.
 * run_on_fail: true means the hook executes even when prior hooks fail.
 */
const SYNC_HOOKS: SessionEndHookConfig[] = [
  { name: 'session-metrics-summary', fn: sessionMetricsSummary, runOnFail: true },
  { name: 'session-cleanup', fn: sessionCleanup, runOnFail: true },
  { name: 'pattern-sync-push', fn: patternSyncPush, runOnFail: false },
];

/**
 * Consolidated sync SessionEnd dispatcher.
 * Runs all sync hooks sequentially.
 * - runOnFail hooks: always run, wrapped in try/catch, never block subsequent hooks.
 * - Normal hooks: skipped if a previous hook returned continue: false.
 */
export function syncSessionEndDispatcher(input: HookInput): HookResult {
  const messages: string[] = [];
  let shouldContinue = true;

  for (const hook of SYNC_HOOKS) {
    // Skip normal hooks if a prior hook signaled stop
    if (!hook.runOnFail && !shouldContinue) {
      logHook(HOOK_NAME, `${hook.name}: skipped (prior hook returned continue: false)`);
      continue;
    }

    try {
      const result = hook.fn(input);

      // Track continue signal (only from normal hooks — run_on_fail hooks can't block)
      if (!hook.runOnFail && result.continue === false) {
        shouldContinue = false;
        logHook(HOOK_NAME, `${hook.name}: returned continue: false`);
      }

      // Collect systemMessage if any
      if (result.systemMessage) {
        messages.push(result.systemMessage);
        logHook(HOOK_NAME, `${hook.name}: systemMessage collected`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      if (hook.runOnFail) {
        // run_on_fail: log and continue regardless
        logHook(HOOK_NAME, `${hook.name} failed (run_on_fail, continuing): ${msg}`, 'warn');
      } else {
        logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
      }
    }
  }

  if (messages.length === 0) {
    logHook(HOOK_NAME, 'All SessionEnd hooks silent');
    return outputSilentSuccess();
  }

  const merged = messages.join('\n');
  logHook(HOOK_NAME, `Merged ${messages.length} messages from SessionEnd hooks`);

  return {
    continue: true,
    systemMessage: merged,
  };
}
