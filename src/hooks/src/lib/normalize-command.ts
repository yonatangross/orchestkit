// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * Normalize shell commands for safe pattern matching.
 * Prevents bypass via quoting, escapes, and compound operators.
 *
 * Issue #687: centralizes normalization that was previously ad-hoc
 * across dangerous-command-blocker, auto-approve-safe-bash, and learning-tracker.
 */

/**
 * Expand hex escapes: \x72\x6d -> rm
 */
function expandHexEscapes(cmd: string): string {
  return cmd.replace(/\\x([0-9a-fA-F]{2})/g, (_match, hex) =>
    String.fromCharCode(parseInt(hex, 16))
  );
}

/**
 * Expand octal escapes: \162\155 -> rm
 */
function expandOctalEscapes(cmd: string): string {
  return cmd.replace(/\\([0-7]{3})/g, (_match, oct) =>
    String.fromCharCode(parseInt(oct, 8))
  );
}

/**
 * Strip backslash escapes from individual characters: r\m -> rm, r\\m -> rm
 * Runs AFTER hex/octal expansion so those are already resolved.
 */
function stripBackslashEscapes(cmd: string): string {
  // Remove backslash before any non-whitespace character (escape bypass)
  return cmd.replace(/\\([^\s])/g, '$1');
}

/**
 * Strip wrapping quotes from tokens: "rm" -> rm, 'rm' -> rm
 * Handles full-token quoting and inline quoting like r"m" -> rm
 */
function stripQuotes(cmd: string): string {
  // Remove matched single or double quotes around content
  let result = cmd;
  // Strip double-quoted segments: "..." -> content
  result = result.replace(/"([^"]*)"/g, '$1');
  // Strip single-quoted segments: '...' -> content
  result = result.replace(/'([^']*)'/g, '$1');
  return result;
}

/**
 * Split a command string on compound operators: && || ; | and newlines.
 * Pipe (|) is included because `safe | dangerous` should not auto-approve
 * based on the safe prefix alone.
 *
 * Does NOT split inside quotes (simplified: quotes are already stripped).
 */
function _splitCompound(cmd: string): string[] {
  // Split on &&, ||, ;, |, or newlines
  // Order matters: && and || before single & and |
  return cmd.split(/\s*(?:&&|\|\||\||;|\n)\s*/);
}

/**
 * Normalize a single sub-command (no splitting, just cleaning).
 * - Expand hex/octal escapes
 * - Strip backslash escapes
 * - Strip quotes
 * - Remove line continuations
 * - Collapse whitespace
 */
export function normalizeSingle(cmd: string): string {
  let result = cmd;
  result = expandHexEscapes(result);
  result = expandOctalEscapes(result);
  result = stripBackslashEscapes(result);
  result = stripQuotes(result);
  // Remove line continuations (backslash + newline)
  result = result.replace(/\\\s*[\r\n]+/g, ' ');
  // Replace remaining newlines
  result = result.replace(/\n/g, ' ');
  // Collapse whitespace
  result = result.replace(/\s+/g, ' ');
  return result.trim();
}

/**
 * Normalize a shell command for safe matching.
 * Strips quoting, expands escapes, splits compound operators.
 * Returns array of individual normalized sub-commands.
 */
export function normalizeCommand(cmd: string): string[] {
  if (!cmd || !cmd.trim()) return [];

  // Pre-process: expand escapes and strip quotes on the raw input,
  // but preserve newlines and compound operators for splitting.
  let preprocessed = cmd;
  preprocessed = expandHexEscapes(preprocessed);
  preprocessed = expandOctalEscapes(preprocessed);
  preprocessed = stripBackslashEscapes(preprocessed);
  preprocessed = stripQuotes(preprocessed);
  // Remove line continuations (backslash + newline) â€” these join lines
  preprocessed = preprocessed.replace(/\\\s*[\r\n]+/g, ' ');

  // Split on compound operators (&&, ||, |, ;) AND newlines
  const parts = preprocessed.split(/\s*(?:&&|\|\||\||;|\n)\s*/);

  // Normalize whitespace in each part and filter empties
  return parts
    .map((p) => p.replace(/\s+/g, ' ').trim())
    .filter(Boolean);
}

/**
 * Check if any sub-command in a compound command matches a dangerous pattern.
 * Patterns are matched as lowercase substrings against each normalized sub-command.
 */
export function containsDangerousCommand(
  cmd: string,
  patterns: string[]
): { matches: boolean; matched?: string; subCommand?: string } {
  const subCommands = normalizeCommand(cmd);

  for (const sub of subCommands) {
    const lowerSub = sub.toLowerCase();
    for (const pattern of patterns) {
      if (lowerSub.includes(pattern.toLowerCase())) {
        return { matches: true, matched: pattern, subCommand: sub };
      }
    }
  }

  return { matches: false };
}

/**
 * Check if a command is a compound command (contains operators like &&, ||, ;, |, or newlines).
 */
export function isCompoundCommand(cmd: string): boolean {
  // Check for newlines BEFORE normalization (normalization converts \n to space)
  // But ignore line continuations (backslash + newline) which join lines
  const withoutContinuations = cmd.replace(/\\\s*[\r\n]+/g, ' ');
  if (/\n/.test(withoutContinuations)) return true;

  // Check the normalized form for compound operators
  const normalized = normalizeSingle(cmd);
  return /(?:&&|\|\||[|;])/.test(normalized);
}
