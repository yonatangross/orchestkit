// Generated by OrchestKit Claude Plugin
// Created: 2026-02-10

/**
 * Code Summarizer — Pure-function library for structural file summaries
 *
 * Extracts structural signatures (imports, functions, classes, types, exports)
 * from source files using regex-based extraction. No AST parsing required.
 *
 * @since v6.0.4
 * @see #463
 */

import { estimateTokenCount } from './common.js';

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

interface ExtractedStructure {
  imports: string[];
  functions: string[];
  classes: string[];
  types: string[];
  exports: string[];
  sections: string[];   // Markdown h1-h3
  variables: string[];  // Shell uppercase vars
}

type LanguageId = 'typescript' | 'python' | 'go' | 'rust' | 'shell' | 'markdown';

// ---------------------------------------------------------------------------
// Extension Map
// ---------------------------------------------------------------------------

const EXT_TO_LANG: Record<string, LanguageId> = {
  '.ts': 'typescript',
  '.tsx': 'typescript',
  '.js': 'typescript',
  '.jsx': 'typescript',
  '.mjs': 'typescript',
  '.mts': 'typescript',
  '.py': 'python',
  '.go': 'go',
  '.rs': 'rust',
  '.sh': 'shell',
  '.bash': 'shell',
  '.md': 'markdown',
};

/** Check if a file extension is supported for summarization */
export function isSummarizable(ext: string): boolean {
  return ext in EXT_TO_LANG;
}

// ---------------------------------------------------------------------------
// Language Extractors (regex-based, no AST)
// ---------------------------------------------------------------------------

function extractTypeScript(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const imports: string[] = [];
  const functions: string[] = [];
  const classes: string[] = [];
  const types: string[] = [];
  const exports: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Imports: import { X } from 'y' or import X from 'y'
    if (/^import\s/.test(trimmed)) {
      imports.push(trimmed.replace(/;$/, ''));
      continue;
    }

    // Interfaces and type aliases
    if (/^(?:export\s+)?(?:interface|type)\s+\w+/.test(trimmed)) {
      const m = trimmed.match(/^(?:export\s+)?(?:interface|type)\s+(\w+[^{=]*)/);
      if (m) types.push(m[0].replace(/\s*[{=]\s*$/, '').trim());
      continue;
    }

    // Classes
    if (/^(?:export\s+)?(?:abstract\s+)?class\s+\w+/.test(trimmed)) {
      const m = trimmed.match(/^(?:export\s+)?(?:abstract\s+)?class\s+\w+(?:\s+extends\s+\w+)?(?:\s+implements\s+[\w,\s]+)?/);
      if (m) classes.push(m[0].trim());
      continue;
    }

    // Named function declarations: async function foo(...): RetType
    if (/^(?:export\s+)?(?:async\s+)?function\s+\w+/.test(trimmed)) {
      const m = trimmed.match(/^(?:export\s+)?(?:async\s+)?function\s+\w+\([^)]*\)(?:\s*:\s*[^{]+)?/);
      if (m) functions.push(m[0].replace(/\s*\{?\s*$/, '').trim());
      continue;
    }

    // Arrow function exports: export const foo = (...) => or export const foo = async (...)
    if (/^(?:export\s+)?const\s+\w+\s*=\s*(?:async\s+)?\(/.test(trimmed)) {
      const m = trimmed.match(/^(?:export\s+)?const\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)(?:\s*:\s*[^=]+)?(?:\s*=>)?/);
      if (m) functions.push(m[0].replace(/\s*=>\s*$/, '').trim());
      continue;
    }

    // Re-exports: export { X } from 'y' or export default
    if (/^export\s+(?:\{|default\s)/.test(trimmed)) {
      exports.push(trimmed.replace(/;$/, ''));
    }
  }

  return { imports, functions, classes, types, exports, sections: [], variables: [] };
}

function extractPython(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const imports: string[] = [];
  const functions: string[] = [];
  const classes: string[] = [];

  let prevLineDecorator = '';

  for (const line of lines) {
    const trimmed = line.trim();

    // Imports
    if (/^(?:from\s|import\s)/.test(trimmed)) {
      imports.push(trimmed);
      continue;
    }

    // Decorators (capture for next def/class)
    if (/^@\w+/.test(trimmed)) {
      prevLineDecorator = trimmed;
      continue;
    }

    // Top-level functions (no leading whitespace)
    if (/^(?:async\s+)?def\s+\w+/.test(line) && !line.startsWith(' ') && !line.startsWith('\t')) {
      const m = line.match(/^(?:async\s+)?def\s+\w+\([^)]*\)(?:\s*->\s*[^:]+)?/);
      if (m) {
        const sig = prevLineDecorator ? `${prevLineDecorator} ${m[0].trim()}` : m[0].trim();
        functions.push(sig);
      }
      prevLineDecorator = '';
      continue;
    }

    // Classes (top-level)
    if (/^class\s+\w+/.test(line) && !line.startsWith(' ') && !line.startsWith('\t')) {
      const m = line.match(/^class\s+\w+(?:\([^)]*\))?/);
      if (m) {
        // Collect method names inside the class
        const className = m[0].trim();
        classes.push(className);
      }
      prevLineDecorator = '';
      continue;
    }

    // Class methods (indented def)
    if (/^\s+(?:async\s+)?def\s+\w+/.test(line)) {
      const m = line.match(/^\s+(?:async\s+)?def\s+(\w+)/);
      if (m && !m[1].startsWith('_')) {
        // Include public methods as part of the class info
        functions.push(`  ${m[0].trim()}`);
      }
      prevLineDecorator = '';
      continue;
    }

    prevLineDecorator = '';
  }

  return { imports, functions, classes, types: [], exports: [], sections: [], variables: [] };
}

function extractGo(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const imports: string[] = [];
  const functions: string[] = [];
  const types: string[] = [];

  let inImportBlock = false;

  for (const line of lines) {
    const trimmed = line.trim();

    // Import block
    if (/^import\s*\(/.test(trimmed)) {
      inImportBlock = true;
      continue;
    }
    if (inImportBlock) {
      if (trimmed === ')') {
        inImportBlock = false;
      } else if (trimmed && !trimmed.startsWith('//')) {
        imports.push(`import ${trimmed}`);
      }
      continue;
    }
    // Single import
    if (/^import\s+"/.test(trimmed)) {
      imports.push(trimmed);
      continue;
    }

    // Functions (with optional receiver)
    if (/^func\s/.test(trimmed)) {
      const m = trimmed.match(/^func\s+(?:\([^)]+\)\s+)?\w+\([^)]*\)(?:\s*(?:\([^)]*\)|\*?\w+))?/);
      if (m) functions.push(m[0].trim());
      continue;
    }

    // Type definitions: type X struct/interface
    if (/^type\s+\w+\s+(?:struct|interface)/.test(trimmed)) {
      const m = trimmed.match(/^type\s+\w+\s+(?:struct|interface)/);
      if (m) types.push(m[0].trim());
      continue;
    }
  }

  return { imports, functions, classes: [], types, exports: [], sections: [], variables: [] };
}

function extractRust(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const imports: string[] = [];
  const functions: string[] = [];
  const types: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    // Use statements
    if (/^use\s/.test(trimmed)) {
      imports.push(trimmed.replace(/;$/, ''));
      continue;
    }

    // Functions: pub/async/fn
    if (/^(?:pub\s+)?(?:async\s+)?fn\s+\w+/.test(trimmed)) {
      const m = trimmed.match(/^(?:pub\s+)?(?:async\s+)?fn\s+\w+(?:<[^>]+>)?\([^)]*\)(?:\s*->\s*[^{]+)?/);
      if (m) functions.push(m[0].replace(/\s*\{?\s*$/, '').trim());
      continue;
    }

    // Structs, enums, traits, impl
    if (/^(?:pub\s+)?(?:struct|enum|trait|impl)\s+\w+/.test(trimmed)) {
      const m = trimmed.match(/^(?:pub\s+)?(?:struct|enum|trait|impl)\s+\w+(?:<[^>]+>)?(?:\s+for\s+\w+(?:<[^>]+>)?)?/);
      if (m) types.push(m[0].trim());
      continue;
    }
  }

  return { imports, functions, classes: [], types, exports: [], sections: [], variables: [] };
}

function extractShell(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const functions: string[] = [];
  const variables: string[] = [];
  const varSet = new Set<string>();

  for (const line of lines) {
    const trimmed = line.trim();

    // Function definitions: foo() { or function foo {
    if (/^(?:function\s+)?(\w+)\s*\(\)\s*\{?/.test(trimmed)) {
      const m = trimmed.match(/^(?:function\s+)?(\w+)\s*\(\)/);
      if (m && m[1] !== 'if' && m[1] !== 'while' && m[1] !== 'for') {
        functions.push(m[1]);
      }
      continue;
    }
    if (/^function\s+(\w+)\s*\{?/.test(trimmed)) {
      const m = trimmed.match(/^function\s+(\w+)/);
      if (m) functions.push(m[1]);
      continue;
    }

    // Uppercase variables (cap at 10)
    if (/^[A-Z][A-Z0-9_]+=/.test(trimmed) && varSet.size < 10) {
      const m = trimmed.match(/^([A-Z][A-Z0-9_]+)=/);
      if (m && !varSet.has(m[1])) {
        varSet.add(m[1]);
        variables.push(m[1]);
      }
    }
  }

  return { imports: [], functions, classes: [], types: [], exports: [], sections: [], variables };
}

function extractMarkdown(content: string): ExtractedStructure {
  const lines = content.split('\n');
  const sections: string[] = [];

  for (const line of lines) {
    // h1-h3 headers
    const m = line.match(/^(#{1,3})\s+(.+)/);
    if (m) {
      sections.push(`${m[1]} ${m[2].trim()}`);
    }
  }

  return { imports: [], functions: [], classes: [], types: [], exports: [], sections, variables: [] };
}

// ---------------------------------------------------------------------------
// Dispatcher
// ---------------------------------------------------------------------------

const EXTRACTORS: Record<LanguageId, (content: string) => ExtractedStructure> = {
  typescript: extractTypeScript,
  python: extractPython,
  go: extractGo,
  rust: extractRust,
  shell: extractShell,
  markdown: extractMarkdown,
};

// ---------------------------------------------------------------------------
// Formatter
// ---------------------------------------------------------------------------

const SUMMARY_CHAR_BUDGET = 1400;

function langLabel(lang: LanguageId): string {
  const labels: Record<LanguageId, string> = {
    typescript: 'TypeScript',
    python: 'Python',
    go: 'Go',
    rust: 'Rust',
    shell: 'Shell',
    markdown: 'Markdown',
  };
  return labels[lang];
}

function formatSection(label: string, items: string[], indent = ''): string {
  if (items.length === 0) return '';
  const header = `${label} (${items.length}):`;
  const itemLines = items.map((i) => `${indent}  ${i}`).join('\n');
  return `${header}\n${itemLines}`;
}

function truncateToFit(sections: string[], budget: number): string {
  let result = '';
  for (const section of sections) {
    if (result.length + section.length + 1 > budget) {
      // Add truncation indicator and stop
      result += '\n  ...truncated';
      break;
    }
    result += (result ? '\n' : '') + section;
  }
  return result;
}

/**
 * Summarize a source file's structure.
 *
 * @param content - Full file content
 * @param filePath - File path (used for header + extension detection)
 * @returns Formatted summary string, or null if unsupported/empty
 */
export function summarizeCode(content: string, filePath: string): string | null {
  // Extract extension
  const dotIdx = filePath.lastIndexOf('.');
  if (dotIdx === -1) return null;
  const ext = filePath.slice(dotIdx).toLowerCase();
  const lang = EXT_TO_LANG[ext];
  if (!lang) return null;

  const extractor = EXTRACTORS[lang];
  const structure = extractor(content);

  // Check if we extracted anything useful
  const totalItems =
    structure.imports.length +
    structure.functions.length +
    structure.classes.length +
    structure.types.length +
    structure.exports.length +
    structure.sections.length +
    structure.variables.length;

  if (totalItems === 0) return null;

  const lineCount = content.split('\n').length;
  const tokenEst = estimateTokenCount(content);

  // Build header
  const header = `[TLDR] ${filePath} (${lineCount} lines, ~${tokenEst} tokens, ${langLabel(lang)})`;

  // Build body sections — ordered by priority (classes/types first, then functions, then imports)
  const bodySections: string[] = [];

  if (structure.classes.length > 0) {
    bodySections.push(formatSection('Classes', structure.classes));
  }
  if (structure.types.length > 0) {
    bodySections.push(formatSection('Types', structure.types));
  }
  if (structure.functions.length > 0) {
    bodySections.push(formatSection('Functions', structure.functions));
  }
  if (structure.exports.length > 0) {
    bodySections.push(formatSection('Exports', structure.exports));
  }
  if (structure.imports.length > 0) {
    bodySections.push(formatSection('Imports', structure.imports));
  }
  if (structure.sections.length > 0) {
    bodySections.push(formatSection('Sections', structure.sections));
  }
  if (structure.variables.length > 0) {
    bodySections.push(formatSection('Variables', structure.variables));
  }

  // Truncate body to fit within budget (header excluded from budget)
  const bodyBudget = SUMMARY_CHAR_BUDGET - header.length - 2; // -2 for newlines
  const body = truncateToFit(bodySections, bodyBudget);

  return `${header}\n\n${body}`;
}
