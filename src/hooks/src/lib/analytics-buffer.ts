// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * Analytics Write Buffer — Batches appendFileSync calls and flushes on exit
 *
 * Reduces per-hook I/O overhead by buffering analytics/metrics/log writes
 * and flushing them in a single batch per file path. Registered process
 * handlers ensure data is written before the process terminates.
 *
 * Issue #688: Buffer analytics writes and flush on process exit
 */

import { appendFileSync, mkdirSync } from 'node:fs';
import { dirname } from 'node:path';

interface BufferEntry {
  filePath: string;
  content: string;
}

const buffer: BufferEntry[] = [];
let flushing = false;
let handlersRegistered = false;

/**
 * Queue an analytics/log write for batched flushing.
 * Call this instead of appendFileSync for non-essential writes.
 */
export function bufferWrite(filePath: string, content: string): void {
  buffer.push({ filePath, content });
  ensureHandlers();
}

/**
 * Flush all buffered writes to disk immediately.
 * Groups entries by file path to minimize syscalls.
 */
export function flush(): void {
  if (flushing || buffer.length === 0) return;
  flushing = true;

  // Group by filePath to write each file once
  const grouped = new Map<string, string[]>();
  for (const entry of buffer) {
    const arr = grouped.get(entry.filePath);
    if (arr) {
      arr.push(entry.content);
    } else {
      grouped.set(entry.filePath, [entry.content]);
    }
  }

  for (const [path, contents] of grouped) {
    try {
      mkdirSync(dirname(path), { recursive: true });
      appendFileSync(path, contents.join(''));
    } catch {
      // Ignore flush errors — never block process exit
    }
  }

  buffer.length = 0;
  flushing = false;
}

/** Number of entries currently buffered (for testing) */
export function pendingCount(): number {
  return buffer.length;
}

/** Clear buffer without writing (for testing) */
export function _resetForTesting(): void {
  buffer.length = 0;
  flushing = false;
}

function ensureHandlers(): void {
  if (handlersRegistered) return;
  handlersRegistered = true;

  process.on('exit', flush);
  process.on('SIGTERM', () => { flush(); process.exit(0); });
  process.on('SIGINT', () => { flush(); process.exit(0); });
}
