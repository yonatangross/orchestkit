// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * Token Cost Estimator
 * Issue #693: Estimate session and daily token costs
 *
 * Uses model-specific pricing to calculate costs from CC's stats-cache.json
 * and session parser data.
 */

import { readFileSync, existsSync, writeFileSync, mkdirSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { getHomeDir } from './paths.js';

// ============================================================================
// Types
// ============================================================================

export interface ModelPricing {
  input_per_mtok: number;
  output_per_mtok: number;
  cache_read_per_mtok: number;
  cache_write_per_mtok: number;
}

export interface PricingConfig {
  models: Record<string, ModelPricing>;
  updated: string;
}

export interface CostBreakdown {
  model: string;
  input_cost: number;
  output_cost: number;
  cache_read_cost: number;
  cache_write_cost: number;
  total: number;
  tokens: {
    input: number;
    output: number;
    cache_read: number;
    cache_write: number;
  };
}

export interface SessionCostEstimate {
  models: CostBreakdown[];
  total: number;
  cache_savings: number; // what you'd pay without caching
}

export interface DailyCostEstimate {
  date: string;
  models: CostBreakdown[];
  total: number;
}

// ============================================================================
// Default Pricing (Feb 2026)
// ============================================================================

const DEFAULT_PRICING: PricingConfig = {
  models: {
    'claude-opus-4-6': {
      input_per_mtok: 5.0,
      output_per_mtok: 25.0,
      cache_read_per_mtok: 0.5,
      cache_write_per_mtok: 6.25,
    },
    'claude-sonnet-4-5-20250929': {
      input_per_mtok: 3.0,
      output_per_mtok: 15.0,
      cache_read_per_mtok: 0.3,
      cache_write_per_mtok: 3.75,
    },
    'claude-haiku-4-5-20251001': {
      input_per_mtok: 1.0,
      output_per_mtok: 5.0,
      cache_read_per_mtok: 0.1,
      cache_write_per_mtok: 1.25,
    },
  },
  updated: '2026-02-18',
};

// Short name aliases for matching stats-cache keys
const MODEL_ALIASES: Record<string, string> = {
  'claude-opus-4-6': 'claude-opus-4-6',
  opus: 'claude-opus-4-6',
  'claude-sonnet-4-5-20250929': 'claude-sonnet-4-5-20250929',
  sonnet: 'claude-sonnet-4-5-20250929',
  'claude-haiku-4-5-20251001': 'claude-haiku-4-5-20251001',
  haiku: 'claude-haiku-4-5-20251001',
};

// ============================================================================
// Config Management
// ============================================================================

function getPricingConfigPath(): string {
  return join(getHomeDir(), '.claude', 'orchestkit-pricing.json');
}

/** Load pricing config â€” user override or defaults */
export function getCostConfig(): PricingConfig {
  const configPath = getPricingConfigPath();
  if (existsSync(configPath)) {
    try {
      const userConfig = JSON.parse(readFileSync(configPath, 'utf8'));
      return {
        ...DEFAULT_PRICING,
        ...userConfig,
        models: { ...DEFAULT_PRICING.models, ...userConfig.models },
      };
    } catch {
      // Fall through to defaults
    }
  }
  return DEFAULT_PRICING;
}

/** Write default pricing config for user customization */
export function initPricingConfig(): void {
  const configPath = getPricingConfigPath();
  if (existsSync(configPath)) return;
  try {
    mkdirSync(dirname(configPath), { recursive: true });
    writeFileSync(
      configPath,
      JSON.stringify(DEFAULT_PRICING, null, 2) + '\n',
    );
  } catch {
    // Non-critical
  }
}

// ============================================================================
// Cost Calculation
// ============================================================================

function resolveModelKey(modelName: string): string {
  return MODEL_ALIASES[modelName] || modelName;
}

function getPricing(modelName: string): ModelPricing {
  const config = getCostConfig();
  const key = resolveModelKey(modelName);
  // Try exact match, then partial match
  if (config.models[key]) return config.models[key];

  // Partial match: "claude-opus" matches "claude-opus-4-6"
  for (const [k, v] of Object.entries(config.models)) {
    if (key.includes(k) || k.includes(key)) return v;
  }

  // Default to sonnet pricing as fallback
  return (
    config.models['claude-sonnet-4-5-20250929'] ||
    DEFAULT_PRICING.models['claude-sonnet-4-5-20250929']
  );
}

function calculateCost(
  model: string,
  tokens: {
    input: number;
    output: number;
    cache_read: number;
    cache_write: number;
  },
): CostBreakdown {
  const pricing = getPricing(model);
  const mtok = 1_000_000;

  return {
    model,
    input_cost: (tokens.input / mtok) * pricing.input_per_mtok,
    output_cost: (tokens.output / mtok) * pricing.output_per_mtok,
    cache_read_cost: (tokens.cache_read / mtok) * pricing.cache_read_per_mtok,
    cache_write_cost:
      (tokens.cache_write / mtok) * pricing.cache_write_per_mtok,
    total:
      (tokens.input / mtok) * pricing.input_per_mtok +
      (tokens.output / mtok) * pricing.output_per_mtok +
      (tokens.cache_read / mtok) * pricing.cache_read_per_mtok +
      (tokens.cache_write / mtok) * pricing.cache_write_per_mtok,
    tokens,
  };
}

/** Estimate cost from stats-cache.json modelUsage (all-time) */
export function estimateAllTimeCost(): SessionCostEstimate | null {
  const statsPath = join(getHomeDir(), '.claude', 'stats-cache.json');
  if (!existsSync(statsPath)) return null;

  try {
    const stats = JSON.parse(readFileSync(statsPath, 'utf8'));
    const modelUsage = stats.modelUsage as Record<
      string,
      {
        inputTokens: number;
        outputTokens: number;
        cacheReadInputTokens: number;
        cacheCreationInputTokens: number;
      }
    >;
    if (!modelUsage) return null;

    const models: CostBreakdown[] = [];
    let totalWithoutCache = 0;

    for (const [model, usage] of Object.entries(modelUsage)) {
      const breakdown = calculateCost(model, {
        input: usage.inputTokens || 0,
        output: usage.outputTokens || 0,
        cache_read: usage.cacheReadInputTokens || 0,
        cache_write: usage.cacheCreationInputTokens || 0,
      });
      models.push(breakdown);

      // What it would cost without caching (all cache reads become full-price input)
      const pricing = getPricing(model);
      const mtok = 1_000_000;
      totalWithoutCache +=
        ((usage.inputTokens + usage.cacheReadInputTokens) / mtok) *
          pricing.input_per_mtok +
        (usage.outputTokens / mtok) * pricing.output_per_mtok;
    }

    const total = models.reduce((sum, m) => sum + m.total, 0);

    return {
      models: models.sort((a, b) => b.total - a.total),
      total,
      cache_savings: totalWithoutCache - total,
    };
  } catch {
    return null;
  }
}

/** Estimate daily costs from stats-cache.json dailyModelTokens */
export function estimateDailyCosts(days = 7): DailyCostEstimate[] {
  const statsPath = join(getHomeDir(), '.claude', 'stats-cache.json');
  if (!existsSync(statsPath)) return [];

  try {
    const stats = JSON.parse(readFileSync(statsPath, 'utf8'));
    const dailyTokens = stats.dailyModelTokens as Array<{
      date: string;
      tokensByModel: Record<string, number>;
    }>;
    if (!Array.isArray(dailyTokens)) return [];

    // Take last N days
    const recent = dailyTokens.slice(-days);

    return recent.map((day) => {
      const models: CostBreakdown[] = [];
      for (const [model, tokens] of Object.entries(day.tokensByModel)) {
        // dailyModelTokens only has total tokens, not split by type
        // Estimate: 70% input, 30% output (rough average for CC usage)
        const inputTokens = Math.round(tokens * 0.7);
        const outputTokens = Math.round(tokens * 0.3);
        models.push(
          calculateCost(model, {
            input: inputTokens,
            output: outputTokens,
            cache_read: 0,
            cache_write: 0,
          }),
        );
      }

      return {
        date: day.date,
        models: models.sort((a, b) => b.total - a.total),
        total: models.reduce((sum, m) => sum + m.total, 0),
      };
    });
  } catch {
    return [];
  }
}

/** Format cost as USD string */
export function formatCost(amount: number): string {
  if (amount < 0.01) return '<$0.01';
  return `$${amount.toFixed(2)}`;
}

/** Format token count with K/M suffix */
export function formatTokens(count: number): string {
  if (count >= 1_000_000) return `${(count / 1_000_000).toFixed(1)}M`;
  if (count >= 1_000) return `${(count / 1_000).toFixed(1)}K`;
  return String(count);
}
