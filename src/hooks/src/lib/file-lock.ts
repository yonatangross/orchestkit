// Generated by OrchestKit Claude Plugin
// Created: 2026-02-06

/**
 * Shared File Lock Utilities
 * Issue #361: Consolidate duplicate file lock code
 *
 * Shared types and functions used by both:
 * - pretool/write-edit/multi-instance-lock.ts (acquire)
 * - posttool/write-edit/file-lock-release.ts (release)
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync, renameSync } from 'node:fs';
import { join, dirname } from 'node:path';

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

export interface FileLock {
  lock_id: string;
  file_path: string;
  lock_type: string;
  instance_id: string;
  acquired_at: string;
  expires_at: string;
  reason?: string;
}

export interface LockDatabase {
  locks: FileLock[];
}

// -----------------------------------------------------------------------------
// Shared Functions
// -----------------------------------------------------------------------------

/**
 * Get locks file path
 */
export function getLocksFilePath(projectDir: string): string {
  return join(projectDir, '.claude', 'coordination', 'locks.json');
}

/**
 * Check if coordination is enabled (directory exists)
 */
export function isCoordinationEnabled(projectDir: string): boolean {
  return existsSync(join(projectDir, '.claude', 'coordination'));
}

/**
 * Load locks database
 */
export function loadLocks(locksPath: string): LockDatabase {
  try {
    if (existsSync(locksPath)) {
      const data = JSON.parse(readFileSync(locksPath, 'utf8'));
      return { locks: Array.isArray(data.locks) ? data.locks : [] };
    }
  } catch {
    // Ignore parse errors or read errors
  }
  return { locks: [] };
}

/**
 * Save locks database atomically (write to temp, then rename).
 * Prevents TOCTOU race conditions when multiple instances write concurrently.
 */
export function saveLocks(locksPath: string, data: LockDatabase): void {
  const dir = dirname(locksPath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
  const tmpPath = `${locksPath}.${process.pid}.tmp`;
  writeFileSync(tmpPath, JSON.stringify(data, null, 2));
  renameSync(tmpPath, locksPath);
}

/**
 * Clean expired locks and return active ones
 */
export function cleanExpiredLocks(locks: FileLock[]): FileLock[] {
  const now = new Date().toISOString();
  return locks.filter(l => l.expires_at > now);
}
