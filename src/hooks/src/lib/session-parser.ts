// Generated by OrchestKit Claude Plugin
// Created: 2026-02-18

/**
 * CC Session JSONL Parser
 * Issue #691: Parse Claude Code session files for analytics
 *
 * Reads CC's native JSONL session logs and extracts structured
 * analytics data: token usage, tool calls, agent spawns, timing.
 */

import { readFileSync, existsSync, readdirSync, statSync } from 'node:fs';
import { join, basename } from 'node:path';
import { getHomeDir } from './paths.js';
import type {
  SessionTokenUsage, ParsedSession, ParseAccumulator,
} from './session-types.js';

export type { SessionTokenUsage, TimelineEvent, ParsedSession, ParseAccumulator } from './session-types.js';

function getProjectsDir(): string {
  return join(getHomeDir(), '.claude', 'projects');
}

/**
 * Find the encoded project directory for a given project path.
 * CC encodes paths by replacing / with - (e.g., /Users/foo/bar -> -Users-foo-bar)
 */
export function findProjectDir(projectPath?: string): string | null {
  const projectsDir = getProjectsDir();
  if (!existsSync(projectsDir)) return null;

  const candidates = [projectPath, process.env.CLAUDE_PROJECT_DIR].filter(Boolean);
  for (const dir of candidates) {
    const encoded = dir!.replace(/\//g, '-');
    const fullPath = join(projectsDir, encoded);
    if (existsSync(fullPath)) return fullPath;
  }
  return null;
}

/**
 * List available session IDs for a project, sorted by modification time (newest first).
 */
export function listSessions(projectDirPath: string, limit = 20): string[] {
  if (!existsSync(projectDirPath)) return [];
  try {
    const entries = readdirSync(projectDirPath)
      .filter(f => f.endsWith('.jsonl'))
      .map(f => ({ name: f.replace('.jsonl', ''), path: join(projectDirPath, f) }));
    entries.sort((a, b) => {
      try { return statSync(b.path).mtimeMs - statSync(a.path).mtimeMs; }
      catch { return 0; }
    });
    return entries.slice(0, limit).map(e => e.name);
  } catch { return []; }
}

function createAccumulator(): ParseAccumulator {
  return {
    timeline: [],
    totalTokens: { input_tokens: 0, output_tokens: 0, cache_creation_input_tokens: 0, cache_read_input_tokens: 0 },
    toolCounts: new Map(), hookCounts: new Map(), agents: [],
    messageCount: 0, startTime: '', endTime: '', sessionId: '',
  };
}

function trackTimestamp(acc: ParseAccumulator, ts: string): void {
  if (!ts) return;
  if (!acc.startTime || ts < acc.startTime) acc.startTime = ts;
  if (ts > acc.endTime) acc.endTime = ts;
}

function processHookEntry(acc: ParseAccumulator, entry: Record<string, unknown>, ts: string): void {
  const data = entry.data as Record<string, string> | undefined;
  const hookName = data?.hookName || data?.hookEvent || 'unknown';
  acc.hookCounts.set(hookName, (acc.hookCounts.get(hookName) || 0) + 1);
  acc.timeline.push({ timestamp: ts, type: 'hook', name: hookName });
}

function getToolDetail(name: string, input: Record<string, string> | undefined): string | undefined {
  if (!input) return undefined;
  if (name === 'Bash') return input.command?.slice(0, 100);
  if (['Read', 'Edit', 'Write'].includes(name)) return input.file_path;
  if (name === 'Grep' || name === 'Glob') return input.pattern;
  return undefined;
}

function processToolBlock(acc: ParseAccumulator, block: Record<string, unknown>, ts: string, usage?: SessionTokenUsage): void {
  const toolName = (block.name as string) || 'unknown';
  acc.toolCounts.set(toolName, (acc.toolCounts.get(toolName) || 0) + 1);
  const input = block.input as Record<string, string> | undefined;

  if (toolName === 'Task') {
    acc.agents.push({ id: (block.id as string) || '', type: input?.subagent_type });
    acc.timeline.push({
      timestamp: ts, type: 'agent_spawn', name: input?.subagent_type || 'unknown',
      details: input?.description, tokens: usage ? { ...usage } : undefined,
    });
  } else {
    acc.timeline.push({
      timestamp: ts, type: 'tool_call', name: toolName,
      details: getToolDetail(toolName, input),
    });
  }
}

function processAssistantMessage(acc: ParseAccumulator, msg: Record<string, unknown>, ts: string): void {
  acc.messageCount++;
  const usage = msg.usage as SessionTokenUsage | undefined;
  if (usage) {
    acc.totalTokens.input_tokens += usage.input_tokens || 0;
    acc.totalTokens.output_tokens += usage.output_tokens || 0;
    acc.totalTokens.cache_creation_input_tokens += usage.cache_creation_input_tokens || 0;
    acc.totalTokens.cache_read_input_tokens += usage.cache_read_input_tokens || 0;
  }
  const blocks = msg.content as Record<string, unknown>[] | undefined;
  if (!Array.isArray(blocks)) return;
  for (const block of blocks) {
    if (block.type === 'tool_use') processToolBlock(acc, block, ts, usage);
  }
}

function buildSummary(acc: ParseAccumulator, filePath: string): ParsedSession {
  const totalCache = acc.totalTokens.cache_creation_input_tokens + acc.totalTokens.cache_read_input_tokens;
  const cacheHitRate = totalCache > 0 ? (acc.totalTokens.cache_read_input_tokens / totalCache) * 100 : 0;
  const durationMs = acc.startTime && acc.endTime
    ? new Date(acc.endTime).getTime() - new Date(acc.startTime).getTime() : 0;

  const toolCalls = [...acc.toolCounts.entries()]
    .map(([name, count]) => ({ name, count })).sort((a, b) => b.count - a.count);
  const hookEvents = [...acc.hookCounts.entries()]
    .map(([name, count]) => ({ name, count })).sort((a, b) => b.count - a.count);
  acc.timeline.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

  return {
    summary: {
      sessionId: acc.sessionId || basename(filePath, '.jsonl'),
      startTime: acc.startTime, endTime: acc.endTime, durationMs,
      branch: acc.branch, version: acc.version, totalTokens: acc.totalTokens,
      toolCalls, agentSpawns: acc.agents, hookEvents,
      messageCount: acc.messageCount, cacheHitRate: Math.round(cacheHitRate * 10) / 10,
    },
    timeline: acc.timeline,
  };
}

/** Parse a CC session JSONL file and extract analytics data. */
export function parseSession(sessionFilePath: string): ParsedSession | null {
  if (!existsSync(sessionFilePath)) return null;
  try {
    const lines = readFileSync(sessionFilePath, 'utf8').split('\n').filter(Boolean);
    const acc = createAccumulator();

    for (const line of lines) {
      try {
        const entry = JSON.parse(line) as Record<string, unknown>;
        const ts = (entry.timestamp as string) || '';
        trackTimestamp(acc, ts);
        if (entry.sessionId && !acc.sessionId) acc.sessionId = entry.sessionId as string;
        if (entry.gitBranch && !acc.branch) acc.branch = entry.gitBranch as string;
        if (entry.version && !acc.version) acc.version = entry.version as string;

        if (entry.type === 'progress' && (entry.data as Record<string, string>)?.type === 'hook_progress') {
          processHookEntry(acc, entry, ts);
        } else if ((entry.message as Record<string, string>)?.role === 'assistant') {
          processAssistantMessage(acc, entry.message as Record<string, unknown>, ts);
        } else if ((entry.message as Record<string, string>)?.role === 'user') {
          acc.messageCount++;
        }
      } catch { }
    }
    return buildSummary(acc, sessionFilePath);
  } catch { return null; }
}

/** Get the stats-cache.json data (CC's pre-aggregated metrics). */
export function getStatsCache(): Record<string, unknown> | null {
  const statsPath = join(getHomeDir(), '.claude', 'stats-cache.json');
  if (!existsSync(statsPath)) return null;
  try { return JSON.parse(readFileSync(statsPath, 'utf8')); }
  catch { return null; }
}

/** Resolve "latest" or partial session ID to full session file path. */
export function resolveSessionPath(sessionRef: string, projectPath?: string): string | null {
  const projDir = findProjectDir(projectPath);
  if (!projDir) return null;

  if (sessionRef === 'latest') {
    const sessions = listSessions(projDir, 1);
    return sessions.length > 0 ? join(projDir, `${sessions[0]}.jsonl`) : null;
  }

  const exactPath = join(projDir, `${sessionRef}.jsonl`);
  if (existsSync(exactPath)) return exactPath;

  const match = listSessions(projDir, 100).find(s => s.startsWith(sessionRef));
  return match ? join(projDir, `${match}.jsonl`) : null;
}
