// Generated by OrchestKit Claude Plugin
// Created: 2026-02-05

/**
 * Model Cost Advisor - SubagentStart Hook
 * Opus 4.6 Upgrade: Analyzes task complexity and recommends optimal model.
 *
 * Uses skill `complexity` field and task description keywords to detect
 * when an expensive model (opus) is being used for simple tasks,
 * or when a cheap model (haiku) is used for complex tasks.
 *
 * Addresses: Issue #331
 * Version: 1.0.0
 */

import { appendFileSync, mkdirSync } from 'node:fs';
import { join, dirname } from 'node:path';
import type { HookInput, HookResult } from '../types.js';
import { outputSilentSuccess, outputWarning, logHook, getProjectDir } from '../lib/common.js';

// Agent model assignments from agent definitions
const OPUS_AGENTS = new Set([
  'backend-system-architect', 'infrastructure-architect', 'workflow-architect',
  'event-driven-architect', 'python-performance-engineer', 'ai-safety-auditor',
]);

const SONNET_AGENTS = new Set([
  'demo-producer',
]);

// Keywords signaling high complexity (should use opus)
const HIGH_COMPLEXITY_SIGNALS = [
  /security|vulnerab|audit|penetration/i,
  /architect|design.*system|distributed/i,
  /migration.*schema|database.*design/i,
  /performance.*optim|profil|bottleneck/i,
  /langgraph|workflow.*orchestrat/i,
];

// Keywords signaling low complexity (safe for haiku)
const LOW_COMPLEXITY_SIGNALS = [
  /list|count|check|verify|read|search/i,
  /simple|straightforward|quick/i,
  /format|lint|style|typo|rename/i,
  /status|progress|summary/i,
];

interface ModelAdvice {
  recommended: string;
  current: string;
  reason: string;
  savingsPercent: number;
}

/**
 * Detect task complexity from description and agent type
 */
function analyzeComplexity(agentType: string, description: string): 'low' | 'medium' | 'high' {
  // Check high-complexity signals
  const highMatches = HIGH_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;
  if (highMatches >= 2 || OPUS_AGENTS.has(agentType)) return 'high';

  // Check low-complexity signals
  const lowMatches = LOW_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;
  if (lowMatches >= 2) return 'low';

  return 'medium';
}

/**
 * Determine current model for agent
 */
function getCurrentModel(agentType: string): string {
  if (OPUS_AGENTS.has(agentType)) return 'opus';
  if (SONNET_AGENTS.has(agentType)) return 'sonnet';
  // 'inherit' agents use the parent's model
  return process.env.CLAUDE_MODEL || 'sonnet';
}

/**
 * Get model recommendation
 */
function getModelAdvice(agentType: string, description: string): ModelAdvice | null {
  const complexity = analyzeComplexity(agentType, description);
  const current = getCurrentModel(agentType);

  // High complexity task on cheap model → recommend upgrade
  if (complexity === 'high' && current === 'haiku') {
    return {
      recommended: 'sonnet',
      current,
      reason: 'High-complexity task detected — haiku may produce lower quality results',
      savingsPercent: 0,
    };
  }

  // Low complexity task on expensive model → recommend downgrade
  if (complexity === 'low' && current === 'opus') {
    return {
      recommended: 'sonnet',
      current,
      reason: 'Simple task detected — sonnet handles this equally well at lower cost',
      savingsPercent: 40,
    };
  }

  // Medium complexity on opus → suggest sonnet for cost savings
  if (complexity === 'medium' && current === 'opus' && !OPUS_AGENTS.has(agentType)) {
    return {
      recommended: 'sonnet',
      current,
      reason: 'Medium-complexity task — sonnet is sufficient, Opus adds cost without benefit',
      savingsPercent: 30,
    };
  }

  return null; // No recommendation needed
}

/**
 * Log model usage for analytics
 */
function logModelUsage(agentType: string, model: string, complexity: string, advice: ModelAdvice | null): void {
  const logFile = join(getProjectDir(), '.claude', 'logs', 'model-usage.jsonl');
  try {
    mkdirSync(dirname(logFile), { recursive: true });
    const entry = {
      timestamp: new Date().toISOString(),
      agent: agentType,
      model,
      complexity,
      recommendation: advice?.recommended || null,
      potentialSavings: advice?.savingsPercent || 0,
    };
    appendFileSync(logFile, JSON.stringify(entry) + '\n');
  } catch {
    // Non-critical, ignore
  }
}

/**
 * Model cost advisor hook — runs at SubagentStart
 */
export function modelCostAdvisor(input: HookInput): HookResult {
  const toolInput = input.tool_input || {};
  const agentType = (toolInput.subagent_type as string) || '';
  const description = (toolInput.description as string) || '';

  if (!agentType) {
    return outputSilentSuccess();
  }

  const complexity = analyzeComplexity(agentType, description);
  const currentModel = getCurrentModel(agentType);
  const advice = getModelAdvice(agentType, description);

  // Log usage for analytics
  logModelUsage(agentType, currentModel, complexity, advice);

  if (!advice) {
    logHook('model-cost-advisor', `${agentType}: ${currentModel} is appropriate for ${complexity} task`);
    return outputSilentSuccess();
  }

  logHook('model-cost-advisor',
    `${agentType}: Recommend ${advice.recommended} instead of ${advice.current} (${advice.reason})`,
    'info'
  );

  // Only show warning for significant cost savings (>= 30%)
  if (advice.savingsPercent >= 30) {
    return outputWarning(
      `Model cost optimization: ${agentType} using ${advice.current} for ${complexity}-complexity task. ` +
      `${advice.reason}. Potential savings: ~${advice.savingsPercent}%. ` +
      `Consider using model: "${advice.recommended}" for this agent.`
    );
  }

  return outputSilentSuccess();
}
