// Generated by OrchestKit Claude Plugin
// Created: 2026-02-20

/**
 * Unified SubagentStart Dispatcher
 * Consolidates 7 SubagentStart hooks into a single process spawn.
 *
 * Issue #685: Reduces 7 separate process spawns to 1 for SubagentStart.
 *
 * Hooks consolidated here (execution order):
 * Phase 1 — Blocking:
 *   - context-gate (can block when too many concurrent agents)
 * Phase 2 — Validation + tracking:
 *   - subagent-validator (validates agent type, logs spawn, permission profile)
 * Phase 3 — Context injection (budget-capped):
 *   - subagent-context-stager (CLAUDE.md rules, pending tasks, decisions)
 *   - graph-memory-inject (knowledge graph context)
 *   - task-linker (orchestration task linking)
 *   - model-cost-advisor (cost optimization warnings)
 *   - issue-context-injector (GitHub issue context from branch name)
 *
 * CC 2.1.49 Compliant: Single consolidated output with 800-token budget
 */

import type { HookInput, HookResult } from '../types.js';
import {
  outputSilentSuccess,
  logHook,
  estimateTokenCount,
  extractContext,
} from '../lib/common.js';

// Import hook implementations
import { contextGate } from './context-gate.js';
import { subagentValidator } from './subagent-validator.js';
import { subagentContextStager } from './subagent-context-stager.js';
import { graphMemoryInject } from './graph-memory-inject.js';
import { taskLinker } from './task-linker.js';
import { modelCostAdvisor } from './model-cost-advisor.js';
import { issueContextInjector } from './issue-context-injector.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'subagent-start-dispatcher';

/** Maximum total tokens for consolidated context output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface ContextHookConfig {
  name: string;
  fn: HookFn;
}

// -----------------------------------------------------------------------------
// Hook Registry — context-producing hooks (Phase 3)
// -----------------------------------------------------------------------------

const CONTEXT_HOOKS: ContextHookConfig[] = [
  { name: 'subagent-context-stager', fn: subagentContextStager },
  { name: 'graph-memory-inject', fn: graphMemoryInject },
  { name: 'task-linker', fn: taskLinker },
  { name: 'model-cost-advisor', fn: modelCostAdvisor },
  { name: 'issue-context-injector', fn: issueContextInjector },
];

/** Exposed for testing */
export const registeredHookNames = () => [
  'context-gate',
  'subagent-validator',
  ...CONTEXT_HOOKS.map(h => h.name),
];

// extractContext imported from ../lib/common.js (Issue #682)

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

export function unifiedSubagentStartDispatcher(input: HookInput): HookResult {
  // --- Phase 1: Blocking check (context-gate) ---
  try {
    const gateResult = contextGate(input);
    if (!gateResult.continue) {
      logHook(HOOK_NAME, 'context-gate blocked agent spawn');
      return gateResult;
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logHook(HOOK_NAME, `context-gate failed: ${message}`, 'warn');
  }

  // --- Phase 2: Validation + tracking (subagent-validator) ---
  let validatorContext: string | null = null;
  try {
    const validatorResult = subagentValidator(input);
    validatorContext = extractContext(validatorResult);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logHook(HOOK_NAME, `subagent-validator failed: ${message}`, 'warn');
  }

  // --- Phase 3: Context injection hooks (budget-capped) ---
  const contextParts: string[] = [];
  const systemMessages: string[] = [];
  let totalTokens = 0;

  // Add validator context first (high priority — permission profile)
  if (validatorContext) {
    const tokens = estimateTokenCount(validatorContext);
    contextParts.push(validatorContext);
    totalTokens += tokens;
  }

  for (const hook of CONTEXT_HOOKS) {
    try {
      const result = hook.fn(input);

      // Collect systemMessage separately (merged at end)
      if (result.systemMessage && typeof result.systemMessage === 'string') {
        systemMessages.push(result.systemMessage);
      }

      // Collect additionalContext with budget enforcement
      const context = result.hookSpecificOutput?.additionalContext as string | undefined;
      if (context) {
        const contextTokens = estimateTokenCount(context);
        if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
          logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
          continue;
        }
        contextParts.push(context);
        totalTokens += contextTokens;
        logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // --- Combine results ---
  const hasContext = contextParts.length > 0;
  const hasSystemMessage = systemMessages.length > 0;

  if (!hasContext && !hasSystemMessage) {
    return outputSilentSuccess();
  }

  const result: HookResult = { continue: true };

  if (hasSystemMessage) {
    // Intentional: concatenate all system messages. In practice only subagent-validator
    // emits systemMessage (permission profile). If multiple hooks emit, first-wins may
    // be preferable — monitor for verbose output.
    result.systemMessage = systemMessages.join('\n\n');
  }

  if (hasContext) {
    const consolidated = contextParts.join('\n\n---\n\n');
    logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);
    result.hookSpecificOutput = {
      additionalContext: consolidated,
    };
  }

  return result;
}
