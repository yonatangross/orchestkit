// Generated by OrchestKit Claude Plugin
// Created: 2026-02-13

/**
 * Unified PostToolUse Write|Edit Quality Dispatcher
 * Issue #453: PostToolUse Hook Consolidation
 *
 * Consolidates 4 Write|Edit PostToolUse hooks into a single dispatcher
 * to reduce process spawns per file write.
 *
 * Hooks consolidated here:
 * - auto-lint (can produce systemMessage)
 * - readme-sync (produces additionalContext)
 * - merge-conflict-predictor (produces additionalContext)
 * - coverage-predictor (can produce systemMessage)
 *
 * CC 2.1.34 Compliant: Single hook entry with merged output
 */

import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  logHook,
  estimateTokenCount,
  extractContext,
} from '../../lib/common.js';

// Import hook implementations
import { autoLint } from '../auto-lint.js';
import { readmeSync } from './readme-sync.js';
import { mergeConflictPredictor } from '../../skill/merge-conflict-predictor.js';
import { coveragePredictor } from './coverage-predictor.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'posttool-write-quality-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface WriteHookConfig {
  name: string;
  fn: HookFn;
}

// -----------------------------------------------------------------------------
// Hook Registry
// -----------------------------------------------------------------------------

const WRITE_HOOKS: WriteHookConfig[] = [
  { name: 'auto-lint', fn: autoLint },
  { name: 'readme-sync', fn: readmeSync },
  { name: 'merge-conflict-predictor', fn: mergeConflictPredictor },
  { name: 'coverage-predictor', fn: coveragePredictor },
];

/** Exposed for testing */
export const registeredHookNames = () => WRITE_HOOKS.map(h => h.name);

// extractContext imported from ../../lib/common.js (Issue #682)

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher for Write|Edit PostToolUse hooks.
 *
 * Runs all hooks, merges their context outputs with budget cap.
 */
export function unifiedWriteQualityDispatcher(input: HookInput): HookResult {
  const contextParts: string[] = [];
  let totalTokens = 0;

  for (const hook of WRITE_HOOKS) {
    try {
      const result = hook.fn(input);

      // Check for blocking results (shouldn't happen in PostToolUse, but be safe)
      if (!result.continue && result.continue !== undefined) {
        logHook(HOOK_NAME, `${hook.name} returned continue:false (unexpected in PostToolUse)`);
        continue;
      }

      const context = extractContext(result);
      if (!context) continue;

      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  if (contextParts.length === 0) {
    return outputSilentSuccess();
  }

  const consolidated = contextParts.join('\n');
  logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);

  return {
    continue: true,
    hookSpecificOutput: {
      hookEventName: 'PostToolUse',
      additionalContext: consolidated,
    },
  };
}
