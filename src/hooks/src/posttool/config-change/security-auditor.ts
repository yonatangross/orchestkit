// Generated by OrchestKit Claude Plugin
// Created: 2026-02-20

/**
 * Config Change Security Auditor - Audits Write|Edit ops targeting .claude/ config files
 * Hook: PostToolUse (Write|Edit)
 * CC 2.1.7 Compliant
 *
 * Issue #772: Provides security visibility when Claude modifies its own configuration.
 * Logs all config changes to .claude/logs/config-audit.jsonl and flags dangerous patterns.
 */

import { existsSync, mkdirSync } from 'node:fs';
import { bufferWrite } from '../../lib/analytics-buffer.js';
import type { HookInput, HookResult } from '../../types.js';
import { outputSilentSuccess, logHook, getProjectDir, getField } from '../../lib/common.js';

/** Patterns that indicate potentially dangerous config modifications */
const DANGEROUS_PATTERNS = [
  { pattern: /"allow"\s*:.*"Bash"/, label: 'permission-escalation: Bash added to allow list' },
  { pattern: /--no-verify/, label: 'hook-bypass: --no-verify detected' },
  { pattern: /["'](API_KEY|SECRET_KEY|AUTH_TOKEN|DB_PASSWORD)["']\s*[:=]/i, label: 'secret-exposure: credential key in config' },
  { pattern: /"deny"\s*:\s*\[\s*\]/, label: 'permission-gap: empty deny list' },
];

/**
 * Check if a file path targets a .claude/ configuration file
 */
function isClaudeConfig(filePath: string): boolean {
  if (!filePath) return false;
  const normalized = filePath.replace(/\\/g, '/');
  // Match .claude/ as directory component in absolute or relative paths
  return /\/\.claude(\/|$)/.test(normalized) || normalized.startsWith('.claude/');
}

/**
 * Detect dangerous patterns in file content
 */
function detectDangerousPatterns(content: string): string[] {
  const findings: string[] = [];
  for (const { pattern, label } of DANGEROUS_PATTERNS) {
    if (pattern.test(content)) {
      findings.push(label);
    }
  }
  return findings;
}

/**
 * Main hook: audit .claude/ config file modifications
 */
export function configChangeAuditor(input: HookInput): HookResult {
  const toolName = input.tool_name || '';

  // Only audit Write and Edit operations
  if (toolName !== 'Write' && toolName !== 'Edit') {
    return outputSilentSuccess();
  }

  const filePath = getField<string>(input, 'tool_input.file_path') || '';

  // Skip if not targeting .claude/ config
  if (!isClaudeConfig(filePath)) {
    return outputSilentSuccess();
  }

  const projectDir = getProjectDir();
  const logDir = `${projectDir}/.claude/logs`;
  const auditFile = `${logDir}/config-audit.jsonl`;

  try {
    // Ensure log directory exists
    if (!existsSync(logDir)) {
      mkdirSync(logDir, { recursive: true });
    }

    // Build audit entry
    const entry = {
      timestamp: new Date().toISOString(),
      tool: toolName,
      file: filePath,
      session_id: input.session_id || 'unknown',
    };

    // Log the config change
    bufferWrite(auditFile, `${JSON.stringify(entry)}\n`);
    logHook('config-change-auditor', `Config change: ${toolName} -> ${filePath}`);

    // Check for dangerous patterns in the content being written/edited
    const content =
      getField<string>(input, 'tool_input.content') ||
      getField<string>(input, 'tool_input.new_string') ||
      '';

    if (!content) {
      logHook('config-change-auditor', `Warning: empty content for ${toolName} on ${filePath} â€” pattern detection skipped`);
    }

    const findings = detectDangerousPatterns(content);

    if (findings.length > 0) {
      const auditNote = `Config audit: ${findings.join('; ')} in ${filePath}`;
      logHook('config-change-auditor', `DANGEROUS: ${auditNote}`, 'warn');
    }
  } catch (err) {
    // Never block on audit errors
    logHook('config-change-auditor', `Error: ${(err as Error).message}`, 'error');
  }

  return outputSilentSuccess();
}
