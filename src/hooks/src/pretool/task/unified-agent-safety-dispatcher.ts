// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Unified Agent Safety Dispatcher — PreToolUse Task Hook
 * Consolidates 5 agent-scoped hooks into a single dispatcher to reduce process spawns.
 *
 * Hooks consolidated here:
 * - block-writes (agent-scoped — can block)
 * - migration-safety-check (agent-scoped — can block)
 * - security-command-audit (agent-scoped — audit logging)
 * - ci-safety-check (agent-scoped — can block)
 * - deployment-safety-check (agent-scoped — can block)
 *
 * NOT consolidated (remains separate in hooks.json):
 * - team-size-gate (Agent Teams gate, different concern)
 *
 * CC 2.1.7 Compliant: Returns first blocking result, or merged context
 */

import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  outputAllowWithContext,
  logHook,
  estimateTokenCount,
} from '../../lib/common.js';

// Import hook implementations
import { blockWrites } from '../../agent/block-writes.js';
import { migrationSafetyCheck } from '../../agent/migration-safety-check.js';
import { securityCommandAudit } from '../../agent/security-command-audit.js';
import { ciSafetyCheck } from '../../agent/ci-safety-check.js';
import { deploymentSafetyCheck } from '../../agent/deployment-safety-check.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'pretool-task-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface SafetyHookConfig {
  name: string;
  fn: HookFn;
  /** Whether this hook can block (deny) operations */
  canBlock: boolean;
}

// -----------------------------------------------------------------------------
// Hook Registry
// Ordering: blocking hooks first, then audit/advisory
// -----------------------------------------------------------------------------

const SAFETY_HOOKS: SafetyHookConfig[] = [
  { name: 'block-writes', fn: blockWrites, canBlock: true },
  { name: 'migration-safety-check', fn: migrationSafetyCheck, canBlock: true },
  { name: 'ci-safety-check', fn: ciSafetyCheck, canBlock: true },
  { name: 'deployment-safety-check', fn: deploymentSafetyCheck, canBlock: true },
  { name: 'security-command-audit', fn: securityCommandAudit, canBlock: false },
];

/** Exposed for testing */
export const registeredHookNames = () => SAFETY_HOOKS.map(h => h.name);

// -----------------------------------------------------------------------------
// Context Extraction
// -----------------------------------------------------------------------------

/**
 * Extract additionalContext from a hook result.
 */
function extractContext(result: HookResult): string | null {
  if (result.hookSpecificOutput?.additionalContext) {
    return result.hookSpecificOutput.additionalContext as string;
  }
  if (result.systemMessage && typeof result.systemMessage === 'string') {
    return result.systemMessage;
  }
  return null;
}

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher for agent safety PreToolUse Task hooks.
 *
 * Runs all hooks sequentially. If any blocking hook denies, returns immediately.
 * Otherwise, merges context from advisory hooks.
 */
export function unifiedAgentSafetyDispatcher(input: HookInput): HookResult {
  const contextParts: string[] = [];
  let totalTokens = 0;

  for (const hook of SAFETY_HOOKS) {
    try {
      const result = hook.fn(input);

      // If hook blocks, return immediately
      if (!result.continue) {
        logHook(HOOK_NAME, `${hook.name} blocked operation`);
        return result;
      }

      // Collect context if produced
      const context = extractContext(result);
      if (!context) continue;

      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;
      logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // No context produced
  if (contextParts.length === 0) {
    return outputSilentSuccess();
  }

  // Single consolidated output
  const consolidated = contextParts.join('\n\n---\n\n');
  logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);
  return outputAllowWithContext(consolidated);
}
