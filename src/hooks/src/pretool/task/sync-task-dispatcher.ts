// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync Task Dispatcher — PreToolUse Task Hook
 * Consolidates 2 Task PreToolUse hooks into a single dispatcher.
 *
 * Consolidated hooks (security-first order):
 * - unified-agent-safety-dispatcher (agent safety checks — FIRST)
 * - team-size-gate (limits team size — SECOND)
 *
 * SHORT-CIRCUIT: On first block, returns immediately without running remaining hooks.
 * Merges additionalContext from all passing hooks into a single output.
 *
 * CC 2.1.9 Compliant: Single PreToolUse dispatcher with merged additionalContext
 */

import type { HookInput, HookResult } from '../../types.js';
import { outputSilentSuccess, logHook, extractContext } from '../../lib/common.js';

// Import consolidated hook implementations
import { unifiedAgentSafetyDispatcher } from './unified-agent-safety-dispatcher.js';
import { teamSizeGate } from './team-size-gate.js';

const HOOK_NAME = 'sync-task-dispatcher';

interface TaskHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult;
}

/**
 * Registry of Task PreToolUse hooks, executed in security-first order.
 * Agent safety dispatcher runs first to catch all safety violations.
 */
const TASK_HOOKS: TaskHookConfig[] = [
  { name: 'unified-agent-safety-dispatcher', fn: unifiedAgentSafetyDispatcher },
  { name: 'team-size-gate', fn: teamSizeGate },
];

/**
 * Consolidated sync Task PreToolUse dispatcher.
 *
 * Execution order:
 * 1. unified-agent-safety-dispatcher (can block — agent safety checks)
 * 2. team-size-gate (can block — team size limits)
 *
 * On first block: SHORT-CIRCUIT immediately.
 * On pass: merge additionalContext from all hooks.
 */
export function syncTaskDispatcher(input: HookInput): HookResult {
  const contextParts: string[] = [];

  for (const hook of TASK_HOOKS) {
    try {
      const result = hook.fn(input);

      if (!result.continue) {
        logHook(HOOK_NAME, `${hook.name} blocked — short-circuiting`);
        return result;
      }

      const context = extractContext(result);
      if (context) {
        contextParts.push(context);
        logHook(HOOK_NAME, `${hook.name}: additionalContext collected`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
    }
  }

  if (contextParts.length === 0) {
    logHook(HOOK_NAME, 'All hooks silent');
    return outputSilentSuccess();
  }

  const mergedContext = contextParts.join('\n\n---\n\n');
  logHook(HOOK_NAME, `Merged ${contextParts.length} context(s)`);
  return {
    continue: true,
    suppressOutput: true,
    hookSpecificOutput: {
      additionalContext: mergedContext,
      hookEventName: 'PreToolUse',
    },
  };
}
