// Generated by OrchestKit Claude Plugin
// Created: 2026-02-10

/**
 * TLDR Summary — PreToolUse[Read] Hook
 *
 * Intercepts Read calls on large files (>500 lines or >2000 tokens) and
 * injects a structural summary as additionalContext. Claude sees the
 * summary as a roadmap alongside the full file content.
 *
 * All error paths return silent success — never blocks a Read.
 *
 * @hook PreToolUse[Read]
 * @since v6.0.4
 * @see #463
 */

import { existsSync, readFileSync, statSync } from 'node:fs';
import type { HookInput, HookResult } from '../../types.js';
import {
  outputAllowWithContext,
  outputSilentSuccess,
  logHook,
  estimateTokenCount,
} from '../../lib/common.js';
import { isSummarizable, summarizeCode } from '../../lib/code-summarizer.js';

const HOOK_NAME = 'tldr-summary';
const LINE_THRESHOLD = 500;
const TOKEN_THRESHOLD = 2000;
const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2MB safety cap

export function tldrSummary(input: HookInput): HookResult {
  try {
    const toolInput = input.tool_input || {};
    const filePath = toolInput.file_path as string | undefined;

    // Guard: no file path
    if (!filePath) {
      return outputSilentSuccess();
    }

    // Guard: targeted read (offset/limit set) — don't interfere with chunked reads
    if (toolInput.offset !== undefined || toolInput.limit !== undefined) {
      return outputSilentSuccess();
    }

    // Guard: unsupported extension
    const dotIdx = filePath.lastIndexOf('.');
    if (dotIdx === -1) {
      return outputSilentSuccess();
    }
    const ext = filePath.slice(dotIdx).toLowerCase();
    if (!isSummarizable(ext)) {
      return outputSilentSuccess();
    }

    // Guard: file doesn't exist
    if (!existsSync(filePath)) {
      return outputSilentSuccess();
    }

    // Guard: file too large (>2MB)
    const stats = statSync(filePath);
    if (stats.size > MAX_FILE_SIZE) {
      logHook(HOOK_NAME, `Skipping ${filePath}: ${stats.size} bytes > 2MB cap`);
      return outputSilentSuccess();
    }

    // Read file content
    const content = readFileSync(filePath, 'utf8');

    // Guard: small file — below both thresholds
    const lineCount = content.split('\n').length;
    const tokenCount = estimateTokenCount(content);
    if (lineCount < LINE_THRESHOLD && tokenCount < TOKEN_THRESHOLD) {
      return outputSilentSuccess();
    }

    // Generate summary
    const summary = summarizeCode(content, filePath);
    if (!summary) {
      return outputSilentSuccess();
    }

    logHook(HOOK_NAME, `Injecting summary for ${filePath} (${lineCount} lines, ~${tokenCount} tokens)`);
    return outputAllowWithContext(summary);
  } catch (err) {
    // Never block a Read — log and pass through
    logHook(HOOK_NAME, `Error: ${err instanceof Error ? err.message : String(err)}`, 'warn');
    return outputSilentSuccess();
  }
}
