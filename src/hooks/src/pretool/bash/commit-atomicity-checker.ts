// Generated by OrchestKit Claude Plugin
// Created: 2026-02-15

/**
 * Commit Atomicity Checker - Heuristic check for atomic commits
 * Hook: PreToolUse (Bash) — matcher: Bash(git commit*)
 *
 * Replaces the LLM prompt-based atomicity check with fast heuristics:
 * - File count: >10 staged files → warn
 * - Directory spread: >3 distinct top-level dirs → warn
 * - Type mixing: files span src/ + docs/ + config/ (3+ categories) → warn
 * - "And" test: commit message contains " and " → warn
 *
 * Zero LLM calls, zero network — pure local heuristics.
 */

import { execSync } from 'node:child_process';
import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  outputAllowWithContext,
  logHook,
  getProjectDir,
} from '../../lib/common.js';

const HOOK_NAME = 'commit-atomicity-checker';

/** Threshold for staged file count warning */
const MAX_FILES = 10;

/** Threshold for distinct top-level directory count */
const MAX_DIRS = 3;

/**
 * Category buckets for type-mixing detection.
 * A file is assigned to a category based on its path prefix.
 */
const CATEGORY_PREFIXES: Record<string, string> = {
  'src/': 'source',
  'lib/': 'source',
  'app/': 'source',
  'docs/': 'docs',
  'doc/': 'docs',
  'test/': 'tests',
  'tests/': 'tests',
  '__tests__/': 'tests',
  'spec/': 'tests',
  'config/': 'config',
  '.github/': 'config',
  'scripts/': 'config',
};

/**
 * Get the category for a file path based on its prefix.
 */
function getCategory(filePath: string): string {
  for (const [prefix, category] of Object.entries(CATEGORY_PREFIXES)) {
    if (filePath.startsWith(prefix)) {
      return category;
    }
  }
  return 'other';
}

/**
 * Extract commit message from a git commit command string.
 * Handles: -m "msg", -m 'msg', -m msg, --message="msg", --message 'msg'
 */
function extractCommitMessage(command: string): string | null {
  // Match -m "..." or -m '...' or --message="..." or --message '...'
  const patterns = [
    /-m\s+"([^"]+)"/,
    /-m\s+'([^']+)'/,
    /--message="([^"]+)"/,
    /--message='([^']+)'/,
    /--message\s+"([^"]+)"/,
    /--message\s+'([^']+)'/,
    /-m\s+([^\s"'-][^\s]*)/,
  ];

  for (const pattern of patterns) {
    const match = command.match(pattern);
    if (match) return match[1];
  }
  return null;
}

/**
 * Get staged file list from git index. Returns null on error.
 */
function getStagedFiles(cwd: string): string[] | null {
  try {
    const output = execSync('git diff --cached --name-only', {
      cwd,
      encoding: 'utf8',
      timeout: 5000,
      stdio: ['pipe', 'pipe', 'pipe'],
    });
    return output.trim().split('\n').filter(Boolean);
  } catch {
    logHook(HOOK_NAME, 'Failed to get staged files, skipping check', 'warn');
    return null;
  }
}

/**
 * Collect atomicity warnings for the given staged files and commit command.
 */
function collectWarnings(stagedFiles: string[], command: string): string[] {
  const warnings: string[] = [];

  if (stagedFiles.length > MAX_FILES) {
    warnings.push(`${stagedFiles.length} staged files (>${MAX_FILES}) — verify all changes are related`);
  }

  const topLevelDirs = new Set(
    stagedFiles.map(f => f.includes('/') ? f.split('/')[0] : '(root)'),
  );
  if (topLevelDirs.size > MAX_DIRS) {
    warnings.push(`Changes span ${topLevelDirs.size} top-level dirs (${[...topLevelDirs].join(', ')}) — may mix concerns`);
  }

  const categories = new Set(stagedFiles.map(getCategory));
  if (categories.size >= 3) {
    warnings.push(`Mixed change types: ${[...categories].join(', ')} — consider splitting`);
  }

  const message = extractCommitMessage(command);
  if (message && /\band\b/i.test(message)) {
    warnings.push(`Commit message contains "and" — may describe multiple concerns`);
  }

  return warnings;
}

/**
 * Heuristic atomicity checker for git commit commands.
 */
export function commitAtomicityChecker(input: HookInput): HookResult {
  try {
    const command = input.tool_input.command || '';
    if (!command) return outputSilentSuccess();

    const cwd = input.project_dir || getProjectDir();
    const stagedFiles = getStagedFiles(cwd);
    if (!stagedFiles || stagedFiles.length === 0) return outputSilentSuccess();

    const warnings = collectWarnings(stagedFiles, command);
    if (warnings.length === 0) return outputSilentSuccess();

    const context = `Atomicity check:\n${warnings.map(w => `- ${w}`).join('\n')}\n\nConsider splitting into atomic commits if these are unrelated changes.`;
    logHook(HOOK_NAME, `${warnings.length} warning(s) for commit`);
    return outputAllowWithContext(context);
  } catch {
    logHook(HOOK_NAME, 'Unexpected error, falling back to silent success', 'warn');
    return outputSilentSuccess();
  }
}
