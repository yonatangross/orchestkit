// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync Bash Dispatcher — PreToolUse Bash Hook
 * Consolidates 3 Bash PreToolUse hooks into a single dispatcher.
 *
 * Consolidated hooks (security-first order):
 * - dangerous-command-blocker (blocks rm -rf, sudo, force push etc — FIRST)
 * - compound-command-validator (validates chained commands — SECOND)
 * - unified-advisory-dispatcher (advisory guidance — LAST)
 *
 * SHORT-CIRCUIT: On first block, returns immediately without running remaining hooks.
 * Merges additionalContext from all passing hooks into a single output.
 *
 * CC 2.1.9 Compliant: Single PreToolUse dispatcher with merged additionalContext
 */

import type { HookInput, HookResult } from '../../types.js';
import { outputSilentSuccess, outputWithUpdatedInput, logHook, extractContext } from '../../lib/common.js';

// Import consolidated hook implementations
import { dangerousCommandBlocker } from './dangerous-command-blocker.js';
import { compoundCommandValidator } from './compound-command-validator.js';
import { unifiedBashAdvisoryDispatcher } from './unified-advisory-dispatcher.js';

const HOOK_NAME = 'sync-bash-dispatcher';

interface BlockingHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult;
}

/**
 * Registry of Bash PreToolUse hooks, executed in security-first order.
 * Blockers run first; advisory dispatcher runs last.
 */
const BASH_HOOKS: BlockingHookConfig[] = [
  { name: 'dangerous-command-blocker', fn: dangerousCommandBlocker },
  { name: 'compound-command-validator', fn: compoundCommandValidator },
  { name: 'unified-advisory-dispatcher', fn: unifiedBashAdvisoryDispatcher },
];

/**
 * Build the merged HookResult from collected context parts and optional updatedInput.
 */
function buildMergedResult(
  contextParts: string[],
  updatedInput: Record<string, unknown> | undefined,
): HookResult {
  const mergedContext = contextParts.length > 0 ? contextParts.join('\n\n---\n\n') : null;

  if (updatedInput && mergedContext) {
    logHook(HOOK_NAME, `Merged ${contextParts.length} context(s) + updatedInput`);
    return {
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: { hookEventName: 'PreToolUse', updatedInput, additionalContext: mergedContext },
    };
  }

  if (updatedInput) {
    logHook(HOOK_NAME, 'updatedInput only — no context');
    return outputWithUpdatedInput(updatedInput);
  }

  if (mergedContext) {
    logHook(HOOK_NAME, `Merged ${contextParts.length} context(s)`);
    return {
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: { additionalContext: mergedContext, hookEventName: 'PreToolUse' },
    };
  }

  logHook(HOOK_NAME, 'All hooks silent');
  return outputSilentSuccess();
}

/**
 * Consolidated sync Bash PreToolUse dispatcher.
 *
 * Execution order:
 * 1. dangerous-command-blocker (can block — security critical)
 * 2. compound-command-validator (can block — security critical)
 * 3. unified-advisory-dispatcher (context + input modifier)
 *
 * On first block: SHORT-CIRCUIT immediately.
 * On pass: merge additionalContext and updatedInput from all hooks.
 */
export function syncBashDispatcher(input: HookInput): HookResult {
  const contextParts: string[] = [];
  let updatedInput: Record<string, unknown> | undefined;

  for (const hook of BASH_HOOKS) {
    try {
      const result = hook.fn(input);

      if (!result.continue) {
        logHook(HOOK_NAME, `${hook.name} blocked — short-circuiting`);
        return result;
      }

      if (result.hookSpecificOutput?.updatedInput) {
        updatedInput = result.hookSpecificOutput.updatedInput as Record<string, unknown>;
        logHook(HOOK_NAME, `${hook.name}: updatedInput collected`);
      }

      const context = extractContext(result);
      if (context) {
        contextParts.push(context);
        logHook(HOOK_NAME, `${hook.name}: additionalContext collected`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
    }
  }

  return buildMergedResult(contextParts, updatedInput);
}
