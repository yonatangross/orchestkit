// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Unified Advisory Dispatcher — PreToolUse Bash Hook
 * Consolidates 8 advisory hooks into a single dispatcher to reduce process spawns.
 *
 * Hooks consolidated here:
 * - default-timeout-setter (input modifier — runs first)
 * - agent-browser-safety (can block — runs second)
 * - error-pattern-warner (context)
 * - issue-docs-requirement (context)
 * - multi-instance-quality-gate (context)
 * - gh-issue-creation-guide (context)
 * - license-compliance (context)
 * - affected-tests-finder (context)
 *
 * NOT consolidated (remain separate in hooks.json):
 * - dangerous-command-blocker (security-critical, must block early)
 * - compound-command-validator (security-critical, must block early)
 *
 * CC 2.1.9 Compliant: Single additionalContext output with 800-token budget
 */

import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  outputAllowWithContext,
  outputWithUpdatedInput,
  logHook,
  estimateTokenCount,
} from '../../lib/common.js';

// Import hook implementations
import { defaultTimeoutSetter } from './default-timeout-setter.js';
import { agentBrowserSafety } from './agent-browser-safety.js';
import { errorPatternWarner } from './error-pattern-warner.js';
import { issueDocsRequirement } from './issue-docs-requirement.js';
import { multiInstanceQualityGate } from './multi-instance-quality-gate.js';
import { ghIssueCreationGuide } from './gh-issue-creation-guide.js';
import { licenseCompliance } from './license-compliance.js';
import { affectedTestsFinder } from './affected-tests-finder.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'pretool-bash-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface AdvisoryHookConfig {
  name: string;
  fn: HookFn;
}

// -----------------------------------------------------------------------------
// Hook Registry — advisory hooks that produce context
// -----------------------------------------------------------------------------

const ADVISORY_HOOKS: AdvisoryHookConfig[] = [
  { name: 'error-pattern-warner', fn: errorPatternWarner },
  { name: 'issue-docs-requirement', fn: issueDocsRequirement },
  { name: 'multi-instance-quality-gate', fn: multiInstanceQualityGate },
  { name: 'gh-issue-creation-guide', fn: ghIssueCreationGuide },
  { name: 'license-compliance', fn: licenseCompliance },
  { name: 'affected-tests-finder', fn: affectedTestsFinder },
];

/** Exposed for testing */
export const registeredHookNames = () => [
  'default-timeout-setter',
  'agent-browser-safety',
  ...ADVISORY_HOOKS.map(h => h.name),
];

// -----------------------------------------------------------------------------
// Context Extraction
// -----------------------------------------------------------------------------

/**
 * Extract additionalContext from a hook result.
 */
function extractContext(result: HookResult): string | null {
  if (result.hookSpecificOutput?.additionalContext) {
    return result.hookSpecificOutput.additionalContext as string;
  }
  if (result.systemMessage && typeof result.systemMessage === 'string') {
    return result.systemMessage;
  }
  return null;
}

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher for advisory Bash PreToolUse hooks.
 *
 * Execution order:
 * 1. default-timeout-setter (input modifier)
 * 2. agent-browser-safety (can block)
 * 3. Advisory hooks (context producers, budget-capped)
 */
export function unifiedBashAdvisoryDispatcher(input: HookInput): HookResult {
  // --- Phase 1: Input modifier (default-timeout-setter) ---
  let updatedInput: Record<string, unknown> | undefined;

  try {
    const timeoutResult = defaultTimeoutSetter(input);
    if (timeoutResult.hookSpecificOutput?.updatedInput) {
      updatedInput = timeoutResult.hookSpecificOutput.updatedInput as Record<string, unknown>;
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logHook(HOOK_NAME, `default-timeout-setter failed: ${message}`, 'warn');
  }

  // --- Phase 2: Blocking check (agent-browser-safety) ---
  try {
    const browserResult = agentBrowserSafety(input);
    if (!browserResult.continue) {
      // Blocked — return the deny immediately
      return browserResult;
    }
    // If it produced context, collect it
    const browserContext = extractContext(browserResult);
    if (browserContext) {
      // Browser safety context is high-priority, prepend to advisory output
      return mergeAdvisoryContext(input, updatedInput, browserContext);
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logHook(HOOK_NAME, `agent-browser-safety failed: ${message}`, 'warn');
  }

  // --- Phase 3: Advisory hooks (context producers) ---
  return mergeAdvisoryContext(input, updatedInput, null);
}

/**
 * Run advisory hooks, merge context, and combine with any input modifications.
 */
function mergeAdvisoryContext(
  input: HookInput,
  updatedInput: Record<string, unknown> | undefined,
  prependContext: string | null,
): HookResult {
  const contextParts: string[] = [];
  let totalTokens = 0;

  // Prepend high-priority context (e.g., browser safety warning)
  if (prependContext) {
    const tokens = estimateTokenCount(prependContext);
    contextParts.push(prependContext);
    totalTokens += tokens;
  }

  // Run advisory hooks
  for (const hook of ADVISORY_HOOKS) {
    try {
      const result = hook.fn(input);

      const context = extractContext(result);
      if (!context) continue;

      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;
      logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // --- Combine results ---

  // Case 1: Input modified + context produced
  if (updatedInput && contextParts.length > 0) {
    const consolidated = contextParts.join('\n\n---\n\n');
    logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t + input mod`);
    return {
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: {
        hookEventName: 'PreToolUse',
        updatedInput,
        additionalContext: consolidated,
      },
    };
  }

  // Case 2: Input modified only
  if (updatedInput) {
    return outputWithUpdatedInput(updatedInput);
  }

  // Case 3: Context produced only
  if (contextParts.length > 0) {
    const consolidated = contextParts.join('\n\n---\n\n');
    logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);
    return outputAllowWithContext(consolidated);
  }

  // Case 4: Nothing produced
  return outputSilentSuccess();
}
