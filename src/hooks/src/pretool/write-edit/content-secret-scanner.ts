// Generated by OrchestKit Claude Plugin
// Created: 2026-02-27

/**
 * Content-Based Secret Scanner Hook
 * Scans Write/Edit content for high-confidence secret patterns
 *
 * OWASP ASI02/ASI03: Prevents accidental secret leakage through file writes.
 * file-guard.ts blocks .env filenames; this hook blocks secret CONTENT in any file.
 *
 * CC 2.1.7 Compliant
 */

import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  outputDeny,
  logHook,
  logPermissionFeedback,
} from '../../lib/common.js';
import { basename, extname } from 'node:path';

// ---------------------------------------------------------------------------
// High-confidence secret patterns (15 patterns)
// Source: secrets-patterns-db (1600+ patterns), filtered to high-confidence
// ---------------------------------------------------------------------------

const SECRET_PATTERNS: Array<{ name: string; regex: RegExp }> = [
  { name: 'OpenAI API Key', regex: /sk-[A-Za-z0-9]{20,}/ },
  { name: 'Anthropic API Key', regex: /sk-ant-[A-Za-z0-9_-]{20,}/ },
  { name: 'GitHub PAT (classic)', regex: /ghp_[A-Za-z0-9]{36,}/ },
  { name: 'GitHub PAT (fine-grained)', regex: /github_pat_[A-Za-z0-9_]{30,}/ },
  { name: 'AWS Access Key', regex: /(?:AKIA|ASIA)[A-Z0-9]{16}/ },
  { name: 'GCP API Key', regex: /AIza[A-Za-z0-9_-]{35}/ },
  { name: 'Stripe Secret Key', regex: /sk_live_[A-Za-z0-9]{24,}/ },
  { name: 'Stripe Publishable Key', regex: /pk_live_[A-Za-z0-9]{24,}/ },
  { name: 'Twilio API Key', regex: /SK[0-9a-f]{32}/ },
  { name: 'SendGrid API Key', regex: /SG\.[A-Za-z0-9_-]{22,}\.[A-Za-z0-9_-]{22,}/ },
  { name: 'Slack Token', regex: /xox[bpras]-[A-Za-z0-9-]{10,}/ },
  { name: 'Tavily API Key', regex: /tvly-[A-Za-z0-9]{20,}/ },
  { name: 'Mem0 API Key', regex: /m0-[A-Za-z0-9]{20,}/ },
  { name: 'JWT Token', regex: /eyJ[A-Za-z0-9_-]{10,}\.eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}/ },
  { name: 'Private Key Block', regex: /-----BEGIN\s+(?:RSA|DSA|EC|OPENSSH|PGP)?\s*PRIVATE KEY-----/ },
];

// Contextual pattern: api_key="value" assignments (not just variable names)
const CONTEXTUAL_SECRET_PATTERN = /(?:api_key|secret_key|api_secret|access_token|auth_token|private_key)\s*[=:]\s*["'][A-Za-z0-9_\-/.+]{16,}["']/i;

// ---------------------------------------------------------------------------
// False positive exclusions
// ---------------------------------------------------------------------------

const EXCLUDED_EXTENSIONS = new Set(['.md', '.txt', '.rst', '.adoc']);

function isExcludedPath(filePath: string): boolean {
  const ext = extname(filePath).toLowerCase();
  if (EXCLUDED_EXTENSIONS.has(ext)) return true;

  const lowerPath = filePath.toLowerCase();
  return (
    lowerPath.includes('fixtures/') ||
    lowerPath.includes('__tests__/') ||
    lowerPath.includes('test-data/') ||
    lowerPath.includes('testdata/') ||
    lowerPath.includes('/tests/') && lowerPath.includes('/fixtures/')
  );
}

// ---------------------------------------------------------------------------
// Scanner
// ---------------------------------------------------------------------------

function scanForSecrets(content: string): { name: string; snippet: string } | null {
  // Check high-confidence patterns
  for (const { name, regex } of SECRET_PATTERNS) {
    const match = content.match(regex);
    if (match) {
      // Mask the secret for logging (show first 8 chars + "...")
      const snippet = match[0].length > 12
        ? `${match[0].substring(0, 8)}...`
        : match[0].substring(0, 4) + '...';
      return { name, snippet };
    }
  }

  // Check contextual pattern
  const ctxMatch = content.match(CONTEXTUAL_SECRET_PATTERN);
  if (ctxMatch) {
    const snippet = ctxMatch[0].length > 20
      ? `${ctxMatch[0].substring(0, 16)}...`
      : ctxMatch[0];
    return { name: 'Secret Assignment', snippet };
  }

  return null;
}

/**
 * Scan Write/Edit content for secret patterns
 */
export function contentSecretScanner(input: HookInput): HookResult {
  const toolName = input.tool_name;
  const filePath = input.tool_input.file_path || '';

  // Determine content to scan based on tool
  let content = '';
  if (toolName === 'Write') {
    content = input.tool_input.content || '';
  } else if (toolName === 'Edit') {
    content = input.tool_input.new_string || '';
  }

  if (!content || !filePath) {
    return outputSilentSuccess();
  }

  // Skip excluded paths (docs, tests, fixtures)
  if (isExcludedPath(filePath)) {
    return outputSilentSuccess();
  }

  const finding = scanForSecrets(content);

  if (finding) {
    const fileName = basename(filePath);
    logPermissionFeedback('deny', `Secret detected in ${fileName}: ${finding.name}`, input);
    logHook('content-secret-scanner', `BLOCKED: ${finding.name} in ${filePath} (${finding.snippet})`);

    return outputDeny(
      `BLOCKED: Potential secret detected in file content.

Type: ${finding.name}
File: ${filePath}
Match: ${finding.snippet}

Secrets must NEVER be committed to source code. Use:
- Environment variables (.env files â€” which are gitignored)
- Secret managers (AWS Secrets Manager, Vault, etc.)
- CI/CD secret injection

If this is a false positive (e.g., test fixture or documentation),
move the file to a test-data/ or fixtures/ directory.`
    );
  }

  logPermissionFeedback('allow', `Content scan clean: ${basename(filePath)}`, input);
  return outputSilentSuccess();
}
