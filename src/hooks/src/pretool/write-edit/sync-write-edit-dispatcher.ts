// Generated by OrchestKit Claude Plugin
// Created: 2026-02-28

/**
 * Sync Write|Edit Dispatcher — PreToolUse Write|Edit Hook
 * Consolidates 4 Write|Edit PreToolUse hooks into a single dispatcher.
 *
 * Consolidated hooks (security-first order):
 * - content-secret-scanner (scans for secrets in file content — FIRST)
 * - file-guard (protects critical files from modification — SECOND)
 * - write-headers (adds headers to new files — input modifier)
 * - unified-quality-dispatcher (quality checks — LAST)
 *
 * SHORT-CIRCUIT: On first block, returns immediately without running remaining hooks.
 * Merges additionalContext from all passing hooks into a single output.
 *
 * CC 2.1.9 Compliant: Single PreToolUse dispatcher with merged additionalContext
 */

import type { HookInput, HookResult } from '../../types.js';
import { outputSilentSuccess, outputWithUpdatedInput, logHook, extractContext } from '../../lib/common.js';

// Import consolidated hook implementations
import { contentSecretScanner } from './content-secret-scanner.js';
import { fileGuard } from './file-guard.js';
import { writeHeaders } from '../input-mod/write-headers.js';
import { unifiedWriteEditQualityDispatcher } from './unified-quality-dispatcher.js';

const HOOK_NAME = 'sync-write-edit-dispatcher';

interface WriteEditHookConfig {
  name: string;
  fn: (input: HookInput) => HookResult;
}

/**
 * Registry of Write|Edit PreToolUse hooks, executed in security-first order.
 * Blockers/scanners run first; quality advisory runs last.
 */
const WRITE_EDIT_HOOKS: WriteEditHookConfig[] = [
  { name: 'content-secret-scanner', fn: contentSecretScanner },
  { name: 'file-guard', fn: fileGuard },
  { name: 'write-headers', fn: writeHeaders },
  { name: 'unified-quality-dispatcher', fn: unifiedWriteEditQualityDispatcher },
];

/**
 * Build the merged HookResult from collected context parts and optional updatedInput.
 */
function buildMergedResult(
  contextParts: string[],
  updatedInput: Record<string, unknown> | undefined,
): HookResult {
  const mergedContext = contextParts.length > 0 ? contextParts.join('\n\n---\n\n') : null;

  if (updatedInput && mergedContext) {
    logHook(HOOK_NAME, `Merged ${contextParts.length} context(s) + updatedInput`);
    return {
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: { hookEventName: 'PreToolUse', updatedInput, additionalContext: mergedContext },
    };
  }

  if (updatedInput) {
    logHook(HOOK_NAME, 'updatedInput only — no context');
    return outputWithUpdatedInput(updatedInput);
  }

  if (mergedContext) {
    logHook(HOOK_NAME, `Merged ${contextParts.length} context(s)`);
    return {
      continue: true,
      suppressOutput: true,
      hookSpecificOutput: { additionalContext: mergedContext, hookEventName: 'PreToolUse' },
    };
  }

  logHook(HOOK_NAME, 'All hooks silent');
  return outputSilentSuccess();
}

/**
 * Consolidated sync Write|Edit PreToolUse dispatcher.
 *
 * Execution order:
 * 1. content-secret-scanner (can block — security critical)
 * 2. file-guard (can block — security critical)
 * 3. write-headers (input modifier — adds headers to new files)
 * 4. unified-quality-dispatcher (context producer)
 *
 * On first block: SHORT-CIRCUIT immediately.
 * On pass: merge additionalContext and updatedInput from all hooks.
 */
export function syncWriteEditDispatcher(input: HookInput): HookResult {
  const contextParts: string[] = [];
  let updatedInput: Record<string, unknown> | undefined;

  for (const hook of WRITE_EDIT_HOOKS) {
    try {
      const result = hook.fn(input);

      if (!result.continue) {
        logHook(HOOK_NAME, `${hook.name} blocked — short-circuiting`);
        return result;
      }

      if (result.hookSpecificOutput?.updatedInput) {
        updatedInput = result.hookSpecificOutput.updatedInput as Record<string, unknown>;
        logHook(HOOK_NAME, `${hook.name}: updatedInput collected`);
      }

      const context = extractContext(result);
      if (context) {
        contextParts.push(context);
        logHook(HOOK_NAME, `${hook.name}: additionalContext collected`);
      }
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${msg}`, 'warn');
    }
  }

  return buildMergedResult(contextParts, updatedInput);
}
