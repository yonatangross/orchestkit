// Generated by OrchestKit Claude Plugin
// Created: 2026-02-09

/**
 * Unified Quality Dispatcher — PreToolUse Write|Edit Hook
 * Consolidates 4 quality hooks into a single dispatcher to reduce process spawns.
 *
 * Hooks consolidated here:
 * - security-pattern-validator (can block — runs first)
 * - architecture-change-detector (context)
 * - docstring-enforcer (context)
 * - code-quality-gate (context)
 *
 * NOT consolidated (remain separate in hooks.json):
 * - file-guard (security-critical guard, must block early)
 * - write-headers (input modifier, must run before quality checks)
 *
 * CC 2.1.9 Compliant: Single additionalContext output with 800-token budget
 */

import type { HookInput, HookResult } from '../../types.js';
import {
  outputSilentSuccess,
  outputAllowWithContext,
  logHook,
  estimateTokenCount,
} from '../../lib/common.js';

// Import hook implementations
import { securityPatternValidator } from '../Write/security-pattern-validator.js';
import { architectureChangeDetector } from '../Write/architecture-change-detector.js';
import { docstringEnforcer } from '../Write/docstring-enforcer.js';
import { codeQualityGate } from '../Write/code-quality-gate.js';

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const HOOK_NAME = 'pretool-write-edit-dispatcher';

/** Maximum total tokens for consolidated output */
const MAX_OUTPUT_TOKENS = 800;

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type HookFn = (input: HookInput) => HookResult;

interface QualityHookConfig {
  name: string;
  fn: HookFn;
}

// -----------------------------------------------------------------------------
// Hook Registry — quality hooks that produce context
// -----------------------------------------------------------------------------

const QUALITY_HOOKS: QualityHookConfig[] = [
  { name: 'architecture-change-detector', fn: architectureChangeDetector },
  { name: 'docstring-enforcer', fn: docstringEnforcer },
  { name: 'code-quality-gate', fn: codeQualityGate },
];

/** Exposed for testing */
export const registeredHookNames = () => [
  'security-pattern-validator',
  ...QUALITY_HOOKS.map(h => h.name),
];

// -----------------------------------------------------------------------------
// Context Extraction
// -----------------------------------------------------------------------------

/**
 * Extract additionalContext from a hook result.
 */
function extractContext(result: HookResult): string | null {
  if (result.hookSpecificOutput?.additionalContext) {
    return result.hookSpecificOutput.additionalContext as string;
  }
  if (result.systemMessage && typeof result.systemMessage === 'string') {
    return result.systemMessage;
  }
  return null;
}

// -----------------------------------------------------------------------------
// Dispatcher Implementation
// -----------------------------------------------------------------------------

/**
 * Unified dispatcher for quality Write|Edit PreToolUse hooks.
 *
 * Execution order:
 * 1. security-pattern-validator (can block)
 * 2. Quality hooks (context producers, budget-capped)
 */
export function unifiedWriteEditQualityDispatcher(input: HookInput): HookResult {
  // --- Phase 1: Security check (can block) ---
  try {
    const securityResult = securityPatternValidator(input);
    if (!securityResult.continue) {
      return securityResult;
    }
    // If security produced a warning context, collect it as high-priority
    const securityContext = extractContext(securityResult);
    if (securityContext) {
      return mergeQualityContext(input, securityContext);
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    logHook(HOOK_NAME, `security-pattern-validator failed: ${message}`, 'warn');
  }

  // --- Phase 2: Quality hooks (context producers) ---
  return mergeQualityContext(input, null);
}

/**
 * Run quality hooks, merge context with optional prepended context.
 */
function mergeQualityContext(
  input: HookInput,
  prependContext: string | null,
): HookResult {
  const contextParts: string[] = [];
  let totalTokens = 0;

  // Prepend high-priority context (e.g., security warnings)
  if (prependContext) {
    const tokens = estimateTokenCount(prependContext);
    contextParts.push(prependContext);
    totalTokens += tokens;
  }

  // Run quality hooks
  for (const hook of QUALITY_HOOKS) {
    try {
      const result = hook.fn(input);

      const context = extractContext(result);
      if (!context) continue;

      const contextTokens = estimateTokenCount(context);
      if (totalTokens + contextTokens > MAX_OUTPUT_TOKENS) {
        logHook(HOOK_NAME, `Budget limit: skipping ${hook.name} (${contextTokens}t would exceed ${MAX_OUTPUT_TOKENS}t cap)`);
        continue;
      }

      contextParts.push(context);
      totalTokens += contextTokens;
      logHook(HOOK_NAME, `${hook.name}: +${contextTokens}t (total: ${totalTokens}t)`);
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      logHook(HOOK_NAME, `${hook.name} failed: ${message}`, 'warn');
    }
  }

  // No context produced
  if (contextParts.length === 0) {
    return outputSilentSuccess();
  }

  // Single consolidated output
  const consolidated = contextParts.join('\n\n---\n\n');
  logHook(HOOK_NAME, `Consolidated ${contextParts.length} hooks into ${totalTokens}t`);
  return outputAllowWithContext(consolidated);
}
