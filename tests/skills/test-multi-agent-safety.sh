#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-08

# ============================================================================
# Multi-Agent Safety Tests
# ============================================================================
# Validates that skills spawning parallel agents follow safety patterns
# to prevent context exhaustion, shell injection, and misconfiguration.
#
# Regression tests for 9 bugs found in /ork:assess and /ork:assess-complexity:
#   1. Shell quoting in !` backtick commands in SKILL.md
#   2. complexity frontmatter matches agent-spawning patterns
#   3. Agent count claims match actual Task() calls
#   4. Agent types referenced exist as agent definitions
#   5. Context exhaustion fallback documented
#   6. Agent Teams uses correct env var (CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS)
#   7. max_turns set on background Task() calls
#   8. Scope constraints in agent-spawning prompts
#   9. 1M context window guidance for large assessments
#
# Usage: ./test-multi-agent-safety.sh [--verbose]
# Exit codes: 0 = all pass, 1 = failures found
# ============================================================================

set -uo pipefail
# Note: -e removed intentionally - tests need to handle expected non-zero returns from grep

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$SCRIPT_DIR/../.." && pwd)}"
SKILLS_DIR="$PROJECT_ROOT/src/skills"
AGENTS_DIR="$PROJECT_ROOT/src/agents"

VERBOSE="${1:-}"

# Counters
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC=''
fi

pass() {
    echo -e "  ${GREEN}PASS${NC} $1"
    ((PASS_COUNT++)) || true
}

fail() {
    echo -e "  ${RED}FAIL${NC} $1"
    ((FAIL_COUNT++)) || true
}

warn() {
    echo -e "  ${YELLOW}WARN${NC} $1"
    ((WARN_COUNT++)) || true
}

info() {
    if [[ "$VERBOSE" == "--verbose" ]]; then
        echo -e "  ${BLUE}INFO${NC} $1"
    fi
}

echo "============================================================================"
echo "  Multi-Agent Safety Tests"
echo "============================================================================"
echo ""
echo "Skills directory: $SKILLS_DIR"
echo "Agents directory: $AGENTS_DIR"
echo ""

# ============================================================================
# Test 1: Shell Quoting in SKILL.md !` Commands
# ============================================================================
# Regression for Bug 1: assess-complexity had !`./scripts/analyze-codebase.sh $ARGUMENTS`
# The unquoted $ARGUMENTS caused shell injection on apostrophes (you're → unmatched ')
echo -e "${CYAN}Test 1: Shell Quoting in SKILL.md !-backtick Commands${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

UNQUOTED_VIOLATIONS=()

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Find !`...` patterns containing $ARGUMENTS without quotes
    # Match: !`command $ARGUMENTS` (bad — unquoted)
    # Skip:  !`command "$ARGUMENTS"` (good — quoted)
    if grep -qE '!`[^`]*[^"]\$ARGUMENTS[^"]*`' "$skill_md" 2>/dev/null; then
        # Double check it's not actually quoted
        while IFS= read -r line; do
            # Skip lines where $ARGUMENTS is properly quoted
            if echo "$line" | grep -qE '"\$ARGUMENTS"'; then
                continue
            fi
            UNQUOTED_VIOLATIONS+=("$skill_name")
            fail "$skill_name: Unquoted \$ARGUMENTS in !-backtick command"
            if [[ -n "$VERBOSE" ]]; then
                echo "    $line"
            fi
        done < <(grep -E '!`[^`]*\$ARGUMENTS[^`]*`' "$skill_md" 2>/dev/null)
    fi
done

if [[ ${#UNQUOTED_VIOLATIONS[@]} -eq 0 ]]; then
    pass "All SKILL.md !-backtick commands have quoted \$ARGUMENTS"
fi
echo ""

# ============================================================================
# Test 2: Complexity Frontmatter for Agent-Spawning Skills
# ============================================================================
# Regression for Bug 2: assess had complexity: low but spawns 4 parallel agents
echo -e "${CYAN}Test 2: Complexity Frontmatter for Agent-Spawning Skills${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

COMPLEXITY_VIOLATIONS=()

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Check if skill spawns multiple agents (has multiple Task( calls with subagent_type)
    agent_spawn_count=$(grep -o 'subagent_type=' "$skill_md" 2>/dev/null | wc -l | tr -d ' ')

    if [[ "$agent_spawn_count" -ge 3 ]]; then
        # Extract complexity from frontmatter (between first and second ---)
        complexity=$(awk '/^---$/{c++; next} c==1' "$skill_md" | grep -E '^complexity:' | head -1 | sed 's/complexity:[[:space:]]*//')

        if [[ "$complexity" == "low" ]]; then
            COMPLEXITY_VIOLATIONS+=("$skill_name")
            fail "$skill_name: complexity=$complexity but spawns $agent_spawn_count agents (should be medium or high)"
        else
            info "$skill_name: complexity=$complexity with $agent_spawn_count agent spawns (OK)"
        fi
    fi
done

if [[ ${#COMPLEXITY_VIOLATIONS[@]} -eq 0 ]]; then
    pass "All multi-agent skills have appropriate complexity level"
fi
echo ""

# ============================================================================
# Test 3: Agent Type Existence Validation
# ============================================================================
# Regression for Bug 4: assess referenced performance-engineer (frontend) for general assessment
echo -e "${CYAN}Test 3: Agent Types Referenced Exist as Definitions${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

MISSING_AGENTS=()

# Collect all agent definition names
declare -A KNOWN_AGENTS
for agent_file in "$AGENTS_DIR"/*.md; do
    agent_name=$(basename "$agent_file" .md)
    KNOWN_AGENTS["$agent_name"]=1
done

# CC built-in agent types (not defined in src/agents/)
CC_BUILTIN_AGENTS=("Explore" "general-purpose" "Bash" "Plan" "statusline-setup")
for builtin in "${CC_BUILTIN_AGENTS[@]}"; do
    KNOWN_AGENTS["$builtin"]=1
done

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Extract agent types from Task(subagent_type="...") calls
    while IFS= read -r agent_type; do
        # Clean up the extracted type
        agent_type=$(echo "$agent_type" | sed 's/[",]//g' | tr -d ' ')

        if [[ -z "$agent_type" ]]; then
            continue
        fi

        # Strip ork: prefix — subagent_type should NOT include plugin prefix
        clean_type="$agent_type"
        if [[ "$agent_type" == ork:* ]]; then
            clean_type="${agent_type#ork:}"
            fail "$skill_name: uses 'ork:' prefix in subagent_type='$agent_type' (should be '$clean_type')"
            MISSING_AGENTS+=("$skill_name → $agent_type (has ork: prefix)")
            continue
        fi

        if [[ -z "${KNOWN_AGENTS[$agent_type]+_}" ]]; then
            MISSING_AGENTS+=("$skill_name → $agent_type")
            fail "$skill_name: references agent '$agent_type' but no $AGENTS_DIR/$agent_type.md exists"
        else
            info "$skill_name: agent '$agent_type' exists (OK)"
        fi
    done < <(grep -oE 'subagent_type="[^"]*"' "$skill_md" 2>/dev/null | sed 's/subagent_type="//;s/"//')
done

if [[ ${#MISSING_AGENTS[@]} -eq 0 ]]; then
    pass "All referenced agent types have matching definitions"
fi
echo ""

# ============================================================================
# Test 4: Agent Teams Env Var Validation
# ============================================================================
# Regression for Bug 7: assess used ORCHESTKIT_PREFER_TEAMS instead of
# CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS
echo -e "${CYAN}Test 4: Agent Teams Uses Correct Env Var${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

WRONG_ENV_VARS=()
CORRECT_FLAG="CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS"

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Check if skill references TeamCreate (uses Agent Teams)
    if grep -q 'TeamCreate' "$skill_md" 2>/dev/null; then
        # Check for any ORCHESTKIT_PREFER_TEAMS reference (wrong)
        if grep -q 'ORCHESTKIT_PREFER_TEAMS' "$skill_md" 2>/dev/null; then
            WRONG_ENV_VARS+=("$skill_name")
            fail "$skill_name: uses ORCHESTKIT_PREFER_TEAMS instead of $CORRECT_FLAG"
        fi

        # Check that it references the correct flag somewhere
        if grep -q "$CORRECT_FLAG" "$skill_md" 2>/dev/null; then
            info "$skill_name: correctly references $CORRECT_FLAG"
        else
            # Some skills may use Teams without explicit flag check (via orchestration-modes reference)
            # Only warn, don't fail
            info "$skill_name: uses TeamCreate but doesn't explicitly check $CORRECT_FLAG"
        fi
    fi
done

if [[ ${#WRONG_ENV_VARS[@]} -eq 0 ]]; then
    pass "No skills use wrong Agent Teams env var"
fi
echo ""

# ============================================================================
# Test 5: max_turns on Background Task Calls
# ============================================================================
# Regression for Bug 8: assess spawned background agents without max_turns,
# allowing unbounded context consumption
echo -e "${CYAN}Test 5: max_turns on Background Agent Spawns${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

NO_MAX_TURNS=()

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Find Task calls with run_in_background=True
    if grep -q 'run_in_background=True' "$skill_md" 2>/dev/null; then
        # Check if ANY Task call in the same skill has max_turns
        if grep -q 'max_turns=' "$skill_md" 2>/dev/null; then
            info "$skill_name: has max_turns on background agents (OK)"
        else
            NO_MAX_TURNS+=("$skill_name")
            fail "$skill_name: spawns background agents without max_turns (risk of context exhaustion)"
        fi
    fi
done

if [[ ${#NO_MAX_TURNS[@]} -eq 0 ]]; then
    pass "All skills with background agents set max_turns"
fi
echo ""

# ============================================================================
# Test 6: Scope Constraints in Agent-Spawning Skills
# ============================================================================
# Regression for original bug: agents received unbounded targets and read entire codebase
echo -e "${CYAN}Test 6: Scope Constraints in Agent-Spawning Skills${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

NO_SCOPE=()

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Count background agent spawns
    bg_spawns=$(grep -o 'run_in_background=True' "$skill_md" 2>/dev/null | wc -l | tr -d ' ')

    if [[ "$bg_spawns" -ge 2 ]]; then
        # Check for scope constraint language
        has_scope=false
        if grep -qiE '(scope.constraint|ONLY read|file.list|do NOT explore|bounded|MAX_FILES|scope_files)' "$skill_md" 2>/dev/null; then
            has_scope=true
        fi

        if $has_scope; then
            info "$skill_name: has scope constraints for $bg_spawns background agents (OK)"
        else
            NO_SCOPE+=("$skill_name")
            fail "$skill_name: spawns $bg_spawns background agents without scope constraints"
        fi
    fi
done

if [[ ${#NO_SCOPE[@]} -eq 0 ]]; then
    pass "All multi-agent skills include scope constraints"
fi
echo ""

# ============================================================================
# Test 7: Context Exhaustion Fallback
# ============================================================================
# Regression for Bug 5: no fallback when agents hit "Context limit reached"
echo -e "${CYAN}Test 7: Context Exhaustion Fallback${NC}"
echo "────────────────────────────────────────────────────────────────────────────"

NO_FALLBACK=()

for skill_md in "$SKILLS_DIR"/*/SKILL.md; do
    skill_name=$(basename "$(dirname "$skill_md")")

    # Check if skill uses Agent Teams
    if grep -q 'TeamCreate' "$skill_md" 2>/dev/null; then
        # Check for context exhaustion fallback
        if grep -qiE '(context.exhaustion|context.limit|partial.results)' "$skill_md" 2>/dev/null; then
            info "$skill_name: has context exhaustion fallback (OK)"
        else
            NO_FALLBACK+=("$skill_name")
            warn "$skill_name: uses Agent Teams but no context exhaustion fallback documented"
        fi
    fi
done

if [[ ${#NO_FALLBACK[@]} -eq 0 ]]; then
    pass "All Agent Teams skills document context exhaustion fallback"
else
    warn "${#NO_FALLBACK[@]} skill(s) missing context exhaustion fallback (recommended)"
fi
echo ""

# ============================================================================
# Summary
# ============================================================================
echo "============================================================================"
echo "  Test Summary"
echo "============================================================================"
echo ""
echo -e "  ${GREEN}Passed:          $PASS_COUNT${NC}"
echo -e "  ${RED}Failed:          $FAIL_COUNT${NC}"
echo -e "  ${YELLOW}Warnings:        $WARN_COUNT${NC}"
echo ""

if [[ $FAIL_COUNT -gt 0 ]]; then
    echo -e "${RED}FAILED: $FAIL_COUNT test(s) failed${NC}"
    echo ""
    echo "These tests prevent multi-agent safety regressions:"
    echo "  - Shell injection via unquoted \$ARGUMENTS in !-backtick commands"
    echo "  - Context exhaustion from unbounded agent spawns"
    echo "  - Wrong Agent Teams env var (ORCHESTKIT_PREFER_TEAMS vs CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS)"
    echo "  - Missing max_turns allowing runaway agents"
    echo "  - Missing scope constraints in multi-agent prompts"
    echo ""
    exit 1
else
    echo -e "${GREEN}SUCCESS: All multi-agent safety tests passed${NC}"
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}Note: $WARN_COUNT warning(s) should be reviewed${NC}"
    fi
    exit 0
fi
