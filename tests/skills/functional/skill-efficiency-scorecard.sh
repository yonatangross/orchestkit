#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-16

# ============================================================================
# Skill Efficiency Scorecard
# ============================================================================
# Produces a JSON scorecard with quantitative metrics for each skill,
# measuring what each skill provides to Claude (the "with skill" benchmark).
#
# Metrics (all counted, not estimated):
# - rule_count: Number of rule files
# - reference_count: Number of reference files
# - imperative_instructions: MUST/ALWAYS/NEVER/DO NOT/SHOULD NOT patterns
# - concrete_tool_refs: Specific tool name mentions
# - agent_type_refs: Specific subagent_type mentions
# - code_examples: Fenced code blocks in rules/
# - phase_steps: Numbered workflow steps or phase headings
# - anti_patterns: NEVER/DO NOT/avoid/should_not instructions
# - specificity_ratio: Concrete technical terms / total instruction words
#
# Output: tests/skills/functional/results/scorecard.json
# Exit: Always 0 (informational, not pass/fail)
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$SCRIPT_DIR/../../.." && pwd)}"
SKILLS_DIR="$PROJECT_ROOT/src/skills"
RESULTS_DIR="$SCRIPT_DIR/results"

mkdir -p "$RESULTS_DIR"

# Tool names that Claude can actually use
TOOL_NAMES="TaskCreate|TaskUpdate|TaskList|TaskGet|Task|Grep|Glob|Read|Edit|Write|AskUserQuestion|WebSearch|WebFetch|Bash|EnterPlanMode|ExitPlanMode"

# Agent types available in the system
AGENT_TYPES="backend-system-architect|test-generator|frontend-ui-developer|workflow-architect|llm-integrator|ux-researcher|security-auditor|code-quality-reviewer|rapid-ui-designer|database-engineer|data-pipeline-engineer|debug-investigator|documentation-specialist|deployment-manager|ci-cd-engineer|monitoring-engineer|prompt-engineer|infrastructure-architect|release-engineer|python-performance-engineer|frontend-performance-engineer|git-operations-engineer|accessibility-specialist|general-purpose|Explore|Plan"

echo "============================================================================"
echo "  Skill Efficiency Scorecard"
echo "============================================================================"
echo ""
echo "Skills directory: $SKILLS_DIR"
echo ""

# Start JSON output
skills_json="["
first=true

for skill_dir in "$SKILLS_DIR"/*/; do
    [[ -d "$skill_dir" ]] || continue
    skill_name=$(basename "$skill_dir")
    skill_file="$skill_dir/SKILL.md"

    [[ -f "$skill_file" ]] || continue

    echo "  Scoring: $skill_name"

    # --- Count rule files ---
    rule_count=0
    rules_content=""
    if [[ -d "$skill_dir/rules" ]]; then
        for rf in "$skill_dir/rules"/*.md; do
            [[ -f "$rf" ]] || continue
            rb=$(basename "$rf" .md)
            [[ "$rb" == "_template" || "$rb" == "_sections" ]] && continue
            rule_count=$((rule_count + 1))
            rules_content+=$(cat "$rf")
            rules_content+=$'\n'
        done
    fi

    # --- Count reference files ---
    reference_count=0
    if [[ -d "$skill_dir/references" ]]; then
        for rf in "$skill_dir/references"/*.md; do
            [[ -f "$rf" ]] || continue
            reference_count=$((reference_count + 1))
        done
    fi

    # --- Combine all skill content ---
    all_content=$(cat "$skill_file")
    all_content+=$'\n'
    all_content+="$rules_content"
    if [[ -d "$skill_dir/references" ]]; then
        for rf in "$skill_dir/references"/*.md; do
            [[ -f "$rf" ]] || continue
            all_content+=$(cat "$rf")
            all_content+=$'\n'
        done
    fi

    # --- Count imperative instructions ---
    imperative_instructions=$(echo "$all_content" | grep -ciE '\bMUST\b|\bALWAYS\b|\bNEVER\b|\bDO NOT\b|\bSHOULD NOT\b|\bREQUIRED\b' 2>/dev/null || true)
    imperative_instructions=${imperative_instructions:-0}
    imperative_instructions=$(echo "$imperative_instructions" | tr -d '[:space:]')

    # --- Count concrete tool references ---
    concrete_tool_refs=$(echo "$all_content" | grep -oE "\b(${TOOL_NAMES})\b" 2>/dev/null | wc -l | tr -d ' ' || true)
    concrete_tool_refs=${concrete_tool_refs:-0}

    # --- Count agent type references ---
    agent_type_refs=$(echo "$all_content" | grep -oE "(${AGENT_TYPES})" 2>/dev/null | wc -l | tr -d ' ' || true)
    agent_type_refs=${agent_type_refs:-0}

    # --- Count code examples (fenced blocks) in rules ---
    code_examples=0
    if [[ -n "$rules_content" ]]; then
        open_count=$(echo "$rules_content" | grep -c '```' 2>/dev/null || true)
        open_count=${open_count:-0}
        open_count=$(echo "$open_count" | tr -d '[:space:]')
        code_examples=$((open_count / 2))
    fi

    # --- Count phase steps (numbered steps and phase headings) ---
    phase_steps=$(echo "$all_content" | grep -cE '^\s*[0-9]+\.|^#+\s*(Phase|Step)\s+[0-9]' 2>/dev/null || true)
    phase_steps=${phase_steps:-0}
    phase_steps=$(echo "$phase_steps" | tr -d '[:space:]')

    # --- Count anti-patterns ---
    anti_patterns=$(echo "$all_content" | grep -ciE '\bNEVER\b|\bDO NOT\b|\bavoid\b|\bshould_not\b|\bmust not\b|\bprohibited\b' 2>/dev/null || true)
    anti_patterns=${anti_patterns:-0}
    anti_patterns=$(echo "$anti_patterns" | tr -d '[:space:]')

    # --- Calculate specificity ratio ---
    total_words=$(echo "$all_content" | wc -w | tr -d ' ')
    total_words=${total_words:-0}
    if [[ $total_words -gt 0 ]]; then
        # Concrete terms: CamelCase identifiers, words with digits (argon2id),
        # numbers with units, hyphenated multi-part names
        concrete_terms=$(echo "$all_content" | grep -oE '\b[A-Z][a-z]+[A-Z][a-zA-Z]*\b|\b[a-z]+[0-9]+[a-z]*\b|\b[0-9]+\s*(ms|seconds|minutes|hours|MB|GB|KB|tokens|bytes)\b|\b[a-z]+-[a-z]+-[a-z]+\b' 2>/dev/null | wc -l | tr -d ' ' || true)
        concrete_terms=${concrete_terms:-0}
        specificity_ratio=$(( (concrete_terms * 1000) / total_words ))
    else
        specificity_ratio=0
    fi

    # Format as X.XXX
    spec_whole=$((specificity_ratio / 1000))
    spec_frac=$((specificity_ratio % 1000))
    spec_formatted=$(printf "%d.%03d" "$spec_whole" "$spec_frac")

    # --- Append to JSON ---
    if [[ "$first" == "true" ]]; then
        first=false
    else
        skills_json+=","
    fi

    skills_json+=$(cat <<ITEM

    {
      "name": "$skill_name",
      "rule_count": $rule_count,
      "reference_count": $reference_count,
      "imperative_instructions": $imperative_instructions,
      "concrete_tool_refs": $concrete_tool_refs,
      "agent_type_refs": $agent_type_refs,
      "code_examples": $code_examples,
      "phase_steps": $phase_steps,
      "anti_patterns": $anti_patterns,
      "specificity_ratio": $spec_formatted,
      "total_words": $total_words
    }
ITEM
)
done

skills_json+=$'\n]'

# --- Compute aggregate stats ---
skill_count=$(echo "$skills_json" | jq 'length')

aggregate=$(echo "$skills_json" | jq '{
  skill_count: length,
  rule_count: { mean: ([.[].rule_count] | add / length | . * 10 | round / 10), median: ([.[].rule_count] | sort | .[length/2 | floor]), min: ([.[].rule_count] | min), max: ([.[].rule_count] | max) },
  reference_count: { mean: ([.[].reference_count] | add / length | . * 10 | round / 10), median: ([.[].reference_count] | sort | .[length/2 | floor]), min: ([.[].reference_count] | min), max: ([.[].reference_count] | max) },
  imperative_instructions: { mean: ([.[].imperative_instructions] | add / length | . * 10 | round / 10), median: ([.[].imperative_instructions] | sort | .[length/2 | floor]), min: ([.[].imperative_instructions] | min), max: ([.[].imperative_instructions] | max) },
  code_examples: { mean: ([.[].code_examples] | add / length | . * 10 | round / 10), median: ([.[].code_examples] | sort | .[length/2 | floor]), min: ([.[].code_examples] | min), max: ([.[].code_examples] | max) },
  specificity_ratio: { mean: ([.[].specificity_ratio] | add / length | . * 1000 | round / 1000), median: ([.[].specificity_ratio] | sort | .[length/2 | floor] | . * 1000 | round / 1000), min: ([.[].specificity_ratio] | min | . * 1000 | round / 1000), max: ([.[].specificity_ratio] | max | . * 1000 | round / 1000) }
}')

# --- Write final scorecard ---
final_json=$(jq -n \
    --argjson skills "$skills_json" \
    --argjson aggregate "$aggregate" \
    --arg generated "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    '{
        generated: $generated,
        aggregate: $aggregate,
        skills: $skills
    }')

echo "$final_json" > "$RESULTS_DIR/scorecard.json"

echo ""
echo "============================================================================"
echo "  Scorecard Summary"
echo "============================================================================"
echo ""
echo "  Skills scored: $skill_count"
echo ""
echo "  Aggregate stats:"
echo "$aggregate" | jq -r '
  "  Rules:         mean=\(.rule_count.mean) median=\(.rule_count.median) min=\(.rule_count.min) max=\(.rule_count.max)",
  "  References:    mean=\(.reference_count.mean) median=\(.reference_count.median) min=\(.reference_count.min) max=\(.reference_count.max)",
  "  Imperatives:   mean=\(.imperative_instructions.mean) median=\(.imperative_instructions.median) min=\(.imperative_instructions.min) max=\(.imperative_instructions.max)",
  "  Code examples: mean=\(.code_examples.mean) median=\(.code_examples.median) min=\(.code_examples.min) max=\(.code_examples.max)",
  "  Specificity:   mean=\(.specificity_ratio.mean) median=\(.specificity_ratio.median) min=\(.specificity_ratio.min) max=\(.specificity_ratio.max)"
'
echo ""

# Human-readable table sorted by rule_count descending
echo "  Top 5 skills (by rule_count):"
printf "  %-35s %6s %12s %8s %11s\n" "Skill" "Rules" "Imperatives" "Examples" "Specificity"
printf "  %-35s %6s %12s %8s %11s\n" "-----------------------------------" "------" "------------" "--------" "-----------"
echo "$skills_json" | jq -r 'sort_by(-.rule_count)[:5][] | "\(.name)|\(.rule_count)|\(.imperative_instructions)|\(.code_examples)|\(.specificity_ratio)"' | while IFS='|' read -r name rules imp ex spec; do
    printf "  %-35s %6s %12s %8s %11s\n" "$name" "$rules" "$imp" "$ex" "$spec"
done
echo ""
echo "  Bottom 5 skills (by rule_count):"
printf "  %-35s %6s %12s %8s %11s\n" "Skill" "Rules" "Imperatives" "Examples" "Specificity"
printf "  %-35s %6s %12s %8s %11s\n" "-----------------------------------" "------" "------------" "--------" "-----------"
echo "$skills_json" | jq -r 'sort_by(.rule_count)[:5][] | "\(.name)|\(.rule_count)|\(.imperative_instructions)|\(.code_examples)|\(.specificity_ratio)"' | while IFS='|' read -r name rules imp ex spec; do
    printf "  %-35s %6s %12s %8s %11s\n" "$name" "$rules" "$imp" "$ex" "$spec"
done
echo ""

echo "  Output: $RESULTS_DIR/scorecard.json"
echo ""
echo "============================================================================"
echo "  Scorecard generation complete (informational â€” always exits 0)"
echo "============================================================================"
exit 0
