#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-16

# ============================================================================
# Eval Completeness Tests
# ============================================================================
# Validates consistency between test-cases.json and .eval.json files.
#
# Tests:
# 1. Skills with test-cases.json should have a corresponding .eval.json
# 2. .eval.json expected_behavior entries should align with test-cases.json
# 3. .eval.json should_not entries must not appear as instructions in rules/
# 4. test-cases.json IDs must be unique within each skill
# 5. expectedBehavior strings must be specific (>5 words, not generic)
#
# Usage: ./test-eval-completeness.sh [--verbose]
# Exit codes: 0 = all pass, 1 = failures found
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$SCRIPT_DIR/../../.." && pwd)}"
SKILLS_DIR="$PROJECT_ROOT/src/skills"
EVALS_DIR="$PROJECT_ROOT/tests/evaluations"

VERBOSE="${1:-}"

# Counters
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC=''
fi

pass() {
    echo -e "  ${GREEN}PASS${NC} $1"
    PASS_COUNT=$((PASS_COUNT + 1))
}

fail() {
    echo -e "  ${RED}FAIL${NC} $1"
    FAIL_COUNT=$((FAIL_COUNT + 1))
}

warn() {
    echo -e "  ${YELLOW}WARN${NC} $1"
    WARN_COUNT=$((WARN_COUNT + 1))
}

info() {
    if [[ "$VERBOSE" == "--verbose" ]]; then
        echo -e "  ${BLUE}INFO${NC} $1"
    fi
}

# Stop words for keyword extraction (4+ char words to skip)
is_stopword() {
    local word="$1"
    case "$word" in
        this|that|with|from|have|does|what|when|where|which|will|would|could|should|these|those|them|then|than|their|there|they|been|being|were|also|into|each|only|just|more|most|some|such|very|like|make|made|used|uses|using|every|must|never|always|before|after|between|through|during|other|about|above|below|under|over)
            return 0 ;;
        *)
            return 1 ;;
    esac
}

# Extract meaningful terms (4+ chars, not stopwords) from a string
extract_terms() {
    local text="$1"
    local lower
    lower=$(echo "$text" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' ' ')
    local terms=()
    for word in $lower; do
        if [[ ${#word} -ge 4 ]] && ! is_stopword "$word"; then
            terms+=("$word")
        fi
    done
    echo "${terms[*]}"
}

# Generic phrases that are too vague for expectedBehavior
GENERIC_PATTERNS=(
    "follow best practices"
    "handle errors"
    "be secure"
    "work correctly"
    "be performant"
    "use appropriate"
    "implement properly"
)

is_generic() {
    local text="$1"
    local lower
    lower=$(echo "$text" | tr '[:upper:]' '[:lower:]')

    for pattern in "${GENERIC_PATTERNS[@]}"; do
        if [[ "$lower" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

# ============================================================================
# Header
# ============================================================================
echo "============================================================================"
echo "  Eval Completeness Tests"
echo "============================================================================"
echo ""

# Build map of existing .eval.json files (skill name -> file path)
declare -A EVAL_FILES
for eval_file in "$EVALS_DIR"/*.eval.json; do
    [[ -f "$eval_file" ]] || continue
    if jq empty "$eval_file" 2>/dev/null; then
        eval_skill=$(jq -r '.skill' "$eval_file")
        EVAL_FILES["$eval_skill"]="$eval_file"
    fi
done

# ============================================================================
# Test 1: Skills with test-cases.json should have .eval.json
# ============================================================================
echo -e "${CYAN}Test 1: Eval File Coverage${NC}"
echo "----------------------------------------------------------------------------"

skills_with_tc=0
skills_with_eval=0
skills_missing_eval=()

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue
    skill_name=$(basename "$(dirname "$tc_file")")
    skills_with_tc=$((skills_with_tc + 1))

    if [[ -n "${EVAL_FILES[$skill_name]+_}" ]]; then
        skills_with_eval=$((skills_with_eval + 1))
        info "$skill_name: Has .eval.json"
    else
        skills_missing_eval+=("$skill_name")
        warn "$skill_name: Has test-cases.json but no .eval.json in tests/evaluations/"
    fi
done

echo ""
echo "  Skills with test-cases.json: $skills_with_tc"
echo "  Skills with .eval.json:      $skills_with_eval"
echo "  Missing .eval.json:          ${#skills_missing_eval[@]}"

if [[ ${#skills_missing_eval[@]} -eq 0 ]]; then
    pass "All skills with test cases have evaluation files"
fi
echo ""

# ============================================================================
# Test 2: .eval.json expected_behavior alignment with test-cases.json
# ============================================================================
echo -e "${CYAN}Test 2: Expected Behavior Alignment${NC}"
echo "----------------------------------------------------------------------------"

alignment_checked=0

for eval_skill in "${!EVAL_FILES[@]}"; do
    eval_file="${EVAL_FILES[$eval_skill]}"
    tc_file="$SKILLS_DIR/$eval_skill/test-cases.json"

    # Skip if no test-cases.json for this skill
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    alignment_checked=$((alignment_checked + 1))

    # Get all expectedBehavior strings from test-cases.json (lowercased)
    tc_behaviors=$(jq -r '[.testCases[].expectedBehavior[]?] | map(ascii_downcase) | .[]' "$tc_file" 2>/dev/null || true)

    # Check each eval expected_behavior has a related entry in test-cases.json
    eval_count=$(jq '.evaluations | length' "$eval_file")
    orphaned=0

    for i in $(seq 0 $((eval_count - 1))); do
        eb_count=$(jq ".evaluations[$i].expected_behavior | length" "$eval_file" 2>/dev/null || echo 0)
        [[ "$eb_count" -eq 0 ]] && continue

        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")

        for b in $(seq 0 $((eb_count - 1))); do
            eb=$(jq -r ".evaluations[$i].expected_behavior[$b]" "$eval_file")
            eb_lower=$(echo "$eb" | tr '[:upper:]' '[:lower:]')

            # Check if any test-case expectedBehavior shares key terms
            found=0
            # Extract 2 key terms from the eval behavior
            terms=$(echo "$eb_lower" | tr -cs '[:alnum:]' ' ')
            for tc_b in $tc_behaviors; do
                for term in $terms; do
                    if [[ ${#term} -ge 5 && "$tc_b" == *"$term"* ]]; then
                        found=1
                        break 2
                    fi
                done
            done

            if [[ $found -eq 0 ]]; then
                orphaned=$((orphaned + 1))
                info "$eval_skill/$eval_id: Eval behavior has no close match in test-cases.json: \"$eb\""
            fi
        done
    done

    if [[ $orphaned -eq 0 ]]; then
        info "$eval_skill: All eval behaviors have matching test case behaviors"
    else
        info "$eval_skill: $orphaned eval behavior(s) without close test-case match"
    fi
done

if [[ $alignment_checked -gt 0 ]]; then
    pass "Checked alignment for $alignment_checked skills with both files"
fi
echo ""

# ============================================================================
# Test 3: should_not entries must not be instructed in rules
# ============================================================================
echo -e "${CYAN}Test 3: should_not Contradiction Check${NC}"
echo "----------------------------------------------------------------------------"

contradictions=0

# Imperative patterns that indicate a POSITIVE instruction (not just a mention)
IMPERATIVE_RE="(must|always|shall|require|implement|use|ensure|enforce)"
# Negation patterns — if these appear on the same line, it's agreement not contradiction
NEGATION_RE="(never|don.t|do not|should not|must not|avoid|don't|prohibited|forbid|warning|caution|instead of|rather than|not recommend)"

for eval_skill in "${!EVAL_FILES[@]}"; do
    eval_file="${EVAL_FILES[$eval_skill]}"
    skill_dir="$SKILLS_DIR/$eval_skill"

    eval_count=$(jq '.evaluations | length' "$eval_file")
    for i in $(seq 0 $((eval_count - 1))); do
        has_sn=$(jq -r ".evaluations[$i] | has(\"should_not\")" "$eval_file")
        [[ "$has_sn" == "true" ]] || continue

        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")
        sn_count=$(jq ".evaluations[$i].should_not | length" "$eval_file")

        for s in $(seq 0 $((sn_count - 1))); do
            sn=$(jq -r ".evaluations[$i].should_not[$s]" "$eval_file")
            terms=$(extract_terms "$sn")
            [[ -n "$terms" ]] || continue

            # Collect content from SKILL.md and rules/ files
            content_files=()
            [[ -f "$skill_dir/SKILL.md" ]] && content_files+=("$skill_dir/SKILL.md")
            if [[ -d "$skill_dir/rules" ]]; then
                for rf in "$skill_dir/rules"/*.md; do
                    [[ -f "$rf" ]] && content_files+=("$rf")
                done
            fi

            for cf in "${content_files[@]}"; do
                # Strip YAML frontmatter (between --- delimiters) before scanning
                # Frontmatter fields like impactDescription are metadata, not instructions
                cf_content=$(awk 'BEGIN{fm=0} /^---$/{fm=!fm; next} fm{next} {print}' "$cf" | tr '[:upper:]' '[:lower:]')
                cf_basename=$(basename "$cf")

                # Check each term: does it appear near an imperative keyword?
                match_count=0
                term_count=0
                for term in $terms; do
                    term_count=$((term_count + 1))
                    # Look for lines containing both the term and an imperative word
                    while IFS= read -r line; do
                        if [[ "$line" == *"$term"* ]]; then
                            # Check if the line has an imperative pattern
                            if [[ "$line" =~ $IMPERATIVE_RE ]]; then
                                # But skip if the line ALSO has a negation (agreement, not contradiction)
                                if ! [[ "$line" =~ $NEGATION_RE ]]; then
                                    match_count=$((match_count + 1))
                                    break
                                fi
                            fi
                        fi
                    done <<< "$cf_content"
                done

                # Flag only if ALL non-stopword terms appear as imperative instructions
                # AND there are at least 3 matching terms (fewer is too noisy)
                if [[ $term_count -ge 3 ]]; then
                    threshold=$term_count
                    if [[ $match_count -ge $threshold ]]; then
                        fail "$eval_skill/$eval_id: Contradiction in $cf_basename — should_not terms instructed: \"$sn\" ($match_count/$term_count terms)"
                        contradictions=$((contradictions + 1))
                        break  # one contradiction per should_not per skill is enough
                    fi
                fi
            done
        done
    done
done

if [[ $contradictions -eq 0 ]]; then
    pass "No contradictions found between should_not entries and skill instructions"
fi
echo ""

# ============================================================================
# Test 4: Unique test case IDs
# ============================================================================
echo -e "${CYAN}Test 4: Unique Test Case IDs${NC}"
echo "----------------------------------------------------------------------------"

duplicate_skills=0

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    skill_name=$(basename "$(dirname "$tc_file")")

    # Get all IDs and check for duplicates
    total_ids=$(jq '[.testCases[].id] | length' "$tc_file")
    unique_ids=$(jq '[.testCases[].id] | unique | length' "$tc_file")

    if [[ "$total_ids" -ne "$unique_ids" ]]; then
        duplicates=$(jq '[.testCases[].id] | group_by(.) | map(select(length > 1)) | map(.[0]) | .[]' "$tc_file")
        fail "$skill_name: Duplicate test case IDs: $duplicates"
        duplicate_skills=$((duplicate_skills + 1))
    else
        info "$skill_name: All $total_ids test case IDs are unique"
    fi
done

if [[ $duplicate_skills -eq 0 ]]; then
    pass "All test case IDs are unique within their skills"
fi
echo ""

# ============================================================================
# Test 5: expectedBehavior specificity
# ============================================================================
echo -e "${CYAN}Test 5: Expected Behavior Specificity${NC}"
echo "----------------------------------------------------------------------------"

vague_count=0
short_count=0

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    skill_name=$(basename "$(dirname "$tc_file")")
    tc_count=$(jq '.testCases | length' "$tc_file")

    for i in $(seq 0 $((tc_count - 1))); do
        tc_id=$(jq -r ".testCases[$i].id" "$tc_file")
        behavior_count=$(jq ".testCases[$i].expectedBehavior | length" "$tc_file")

        for b in $(seq 0 $((behavior_count - 1))); do
            behavior=$(jq -r ".testCases[$i].expectedBehavior[$b]" "$tc_file")

            # Check word count (must be >5 words)
            word_count=$(echo "$behavior" | wc -w | tr -d ' ')
            if [[ "$word_count" -le 5 ]]; then
                warn "$skill_name/$tc_id: Too short ($word_count words): \"$behavior\""
                short_count=$((short_count + 1))
            fi

            # Check for generic phrases
            if is_generic "$behavior"; then
                warn "$skill_name/$tc_id: Generic behavior: \"$behavior\""
                vague_count=$((vague_count + 1))
            fi
        done
    done
done

if [[ $vague_count -eq 0 && $short_count -eq 0 ]]; then
    pass "All expectedBehavior entries are specific and descriptive"
else
    if [[ $short_count -gt 0 ]]; then
        echo "  $short_count behavior(s) with 5 or fewer words"
    fi
    if [[ $vague_count -gt 0 ]]; then
        echo "  $vague_count behavior(s) with generic phrasing"
    fi
fi
echo ""

# ============================================================================
# Test 6: Orphaned eval files (referencing non-existent skills)
# ============================================================================
echo -e "${CYAN}Test 6: Orphaned Eval Files${NC}"
echo "----------------------------------------------------------------------------"

orphaned_evals=0

for eval_file in "$EVALS_DIR"/*.eval.json; do
    [[ -f "$eval_file" ]] || continue
    jq empty "$eval_file" 2>/dev/null || continue

    eval_skill=$(jq -r '.skill' "$eval_file")
    eval_basename=$(basename "$eval_file")

    if [[ ! -d "$SKILLS_DIR/$eval_skill" ]]; then
        fail "$eval_basename: References non-existent skill '$eval_skill'"
        orphaned_evals=$((orphaned_evals + 1))
    else
        info "$eval_basename: Skill '$eval_skill' exists"
    fi
done

if [[ $orphaned_evals -eq 0 ]]; then
    pass "All .eval.json files reference existing skills"
fi
echo ""

# ============================================================================
# Summary
# ============================================================================
echo "============================================================================"
echo "  Eval Completeness Summary"
echo "============================================================================"
echo ""
echo -e "  ${GREEN}Passed:          $PASS_COUNT${NC}"
echo -e "  ${RED}Failed:          $FAIL_COUNT${NC}"
echo -e "  ${YELLOW}Warnings:        $WARN_COUNT${NC}"
echo ""
echo "============================================================================"

if [[ $FAIL_COUNT -gt 0 ]]; then
    echo -e "${RED}FAILED: $FAIL_COUNT test(s) failed${NC}"
    exit 1
else
    echo -e "${GREEN}SUCCESS: All critical tests passed${NC}"
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}Note: $WARN_COUNT warning(s) should be reviewed${NC}"
    fi
    exit 0
fi
