#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-16

# ============================================================================
# Eval Completeness Tests
# ============================================================================
# Validates consistency between test-cases.json and .eval.json files.
#
# Tests:
# 1. Skills with test-cases.json should have a corresponding .eval.json
# 2. .eval.json expected_behavior entries should align with test-cases.json
# 3. .eval.json should_not entries must not appear as instructions in rules/
# 4. test-cases.json IDs must be unique within each skill
# 5. expectedBehavior strings must be specific (>5 words, not generic)
#
# Usage: ./test-eval-completeness.sh [--verbose]
# Exit codes: 0 = all pass, 1 = failures found
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$SCRIPT_DIR/../../.." && pwd)}"
SKILLS_DIR="$PROJECT_ROOT/src/skills"
EVALS_DIR="$PROJECT_ROOT/tests/evaluations"

VERBOSE="${1:-}"

# Counters
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0

# Colors
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC=''
fi

pass() {
    echo -e "  ${GREEN}PASS${NC} $1"
    PASS_COUNT=$((PASS_COUNT + 1))
}

fail() {
    echo -e "  ${RED}FAIL${NC} $1"
    FAIL_COUNT=$((FAIL_COUNT + 1))
}

warn() {
    echo -e "  ${YELLOW}WARN${NC} $1"
    WARN_COUNT=$((WARN_COUNT + 1))
}

info() {
    if [[ "$VERBOSE" == "--verbose" ]]; then
        echo -e "  ${BLUE}INFO${NC} $1"
    fi
}

# Generic phrases that are too vague for expectedBehavior
GENERIC_PATTERNS=(
    "follow best practices"
    "handle errors"
    "be secure"
    "work correctly"
    "be performant"
    "use appropriate"
    "implement properly"
)

is_generic() {
    local text="$1"
    local lower
    lower=$(echo "$text" | tr '[:upper:]' '[:lower:]')

    for pattern in "${GENERIC_PATTERNS[@]}"; do
        if [[ "$lower" == *"$pattern"* ]]; then
            return 0
        fi
    done
    return 1
}

# ============================================================================
# Header
# ============================================================================
echo "============================================================================"
echo "  Eval Completeness Tests"
echo "============================================================================"
echo ""

# Build map of existing .eval.json files (skill name -> file path)
declare -A EVAL_FILES
for eval_file in "$EVALS_DIR"/*.eval.json; do
    [[ -f "$eval_file" ]] || continue
    if jq empty "$eval_file" 2>/dev/null; then
        eval_skill=$(jq -r '.skill' "$eval_file")
        EVAL_FILES["$eval_skill"]="$eval_file"
    fi
done

# ============================================================================
# Test 1: Skills with test-cases.json should have .eval.json
# ============================================================================
echo -e "${CYAN}Test 1: Eval File Coverage${NC}"
echo "----------------------------------------------------------------------------"

skills_with_tc=0
skills_with_eval=0
skills_missing_eval=()

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue
    skill_name=$(basename "$(dirname "$tc_file")")
    skills_with_tc=$((skills_with_tc + 1))

    if [[ -n "${EVAL_FILES[$skill_name]+_}" ]]; then
        skills_with_eval=$((skills_with_eval + 1))
        info "$skill_name: Has .eval.json"
    else
        skills_missing_eval+=("$skill_name")
        warn "$skill_name: Has test-cases.json but no .eval.json in tests/evaluations/"
    fi
done

echo ""
echo "  Skills with test-cases.json: $skills_with_tc"
echo "  Skills with .eval.json:      $skills_with_eval"
echo "  Missing .eval.json:          ${#skills_missing_eval[@]}"

if [[ ${#skills_missing_eval[@]} -eq 0 ]]; then
    pass "All skills with test cases have evaluation files"
fi
echo ""

# ============================================================================
# Test 2: .eval.json expected_behavior alignment with test-cases.json
# ============================================================================
echo -e "${CYAN}Test 2: Expected Behavior Alignment${NC}"
echo "----------------------------------------------------------------------------"

alignment_checked=0

for eval_skill in "${!EVAL_FILES[@]}"; do
    eval_file="${EVAL_FILES[$eval_skill]}"
    tc_file="$SKILLS_DIR/$eval_skill/test-cases.json"

    # Skip if no test-cases.json for this skill
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    alignment_checked=$((alignment_checked + 1))

    # Get all expectedBehavior strings from test-cases.json (lowercased)
    tc_behaviors=$(jq -r '[.testCases[].expectedBehavior[]?] | map(ascii_downcase) | .[]' "$tc_file" 2>/dev/null || true)

    # Check each eval expected_behavior has a related entry in test-cases.json
    eval_count=$(jq '.evaluations | length' "$eval_file")
    orphaned=0

    for i in $(seq 0 $((eval_count - 1))); do
        eb_count=$(jq ".evaluations[$i].expected_behavior | length" "$eval_file" 2>/dev/null || echo 0)
        [[ "$eb_count" -eq 0 ]] && continue

        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")

        for b in $(seq 0 $((eb_count - 1))); do
            eb=$(jq -r ".evaluations[$i].expected_behavior[$b]" "$eval_file")
            eb_lower=$(echo "$eb" | tr '[:upper:]' '[:lower:]')

            # Check if any test-case expectedBehavior shares key terms
            found=0
            # Extract 2 key terms from the eval behavior
            terms=$(echo "$eb_lower" | tr -cs '[:alnum:]' ' ')
            for tc_b in $tc_behaviors; do
                for term in $terms; do
                    if [[ ${#term} -ge 5 && "$tc_b" == *"$term"* ]]; then
                        found=1
                        break 2
                    fi
                done
            done

            if [[ $found -eq 0 ]]; then
                orphaned=$((orphaned + 1))
                info "$eval_skill/$eval_id: Eval behavior has no close match in test-cases.json: \"$eb\""
            fi
        done
    done

    if [[ $orphaned -eq 0 ]]; then
        info "$eval_skill: All eval behaviors have matching test case behaviors"
    else
        info "$eval_skill: $orphaned eval behavior(s) without close test-case match"
    fi
done

if [[ $alignment_checked -gt 0 ]]; then
    pass "Checked alignment for $alignment_checked skills with both files"
fi
echo ""

# ============================================================================
# Test 3: should_not entries must not be instructed in rules
# ============================================================================
echo -e "${CYAN}Test 3: should_not Contradiction Check${NC}"
echo "----------------------------------------------------------------------------"

contradictions=0

for eval_skill in "${!EVAL_FILES[@]}"; do
    eval_file="${EVAL_FILES[$eval_skill]}"
    skill_dir="$SKILLS_DIR/$eval_skill"
    rules_dir="$skill_dir/rules"

    [[ -d "$rules_dir" ]] || continue

    eval_count=$(jq '.evaluations | length' "$eval_file")
    for i in $(seq 0 $((eval_count - 1))); do
        has_sn=$(jq -r ".evaluations[$i] | has(\"should_not\")" "$eval_file")
        [[ "$has_sn" == "true" ]] || continue

        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")
        sn_count=$(jq ".evaluations[$i].should_not | length" "$eval_file")

        for s in $(seq 0 $((sn_count - 1))); do
            sn=$(jq -r ".evaluations[$i].should_not[$s]" "$eval_file")
            sn_lower=$(echo "$sn" | tr '[:upper:]' '[:lower:]')

            # Check SKILL.md for direct instruction of forbidden behavior
            skill_file="$skill_dir/SKILL.md"
            if [[ -f "$skill_file" ]]; then
                skill_lower=$(tr '[:upper:]' '[:lower:]' < "$skill_file")
                if [[ "$skill_lower" == *"$sn_lower"* ]]; then
                    fail "$eval_skill/$eval_id: SKILL.md contains exact should_not text: \"$sn\""
                    contradictions=$((contradictions + 1))
                fi
            fi
        done
    done
done

if [[ $contradictions -eq 0 ]]; then
    pass "No contradictions found (should_not text not found verbatim in SKILL.md)"
fi
echo ""

# ============================================================================
# Test 4: Unique test case IDs
# ============================================================================
echo -e "${CYAN}Test 4: Unique Test Case IDs${NC}"
echo "----------------------------------------------------------------------------"

duplicate_skills=0

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    skill_name=$(basename "$(dirname "$tc_file")")

    # Get all IDs and check for duplicates
    total_ids=$(jq '[.testCases[].id] | length' "$tc_file")
    unique_ids=$(jq '[.testCases[].id] | unique | length' "$tc_file")

    if [[ "$total_ids" -ne "$unique_ids" ]]; then
        duplicates=$(jq '[.testCases[].id] | group_by(.) | map(select(length > 1)) | map(.[0]) | .[]' "$tc_file")
        fail "$skill_name: Duplicate test case IDs: $duplicates"
        duplicate_skills=$((duplicate_skills + 1))
    else
        info "$skill_name: All $total_ids test case IDs are unique"
    fi
done

if [[ $duplicate_skills -eq 0 ]]; then
    pass "All test case IDs are unique within their skills"
fi
echo ""

# ============================================================================
# Test 5: expectedBehavior specificity
# ============================================================================
echo -e "${CYAN}Test 5: Expected Behavior Specificity${NC}"
echo "----------------------------------------------------------------------------"

vague_count=0
short_count=0

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue

    if ! jq empty "$tc_file" 2>/dev/null; then
        continue
    fi

    skill_name=$(basename "$(dirname "$tc_file")")
    tc_count=$(jq '.testCases | length' "$tc_file")

    for i in $(seq 0 $((tc_count - 1))); do
        tc_id=$(jq -r ".testCases[$i].id" "$tc_file")
        behavior_count=$(jq ".testCases[$i].expectedBehavior | length" "$tc_file")

        for b in $(seq 0 $((behavior_count - 1))); do
            behavior=$(jq -r ".testCases[$i].expectedBehavior[$b]" "$tc_file")

            # Check word count (must be >5 words)
            word_count=$(echo "$behavior" | wc -w | tr -d ' ')
            if [[ "$word_count" -le 3 ]]; then
                warn "$skill_name/$tc_id: Too short ($word_count words): \"$behavior\""
                short_count=$((short_count + 1))
            fi

            # Check for generic phrases
            if is_generic "$behavior"; then
                warn "$skill_name/$tc_id: Generic behavior: \"$behavior\""
                vague_count=$((vague_count + 1))
            fi
        done
    done
done

if [[ $vague_count -eq 0 && $short_count -eq 0 ]]; then
    pass "All expectedBehavior entries are specific and descriptive"
else
    if [[ $short_count -gt 0 ]]; then
        echo "  $short_count behavior(s) with 3 or fewer words"
    fi
    if [[ $vague_count -gt 0 ]]; then
        echo "  $vague_count behavior(s) with generic phrasing"
    fi
fi
echo ""

# ============================================================================
# Summary
# ============================================================================
echo "============================================================================"
echo "  Eval Completeness Summary"
echo "============================================================================"
echo ""
echo -e "  ${GREEN}Passed:          $PASS_COUNT${NC}"
echo -e "  ${RED}Failed:          $FAIL_COUNT${NC}"
echo -e "  ${YELLOW}Warnings:        $WARN_COUNT${NC}"
echo ""
echo "============================================================================"

if [[ $FAIL_COUNT -gt 0 ]]; then
    echo -e "${RED}FAILED: $FAIL_COUNT test(s) failed${NC}"
    exit 1
else
    echo -e "${GREEN}SUCCESS: All critical tests passed${NC}"
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}Note: $WARN_COUNT warning(s) should be reviewed${NC}"
    fi
    exit 0
fi
