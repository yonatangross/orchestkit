#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-16

# ============================================================================
# Rule Traceability Tests
# ============================================================================
# Validates the traceability chain: test-cases.json -> rules/*.md -> content.
#
# Tests:
# 1. Rule file resolution: testCase.rule -> rules/{rule}.md must exist
# 2. Content verification: expectedBehavior terms appear in rule file content
# 3. Bidirectional coverage: rule files without test cases are flagged
# 4. Contradiction detection: .eval.json should_not entries vs rule content
#
# Usage: ./test-rule-traceability.sh [--verbose]
# Exit codes: 0 = all pass, 1 = failures found
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$SCRIPT_DIR/../../.." && pwd)}"
SKILLS_DIR="$PROJECT_ROOT/src/skills"
EVALS_DIR="$PROJECT_ROOT/tests/evaluations"

VERBOSE="${1:-}"

# Counters
PASS_COUNT=0
FAIL_COUNT=0
WARN_COUNT=0
TOTAL_BEHAVIORS=0
TRACED_BEHAVIORS=0
SKILLS_CHECKED=0

# Colors (only if stdout is a terminal)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    CYAN='\033[0;36m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' BLUE='' CYAN='' NC=''
fi

pass() {
    echo -e "  ${GREEN}PASS${NC} $1"
    PASS_COUNT=$((PASS_COUNT + 1))
}

fail() {
    echo -e "  ${RED}FAIL${NC} $1"
    FAIL_COUNT=$((FAIL_COUNT + 1))
}

warn() {
    echo -e "  ${YELLOW}WARN${NC} $1"
    WARN_COUNT=$((WARN_COUNT + 1))
}

info() {
    if [[ "$VERBOSE" == "--verbose" ]]; then
        echo -e "  ${BLUE}INFO${NC} $1"
    fi
}

# Stop words for keyword extraction (4+ char words to skip)
is_stopword() {
    local word="$1"
    case "$word" in
        this|that|with|from|have|does|what|when|where|which|will|would|could|should|these|those|them|then|than|their|there|they|been|being|were|also|into|each|only|just|more|most|some|such|very|like|make|made|used|uses|using|every|must|never|always|before|after|between|through|during|other|about|above|below|under|over)
            return 0 ;;
        *)
            return 1 ;;
    esac
}

# Extract meaningful terms (4+ chars, not stopwords) from a string
extract_terms() {
    local text="$1"
    local lower
    lower=$(echo "$text" | tr '[:upper:]' '[:lower:]' | tr -cs '[:alnum:]' ' ')
    local terms=()
    for word in $lower; do
        if [[ ${#word} -ge 4 ]] && ! is_stopword "$word"; then
            terms+=("$word")
        fi
    done
    echo "${terms[*]}"
}

# ============================================================================
# Header
# ============================================================================
echo "============================================================================"
echo "  Rule Traceability Tests"
echo "============================================================================"
echo ""
echo "Skills directory: $SKILLS_DIR"
echo ""

# ============================================================================
# Test 1 & 2: Rule resolution + content verification
# ============================================================================
echo -e "${CYAN}Test 1: Rule File Resolution & Content Verification${NC}"
echo "----------------------------------------------------------------------------"

for tc_file in "$SKILLS_DIR"/*/test-cases.json; do
    [[ -f "$tc_file" ]] || continue

    skill_dir=$(dirname "$tc_file")
    skill_name=$(basename "$skill_dir")
    rules_dir="$skill_dir/rules"
    SKILLS_CHECKED=$((SKILLS_CHECKED + 1))

    # Validate JSON
    if ! jq empty "$tc_file" 2>/dev/null; then
        fail "$skill_name: Invalid JSON in test-cases.json"
        continue
    fi

    # Get number of test cases
    tc_count=$(jq '.testCases | length' "$tc_file")
    if [[ "$tc_count" -eq 0 ]]; then
        warn "$skill_name: Empty testCases array"
        continue
    fi

    skill_traced=0
    skill_total=0

    for i in $(seq 0 $((tc_count - 1))); do
        tc_id=$(jq -r ".testCases[$i].id" "$tc_file")
        tc_rule=$(jq -r ".testCases[$i].rule // empty" "$tc_file")

        # Skip test cases without a rule field (orchestration skills)
        if [[ -z "$tc_rule" ]]; then
            info "$skill_name/$tc_id: No rule field (orchestration skill)"
            continue
        fi

        rule_file="$rules_dir/${tc_rule}.md"

        # Check 1: Rule file exists
        if [[ ! -f "$rule_file" ]]; then
            fail "$skill_name/$tc_id: Rule file not found: rules/${tc_rule}.md"
            continue
        fi

        # Read rule file content (lowercase for matching)
        rule_content=$(tr '[:upper:]' '[:lower:]' < "$rule_file")

        # Check 2: Each expectedBehavior has at least one term in rule content
        behavior_count=$(jq -r ".testCases[$i].expectedBehavior | length" "$tc_file")

        for b in $(seq 0 $((behavior_count - 1))); do
            behavior=$(jq -r ".testCases[$i].expectedBehavior[$b]" "$tc_file")
            TOTAL_BEHAVIORS=$((TOTAL_BEHAVIORS + 1))
            skill_total=$((skill_total + 1))

            terms=$(extract_terms "$behavior")
            found=0

            for term in $terms; do
                if [[ "$rule_content" == *"$term"* ]]; then
                    found=1
                    break
                fi
            done

            if [[ $found -eq 1 ]]; then
                TRACED_BEHAVIORS=$((TRACED_BEHAVIORS + 1))
                skill_traced=$((skill_traced + 1))
            else
                warn "$skill_name/$tc_id: No term match for behavior: \"$behavior\""
                info "  Terms checked: $terms"
            fi
        done
    done

    # Report per-skill score
    if [[ $skill_total -gt 0 ]]; then
        score=$((skill_traced * 100 / skill_total))
        if [[ $score -eq 100 ]]; then
            pass "$skill_name: ${skill_traced}/${skill_total} behaviors traced (${score}%)"
        else
            warn "$skill_name: ${skill_traced}/${skill_total} behaviors traced (${score}%)"
        fi
    else
        info "$skill_name: No rule-linked test cases"
    fi
done

echo ""

# ============================================================================
# Test 3: Bidirectional coverage (untested rules)
# ============================================================================
echo -e "${CYAN}Test 2: Bidirectional Coverage (Untested Rules)${NC}"
echo "----------------------------------------------------------------------------"

untested_total=0

for skill_dir in "$SKILLS_DIR"/*/; do
    [[ -d "$skill_dir" ]] || continue
    rules_dir="$skill_dir/rules"
    [[ -d "$rules_dir" ]] || continue

    skill_name=$(basename "$skill_dir")
    tc_file="$skill_dir/test-cases.json"

    # Collect tested rule names
    tested_rules=()
    if [[ -f "$tc_file" ]] && jq empty "$tc_file" 2>/dev/null; then
        while IFS= read -r rule_name; do
            [[ -n "$rule_name" ]] && tested_rules+=("$rule_name")
        done < <(jq -r '.testCases[].rule // empty' "$tc_file" 2>/dev/null)
    fi

    # Check each rule file
    for rule_file in "$rules_dir"/*.md; do
        [[ -f "$rule_file" ]] || continue
        rule_basename=$(basename "$rule_file" .md)

        # Skip template and sections files
        [[ "$rule_basename" == "_template" || "$rule_basename" == "_sections" ]] && continue

        # Check if this rule is covered by a test case
        is_tested=0
        for tested in "${tested_rules[@]+"${tested_rules[@]}"}"; do
            if [[ "$tested" == "$rule_basename" ]]; then
                is_tested=1
                break
            fi
        done

        if [[ $is_tested -eq 0 ]]; then
            warn "$skill_name: Untested rule: rules/${rule_basename}.md"
            untested_total=$((untested_total + 1))
        fi
    done
done

if [[ $untested_total -eq 0 ]]; then
    pass "All rule files have corresponding test cases"
else
    echo ""
    echo "  $untested_total rule file(s) without test coverage"
fi
echo ""

# ============================================================================
# Test 4: Contradiction detection (.eval.json should_not vs rules)
# ============================================================================
echo -e "${CYAN}Test 3: Contradiction Detection (should_not vs rule content)${NC}"
echo "----------------------------------------------------------------------------"

contradictions=0

for eval_file in "$EVALS_DIR"/*.eval.json; do
    [[ -f "$eval_file" ]] || continue

    if ! jq empty "$eval_file" 2>/dev/null; then
        continue
    fi

    eval_skill=$(jq -r '.skill' "$eval_file")
    skill_dir="$SKILLS_DIR/$eval_skill"

    # Check each evaluation's should_not entries
    eval_count=$(jq '.evaluations | length' "$eval_file")
    for i in $(seq 0 $((eval_count - 1))); do
        has_should_not=$(jq -r ".evaluations[$i] | has(\"should_not\")" "$eval_file")
        [[ "$has_should_not" == "true" ]] || continue

        should_not_count=$(jq ".evaluations[$i].should_not | length" "$eval_file")
        for s in $(seq 0 $((should_not_count - 1))); do
            should_not=$(jq -r ".evaluations[$i].should_not[$s]" "$eval_file")
            should_not_lower=$(echo "$should_not" | tr '[:upper:]' '[:lower:]')

            # Check if SKILL.md explicitly instructs this forbidden behavior
            skill_file="$skill_dir/SKILL.md"
            if [[ -f "$skill_file" ]]; then
                skill_content=$(tr '[:upper:]' '[:lower:]' < "$skill_file")
                # Extract key terms from should_not
                terms=$(extract_terms "$should_not")
                match_count=0
                term_count=0
                for term in $terms; do
                    term_count=$((term_count + 1))
                    if [[ "$skill_content" == *"$term"* ]]; then
                        match_count=$((match_count + 1))
                    fi
                done

                # Flag if majority of should_not terms appear as instructions
                if [[ $term_count -gt 0 ]]; then
                    threshold=$(( (term_count + 1) / 2 ))
                    if [[ $match_count -ge $threshold ]]; then
                        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")
                        info "$eval_skill/$eval_id: should_not terms found in SKILL.md: \"$should_not\" ($match_count/$term_count terms)"
                    fi
                fi
            fi

            # Check rule files for contradictions
            if [[ -d "$skill_dir/rules" ]]; then
                for rule_file in "$skill_dir/rules"/*.md; do
                    [[ -f "$rule_file" ]] || continue
                    rule_basename=$(basename "$rule_file" .md)
                    [[ "$rule_basename" == "_template" || "$rule_basename" == "_sections" ]] && continue

                    rule_content=$(tr '[:upper:]' '[:lower:]' < "$rule_file")
                    terms=$(extract_terms "$should_not")
                    match_count=0
                    term_count=0
                    for term in $terms; do
                        term_count=$((term_count + 1))
                        if [[ "$rule_content" == *"$term"* ]]; then
                            match_count=$((match_count + 1))
                        fi
                    done

                    # Flag if ALL key terms match â€” warn since term overlap may be
                    # contextual (e.g., "modify" appears in analysis context, not as instruction)
                    if [[ $term_count -gt 1 && $match_count -eq $term_count ]]; then
                        eval_id=$(jq -r ".evaluations[$i].id" "$eval_file")
                        warn "$eval_skill/$eval_id: Possible contradiction in rules/${rule_basename}.md for should_not: \"$should_not\""
                        contradictions=$((contradictions + 1))
                    fi
                done
            fi
        done
    done
done

if [[ $contradictions -eq 0 ]]; then
    pass "No contradictions found between should_not entries and rule files"
fi
echo ""

# ============================================================================
# Summary
# ============================================================================
echo "============================================================================"
echo "  Rule Traceability Summary"
echo "============================================================================"
echo ""
echo -e "  Skills checked:     $SKILLS_CHECKED"
echo -e "  Behaviors total:    $TOTAL_BEHAVIORS"
echo -e "  Behaviors traced:   $TRACED_BEHAVIORS"
if [[ $TOTAL_BEHAVIORS -gt 0 ]]; then
    overall_score=$((TRACED_BEHAVIORS * 100 / TOTAL_BEHAVIORS))
    echo -e "  Traceability score: ${overall_score}%"
fi
echo ""
echo -e "  ${GREEN}Passed:          $PASS_COUNT${NC}"
echo -e "  ${RED}Failed:          $FAIL_COUNT${NC}"
echo -e "  ${YELLOW}Warnings:        $WARN_COUNT${NC}"
echo ""
echo "============================================================================"

if [[ $FAIL_COUNT -gt 0 ]]; then
    echo -e "${RED}FAILED: $FAIL_COUNT test(s) failed${NC}"
    exit 1
else
    echo -e "${GREEN}SUCCESS: All critical tests passed${NC}"
    if [[ $WARN_COUNT -gt 0 ]]; then
        echo -e "${YELLOW}Note: $WARN_COUNT warning(s) should be reviewed${NC}"
    fi
    exit 0
fi
