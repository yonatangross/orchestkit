#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-17

# tests/hooks/test-hook-structure.sh
# Validates hooks.json structure and handler references
set -euo pipefail

PROJECT_ROOT="${CLAUDE_PROJECT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)}"
HOOKS_JSON="$PROJECT_ROOT/src/hooks/hooks.json"
DIST_DIR="$PROJECT_ROOT/src/hooks/dist"

RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

PASS=0
FAIL=0

pass() { echo -e "  ${GREEN}✓${NC} $1"; PASS=$((PASS + 1)); }
fail() { echo -e "  ${RED}✗${NC} $1"; FAIL=$((FAIL + 1)); }

echo "Hook Structure Tests"
echo "===================="

# 1. hooks.json exists and is valid JSON
if [[ ! -f "$HOOKS_JSON" ]]; then
  fail "hooks.json not found at $HOOKS_JSON"
  exit 1
fi

if python3 -c "import json; json.load(open('$HOOKS_JSON'))" 2>/dev/null; then
  pass "hooks.json is valid JSON"
else
  fail "hooks.json is not valid JSON"
  exit 1
fi

# 2. hooks.json has required top-level keys
if python3 -c "
import json, sys
data = json.load(open('$HOOKS_JSON'))
assert 'hooks' in data, 'missing hooks key'
assert isinstance(data['hooks'], dict), 'hooks must be dict'
" 2>/dev/null; then
  pass "hooks.json has 'hooks' object"
else
  fail "hooks.json missing 'hooks' object"
fi

# 3. All hook event types are valid Claude Code events
VALID_EVENTS="PreToolUse PostToolUse PostToolUseFailure Notification PermissionRequest UserPromptSubmit SessionStart SessionEnd PreCompact Stop SubagentStop SubagentStart TeammateIdle TaskCompleted Setup"
INVALID_EVENTS=$(python3 -c "
import json
valid = set('$VALID_EVENTS'.split())
data = json.load(open('$HOOKS_JSON'))
invalid = [k for k in data.get('hooks', {}).keys() if k not in valid]
if invalid: print(' '.join(invalid))
" 2>/dev/null || true)

if [[ -z "$INVALID_EVENTS" ]]; then
  pass "All hook event types are valid"
else
  fail "Invalid hook event types: $INVALID_EVENTS"
fi

# 4. All command hooks reference a known dispatcher script
BAD_COMMANDS=$(python3 -c "
import json
KNOWN_DISPATCHERS = ['run-hook.mjs', 'run-hook-silent.mjs', 'stop-fire-and-forget.mjs', 'stop-uncommitted-check.mjs']
data = json.load(open('$HOOKS_JSON'))
bad = []
for event, entries in data.get('hooks', {}).items():
  for entry in entries:
    for hook in entry.get('hooks', []):
      cmd = hook.get('command', '')
      if cmd and not any(d in cmd for d in KNOWN_DISPATCHERS):
        bad.append(f'{event}: {cmd[:60]}')
if bad:
  for b in bad: print(b)
" 2>/dev/null || true)

if [[ -z "$BAD_COMMANDS" ]]; then
  pass "All command hooks use known dispatcher scripts"
else
  fail "Commands not using known dispatcher: $BAD_COMMANDS"
fi

# 5. dist/ directory exists with compiled bundles
if [[ -d "$DIST_DIR" ]]; then
  BUNDLE_COUNT=$(find "$DIST_DIR" -name "*.mjs" -type f | wc -l | tr -d ' ')
  if [[ "$BUNDLE_COUNT" -gt 0 ]]; then
    pass "dist/ has $BUNDLE_COUNT compiled bundles"
  else
    fail "dist/ exists but has no .mjs bundles"
  fi
else
  fail "dist/ directory not found"
fi

# 6. Every hook handler path in hooks.json has a corresponding dist bundle
MISSING_BUNDLES=$(python3 -c "
import json, os, re
data = json.load(open('$HOOKS_JSON'))
dist = '$DIST_DIR'
bundles = set()
for f in os.listdir(dist):
    if f.endswith('.mjs'):
        bundles.add(f.replace('.mjs', ''))
# Extract category names from hook commands (e.g., 'pretool', 'posttool', 'prompt')
categories = set()
for event, entries in data.get('hooks', {}).items():
    for entry in entries:
        for hook in entry.get('hooks', []):
            cmd = hook.get('command', '')
            m = re.search(r'run-hook\.mjs\s+(\w+)/', cmd)
            if m:
                categories.add(m.group(1))
missing = [c for c in categories if c not in bundles]
if missing: print(' '.join(sorted(missing)))
" 2>/dev/null || true)

if [[ -z "$MISSING_BUNDLES" ]]; then
  pass "All hook categories have compiled bundles"
else
  fail "Missing dist bundles for: $MISSING_BUNDLES"
fi

# Summary
echo ""
echo "Results: $PASS passed, $FAIL failed"
[[ $FAIL -eq 0 ]] && exit 0 || exit 1
