#!/usr/bin/env bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-28

# test-context-injection-budget.sh — Measures token output from prompt dispatcher
#
# Invokes the unified prompt dispatcher with test prompts and measures
# the token count of injected context. Verifies it stays under budget.
#
# Usage: ./tests/hooks/test-context-injection-budget.sh
# Requires: node, built hooks (npm run build in src/hooks)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
HOOKS_DIST="$PROJECT_ROOT/src/hooks/dist"

# Budget constants
MAX_FIRST_MESSAGE_TOKENS=5000
MAX_PER_TURN_TOKENS=800

PASSED=0
FAILED=0
WARNINGS=0

pass() { echo "  ✓ $1"; PASSED=$((PASSED + 1)); }
fail() { echo "  ✗ $1"; FAILED=$((FAILED + 1)); }
warn() { echo "  ⚠ $1"; WARNINGS=$((WARNINGS + 1)); }

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  Context Injection Budget Test"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# Check prerequisites
if [ ! -f "$HOOKS_DIST/prompt.mjs" ]; then
  echo "ERROR: Hooks not built. Run: cd src/hooks && npm run build"
  exit 1
fi

# Create temp dir for test session flags (so once-per-session hooks fire)
TEST_SESSION_DIR=$(mktemp -d)
TEST_SESSION_ID="test-budget-$(date +%s)"
trap "rm -rf $TEST_SESSION_DIR" EXIT

# Helper: run dispatcher with a prompt and capture the additionalContext token count
measure_tokens() {
  local prompt="$1"
  local label="$2"

  local input_json
  input_json=$(cat <<JSONEOF
{
  "prompt": "$prompt",
  "session_id": "$TEST_SESSION_ID",
  "project_dir": "$PROJECT_ROOT"
}
JSONEOF
)

  local result
  result=$(echo "$input_json" | ORCHESTKIT_LOG_LEVEL=error CLAUDE_SESSION_ID="$TEST_SESSION_ID" CLAUDE_PROJECT_DIR="$PROJECT_ROOT" node -e "
    import('$HOOKS_DIST/prompt.mjs').then(mod => {
      const hooks = mod.hooks || {};
      const dispatcherFn = hooks['prompt/unified-dispatcher'];
      if (!dispatcherFn) {
        console.log(JSON.stringify({error: 'dispatcher not found', available: Object.keys(hooks)}));
        process.exit(1);
      }

      let input = '';
      process.stdin.on('data', chunk => input += chunk);
      process.stdin.on('end', () => {
        try {
          const parsed = JSON.parse(input);
          const result = dispatcherFn(parsed);
          const ctx = result?.hookSpecificOutput?.additionalContext || result?.systemMessage || '';
          const tokens = ctx ? Math.ceil(ctx.length / 3.5) : 0;
          console.log(JSON.stringify({tokens, length: ctx.length, hasContext: !!ctx}));
        } catch(e) {
          console.log(JSON.stringify({error: e.message, tokens: 0}));
        }
      });
    }).catch(e => {
      console.log(JSON.stringify({error: e.message}));
      process.exit(1);
    });
  " 2>/dev/null)

  local tokens
  tokens=$(echo "$result" | node -e "
    let d=''; process.stdin.on('data',c=>d+=c); process.stdin.on('end',()=>{
      try { console.log(JSON.parse(d).tokens || 0); } catch { console.log(-1); }
    });
  " 2>/dev/null)

  echo "$tokens"
}

echo ""
echo "▶ Test 1: Simple greeting (should trigger minimal context)"
echo "────────────────────────────────────────────────────────────"

HELLO_TOKENS=$(measure_tokens "hello" "simple greeting")

if [ "$HELLO_TOKENS" = "-1" ] || [ -z "$HELLO_TOKENS" ]; then
  warn "Could not measure tokens (dispatcher may not be importable as ESM)"
  echo "    Falling back to static analysis..."

  # Static analysis: count the AGENTATION_CONTEXT string length
  AGENTATION_LEN=$(grep -o '\[Agentation\].*' "$PROJECT_ROOT/src/hooks/src/prompt/agentation-context.ts" | head -1 | wc -c | tr -d ' ')
  AGENTATION_TOKENS=$((AGENTATION_LEN / 3))

  if [ "$AGENTATION_TOKENS" -lt 20 ]; then
    pass "Agentation context compressed (~${AGENTATION_TOKENS}t, was ~45t)"
  else
    fail "Agentation context still large (~${AGENTATION_TOKENS}t, target <20t)"
  fi
else
  echo "    Tokens on 'hello': $HELLO_TOKENS"
  if [ "$HELLO_TOKENS" -le "$MAX_PER_TURN_TOKENS" ]; then
    pass "'hello' under per-turn budget ($HELLO_TOKENS ≤ $MAX_PER_TURN_TOKENS)"
  else
    fail "'hello' exceeds per-turn budget ($HELLO_TOKENS > $MAX_PER_TURN_TOKENS)"
  fi
fi

echo ""
echo "▶ Test 2: Memory trigger keyword narrowing"
echo "────────────────────────────────────────────────────────────"

# These prompts should NOT trigger memory search (removed keywords)
for prompt in "add a button" "fix the bug" "create a file" "build the project" "update the readme" "implement auth" "change the color" "modify the config"; do
  # Check if shouldSearchMemory would return false
  SHOULD_TRIGGER=$(node -e "
    const KEYWORDS = ['design','refactor','continue','resume','previous','last time','before','earlier','pattern','decision','how did we','what did we'];
    const STRONG = ['remember','how did we','what did we','last time'];
    const p = '$prompt'.toLowerCase();
    const strongMatch = STRONG.some(k => p.includes(k));
    let count = 0;
    for (const k of KEYWORDS) { if (p.includes(k)) count++; }
    console.log(strongMatch || count >= 2 ? 'yes' : 'no');
  " 2>/dev/null)

  if [ "$SHOULD_TRIGGER" = "no" ]; then
    pass "\"$prompt\" correctly does NOT trigger memory search"
  else
    fail "\"$prompt\" incorrectly triggers memory search"
  fi
done

echo ""
echo "▶ Test 3: Strong single keywords still trigger"
echo "────────────────────────────────────────────────────────────"

for prompt in "do you remember the auth pattern" "how did we handle caching" "what did we decide about the API" "last time we discussed deployment"; do
  SHOULD_TRIGGER=$(node -e "
    const STRONG = ['remember','how did we','what did we','last time'];
    const p = '$prompt'.toLowerCase();
    console.log(STRONG.some(k => p.includes(k)) ? 'yes' : 'no');
  " 2>/dev/null)

  if [ "$SHOULD_TRIGGER" = "yes" ]; then
    pass "\"$prompt\" correctly triggers memory search"
  else
    fail "\"$prompt\" should trigger memory search but doesn't"
  fi
done

echo ""
echo "▶ Test 4: Realtime-sync keyword changes"
echo "────────────────────────────────────────────────────────────"

# "must" and "cannot" should NOT trigger IMMEDIATE sync
IMMEDIATE_RE="decided|chose|architecture|security|blocked|breaking|critical|deprecated|removed|migration"

for word in "must" "cannot"; do
  if echo "$IMMEDIATE_RE" | grep -q "$word"; then
    fail "\"$word\" still in IMMEDIATE_KEYWORDS"
  else
    pass "\"$word\" removed from IMMEDIATE_KEYWORDS"
  fi
done

# MIN_CONTENT_LENGTH should be 60
MIN_LEN=$(grep 'MIN_CONTENT_LENGTH' "$PROJECT_ROOT/src/hooks/src/posttool/realtime-sync.ts" | grep -o '[0-9]*')
if [ "$MIN_LEN" = "60" ]; then
  pass "MIN_CONTENT_LENGTH = 60 (was 30)"
else
  fail "MIN_CONTENT_LENGTH = $MIN_LEN (expected 60)"
fi

echo ""
echo "▶ Test 5: Agentation context compression"
echo "────────────────────────────────────────────────────────────"

AGENTATION_LINES=$(grep -c '.' "$PROJECT_ROOT/src/hooks/src/prompt/agentation-context.ts" <<< "$(sed -n '/AGENTATION_CONTEXT/,/;$/p' "$PROJECT_ROOT/src/hooks/src/prompt/agentation-context.ts")" 2>/dev/null || echo "0")

# Check that the constant value fits on one line (backtick string with no newlines)
CONST_HAS_NEWLINE=$(node -e "
  const src = require('fs').readFileSync('$PROJECT_ROOT/src/hooks/src/prompt/agentation-context.ts','utf8');
  const m = src.match(/AGENTATION_CONTEXT\s*=\s*\x60([^\x60]*)\x60/);
  console.log(m && !m[1].includes('\\n') ? 'single' : 'multi');
" 2>/dev/null)
if [ "$CONST_HAS_NEWLINE" = "single" ]; then
  pass "AGENTATION_CONTEXT is single-line (was 4 lines)"
else
  fail "AGENTATION_CONTEXT still has newlines (expected single-line)"
fi

echo ""
echo "▶ Test 6: Noisy output filter"
echo "────────────────────────────────────────────────────────────"

# Test isNoisyOutput logic
# Test individual noisy lines
for input in "[Cross-project context: orchestkit]" "[2026-02-28 08:45]"; do
  IS_NOISY=$(node -e "
    const lines = '$input'.split('\\n').filter(l => l.trim().length > 0);
    const noisy = lines.length === 0 || lines.every(line => {
      const t = line.trim();
      if (/^\[Cross-project context:.*\]$/.test(t)) return true;
      if (/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}.*\]$/.test(t)) return true;
      return false;
    });
    console.log(noisy ? 'yes' : 'no');
  " 2>/dev/null)

  if [ "$IS_NOISY" = "yes" ]; then
    pass "\"$input\" correctly detected as noisy"
  else
    fail "\"$input\" should be noisy but wasn't"
  fi
done

# Test multi-line noisy content (actual newline via node)
IS_NOISY=$(node -e "
  const input = '[Cross-project context: foo]\n[2026-01-01 12:00]';
  const lines = input.split('\n').filter(l => l.trim().length > 0);
  const noisy = lines.length === 0 || lines.every(line => {
    const t = line.trim();
    if (/^\[Cross-project context:.*\]$/.test(t)) return true;
    if (/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}.*\]$/.test(t)) return true;
    return false;
  });
  console.log(noisy ? 'yes' : 'no');
" 2>/dev/null)

if [ "$IS_NOISY" = "yes" ]; then
  pass "Multi-line noisy content correctly detected"
else
  fail "Multi-line noisy content should be detected as noisy"
fi

# Non-noisy content should pass through
IS_NOISY=$(node -e "
  const input = 'Use mcp__memory__search_nodes for context';
  const lines = input.split('\\\\n').filter(l => l.trim().length > 0);
  const noisy = lines.length === 0 || lines.every(line => {
    const t = line.trim();
    if (/^\[Cross-project context:.*\]$/.test(t)) return true;
    if (/^\[\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}.*\]$/.test(t)) return true;
    return false;
  });
  console.log(noisy ? 'yes' : 'no');
" 2>/dev/null)

if [ "$IS_NOISY" = "no" ]; then
  pass "Actionable content correctly passes noise filter"
else
  fail "Actionable content incorrectly filtered as noisy"
fi

echo ""
echo "▶ Test 7: SessionStart hook consolidation"
echo "────────────────────────────────────────────────────────────"

SESSION_START_HOOKS=$(node -e "
  const hooks = JSON.parse(require('fs').readFileSync('$PROJECT_ROOT/src/hooks/hooks.json', 'utf8'));
  const ss = hooks.hooks.SessionStart[0].hooks;
  console.log(ss.length);
" 2>/dev/null)

if [ "$SESSION_START_HOOKS" = "3" ]; then
  pass "SessionStart has 3 hooks (was 6): async-dispatcher, sync-dispatcher, pr-status-enricher"
else
  fail "SessionStart has $SESSION_START_HOOKS hooks (expected 3)"
fi

# Verify sync-session-dispatcher exists
if grep -q "sync-session-dispatcher" "$PROJECT_ROOT/src/hooks/hooks.json"; then
  pass "sync-session-dispatcher registered in hooks.json"
else
  fail "sync-session-dispatcher NOT in hooks.json"
fi

echo ""
echo "▶ Test 8: session_id fallback"
echo "────────────────────────────────────────────────────────────"

if grep -q "getSessionId" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts" && grep -q "input.session_id || getSessionId()" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
  pass "session_id falls back to getSessionId() (was empty string)"
else
  fail "session_id fallback not properly implemented"
fi

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "  Results: $PASSED passed, $FAILED failed, $WARNINGS warnings"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ "$FAILED" -gt 0 ]; then
  echo "FAILED"
  exit 1
else
  echo "ALL TESTS PASSED"
  exit 0
fi
