#!/bin/bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-15

# ============================================================================
# Image Paste Guard Tests
# Issue #620: Image paste kills context window
# ============================================================================
# Behavioral tests for the 3-layer defense against oversized/binary prompts:
#   Layer 1: run-hook.mjs MAX_STDIN_BYTES (512KB stdin cap)
#   Layer 2: unified-dispatcher MAX_PROMPT_LENGTH + isImageOrBinaryPrompt()
#   Layer 3: capture-user-intent MAX_PROMPT_LENGTH + isImageOrBinaryPrompt()
#
# Tests verify that hooks:
#   1. Return silent success for oversized prompts
#   2. Return silent success for base64 image data
#   3. Return silent success for data URI prompts
#   4. Still work normally for regular text prompts
#   5. Handle edge cases (just under limit, just over limit)
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

RUN_HOOK="$PROJECT_ROOT/src/hooks/bin/run-hook.mjs"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0

log_pass() {
    echo -e "  ${GREEN}â—‹${NC} $1... ${GREEN}PASS${NC}"
    TESTS_PASSED=$((TESTS_PASSED + 1))
}

log_fail() {
    echo -e "  ${RED}âœ—${NC} $1... ${RED}FAIL${NC}"
    echo -e "    ${RED}$2${NC}"
    TESTS_FAILED=$((TESTS_FAILED + 1))
}

# Run a hook with given JSON input and return stdout
run_hook_with_input() {
    local hook_name="$1"
    local json_input="$2"
    local timeout_sec="${3:-5}"

    echo "$json_input" | timeout "${timeout_sec}" node "$RUN_HOOK" "$hook_name" 2>/dev/null || true
}

# Check if output indicates silent success (continue=true, suppressOutput=true)
is_silent_success() {
    local output="$1"
    if [[ -z "$output" ]]; then
        return 1
    fi
    local cont suppress
    cont=$(echo "$output" | jq -r '.continue' 2>/dev/null)
    suppress=$(echo "$output" | jq -r '.suppressOutput' 2>/dev/null)
    [[ "$cont" == "true" && "$suppress" == "true" ]]
}

# Check if output has additionalContext (hook actually processed the prompt)
has_additional_context() {
    local output="$1"
    local ctx
    ctx=$(echo "$output" | jq -r '.hookSpecificOutput.additionalContext // empty' 2>/dev/null)
    [[ -n "$ctx" ]]
}

# Generate a string of N characters
generate_string() {
    local length="$1"
    local char="${2:-a}"
    printf '%0.s'"$char" $(seq 1 "$length")
}

# Generate fake base64 content (continuous A-Za-z0-9+/= chars)
generate_base64_block() {
    local length="$1"
    # Use a repeating base64-like pattern
    local pattern="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    local result=""
    while [[ ${#result} -lt "$length" ]]; do
        result="${result}${pattern}"
    done
    echo "${result:0:$length}"
}

echo ""
echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "${CYAN}  Image Paste Guard Tests (Issue #620)${NC}"
echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

# Check prerequisites
if [[ ! -f "$RUN_HOOK" ]]; then
    echo -e "${RED}SKIP: run-hook.mjs not found at $RUN_HOOK${NC}"
    exit 0
fi

if ! command -v timeout >/dev/null 2>&1 && ! command -v gtimeout >/dev/null 2>&1; then
    # macOS without coreutils â€” redefine timeout as direct exec
    timeout() { shift; "$@"; }
fi

# Redefine timeout to use gtimeout on macOS if available
if ! command -v timeout >/dev/null 2>&1 && command -v gtimeout >/dev/null 2>&1; then
    timeout() { gtimeout "$@"; }
fi

# ============================================================================
# Layer 2: unified-dispatcher prompt guard tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 2: unified-dispatcher prompt guards${NC}"
echo ""

# Test 1: Normal text prompt processes normally
test_normal_prompt() {
    local input='{"prompt":"implement a new login feature using JWT","tool_name":"","session_id":"test","tool_input":{}}'
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "normal text prompt processes without error"
    else
        log_fail "normal text prompt processes without error" "Got: $output"
    fi
}
test_normal_prompt

# Test 2: Oversized prompt (>50K chars) returns silent success
test_oversized_prompt() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input" 10)
    if is_silent_success "$output"; then
        log_pass "oversized prompt (60K chars) returns silent success"
    else
        log_fail "oversized prompt (60K chars) returns silent success" "Got: $output"
    fi
}
test_oversized_prompt

# Test 3: Base64 image data returns silent success
test_base64_prompt() {
    local b64_data
    b64_data=$(generate_base64_block 2000)
    local input
    input=$(jq -n --arg p "$b64_data" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "base64 image data (2KB) returns silent success"
    else
        log_fail "base64 image data (2KB) returns silent success" "Got: $output"
    fi
}
test_base64_prompt

# Test 4: Data URI prompt returns silent success
test_data_uri_prompt() {
    local b64_block
    b64_block=$(generate_base64_block 2000)
    local data_uri="data:image/png;base64,${b64_block}"
    local input
    input=$(jq -n --arg p "$data_uri" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "data:image/png URI returns silent success"
    else
        log_fail "data:image/png URI returns silent success" "Got: $output"
    fi
}
test_data_uri_prompt

# Test 5: Short base64 (under 500 chars) is NOT blocked (could be normal text)
test_short_base64_not_blocked() {
    local short_b64
    short_b64=$(generate_base64_block 200)
    local input
    input=$(jq -n --arg p "$short_b64" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    # Should NOT be blocked â€” short base64 could be normal text
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "short base64 (200 chars) is not blocked"
    else
        log_fail "short base64 (200 chars) is not blocked" "Got: $output"
    fi
}
test_short_base64_not_blocked

# Test 6: Prompt with non-printable chars (binary data) returns silent success
test_binary_prompt() {
    # Create a prompt that's >30% non-printable (simulate binary)
    # Use a mix of printable and non-printable chars
    local binary_prompt
    binary_prompt=$(python3 -c "
import sys, json
# 70% non-printable (null bytes), 30% printable
data = '\\x00' * 700 + 'a' * 300 + '\\x00' * 500
print(data)
" 2>/dev/null || echo "")
    if [[ -z "$binary_prompt" ]]; then
        log_pass "binary prompt detection (skipped - python3 unavailable)"
        return
    fi
    local input
    input=$(jq -n --arg p "$binary_prompt" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "binary (non-printable) prompt returns silent success"
    else
        log_fail "binary (non-printable) prompt returns silent success" "Got: $output"
    fi
}
test_binary_prompt

# ============================================================================
# Layer 3: capture-user-intent prompt guard tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 3: capture-user-intent prompt guards${NC}"
echo ""

# Test 7: Normal prompt works (capture-user-intent is silent, so always suppressOutput)
test_intent_normal() {
    local input='{"prompt":"lets use PostgreSQL because it is the most loved database","tool_name":"","session_id":"test","tool_input":{}}'
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent processes normal prompt silently"
    else
        log_fail "capture-user-intent processes normal prompt silently" "Got: $output"
    fi
}
test_intent_normal

# Test 8: Oversized prompt skipped
test_intent_oversized() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input" 10)
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips oversized prompt (60K)"
    else
        log_fail "capture-user-intent skips oversized prompt (60K)" "Got: $output"
    fi
}
test_intent_oversized

# Test 9: Base64 data skipped
test_intent_base64() {
    local b64_data
    b64_data=$(generate_base64_block 2000)
    local input
    input=$(jq -n --arg p "$b64_data" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips base64 data"
    else
        log_fail "capture-user-intent skips base64 data" "Got: $output"
    fi
}
test_intent_base64

# Test 10: Data URI skipped
test_intent_data_uri() {
    local b64_block
    b64_block=$(generate_base64_block 2000)
    local data_uri="data:image/png;base64,${b64_block}"
    local input
    input=$(jq -n --arg p "$data_uri" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips data URI"
    else
        log_fail "capture-user-intent skips data URI" "Got: $output"
    fi
}
test_intent_data_uri

# ============================================================================
# Layer 1: run-hook.mjs stdin cap tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 1: run-hook.mjs stdin size cap${NC}"
echo ""

# Test 11: Verify MAX_STDIN_BYTES constant exists in run-hook.mjs
test_stdin_cap_exists() {
    if grep -q "MAX_STDIN_BYTES" "$RUN_HOOK"; then
        log_pass "MAX_STDIN_BYTES constant defined in run-hook.mjs"
    else
        log_fail "MAX_STDIN_BYTES constant defined in run-hook.mjs" "Constant not found"
    fi
}
test_stdin_cap_exists

# Test 12: Verify stdin cap triggers process.stdin.destroy()
test_stdin_destroy_on_cap() {
    if grep -q "process.stdin.destroy" "$RUN_HOOK"; then
        log_pass "stdin.destroy() called when cap exceeded"
    else
        log_fail "stdin.destroy() called when cap exceeded" "Pattern not found"
    fi
}
test_stdin_destroy_on_cap

# Test 13: Verify incremental byte counter (not recalculating full input each chunk)
test_byte_length_check() {
    if grep -q "inputBytes" "$RUN_HOOK" && grep -q "Buffer.byteLength" "$RUN_HOOK"; then
        log_pass "uses incremental byte counter for accurate size check"
    else
        log_fail "uses incremental byte counter for accurate size check" "Pattern not found"
    fi
}
test_byte_length_check

# ============================================================================
# Source code guard verification
# ============================================================================

echo ""
echo -e "  ${CYAN}Source code guard verification${NC}"
echo ""

# Test 14: unified-dispatcher imports MAX_PROMPT_LENGTH from shared lib
test_dispatcher_has_max_length() {
    if grep -q "MAX_PROMPT_LENGTH" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "unified-dispatcher uses MAX_PROMPT_LENGTH"
    else
        log_fail "unified-dispatcher uses MAX_PROMPT_LENGTH" "Constant not found"
    fi
}
test_dispatcher_has_max_length

# Test 15: unified-dispatcher imports isImageOrBinaryPrompt from shared lib
test_dispatcher_has_image_detect() {
    if grep -q "isImageOrBinaryPrompt" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "unified-dispatcher uses isImageOrBinaryPrompt()"
    else
        log_fail "unified-dispatcher uses isImageOrBinaryPrompt()" "Function not found"
    fi
}
test_dispatcher_has_image_detect

# Test 16: capture-user-intent imports MAX_PROMPT_LENGTH from shared lib
test_intent_has_max_length() {
    if grep -q "MAX_PROMPT_LENGTH" "$PROJECT_ROOT/src/hooks/src/prompt/capture-user-intent.ts"; then
        log_pass "capture-user-intent uses MAX_PROMPT_LENGTH"
    else
        log_fail "capture-user-intent uses MAX_PROMPT_LENGTH" "Constant not found"
    fi
}
test_intent_has_max_length

# Test 17: capture-user-intent imports isImageOrBinaryPrompt from shared lib
test_intent_has_image_detect() {
    if grep -q "isImageOrBinaryPrompt" "$PROJECT_ROOT/src/hooks/src/prompt/capture-user-intent.ts"; then
        log_pass "capture-user-intent uses isImageOrBinaryPrompt()"
    else
        log_fail "capture-user-intent uses isImageOrBinaryPrompt()" "Function not found"
    fi
}
test_intent_has_image_detect

# Test 18: shared lib defines isImageOrBinaryPrompt with data URI check
test_image_detect_checks_data_uri() {
    if grep -q 'data:image' "$PROJECT_ROOT/src/hooks/src/lib/prompt-guards.ts"; then
        log_pass "isImageOrBinaryPrompt checks data:image/ URI"
    else
        log_fail "isImageOrBinaryPrompt checks data:image/ URI" "Pattern not found"
    fi
}
test_image_detect_checks_data_uri

# Test 19: shared lib checks base64 blocks
test_image_detect_checks_base64() {
    if grep -q 'A-Za-z0-9+/=' "$PROJECT_ROOT/src/hooks/src/lib/prompt-guards.ts"; then
        log_pass "isImageOrBinaryPrompt checks base64 character blocks"
    else
        log_fail "isImageOrBinaryPrompt checks base64 character blocks" "Pattern not found"
    fi
}
test_image_detect_checks_base64

# Test 20: shared lib checks non-printable ratio
test_image_detect_checks_nontext() {
    if grep -q 'nonText' "$PROJECT_ROOT/src/hooks/src/lib/prompt-guards.ts"; then
        log_pass "isImageOrBinaryPrompt checks non-text content ratio"
    else
        log_fail "isImageOrBinaryPrompt checks non-text content ratio" "Pattern not found"
    fi
}
test_image_detect_checks_nontext

# ============================================================================
# Performance regression test
# ============================================================================

echo ""
echo -e "  ${CYAN}Performance: oversized prompt latency${NC}"
echo ""

# Test 21: Oversized prompt completes in under 500ms
test_oversized_prompt_latency() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local start_ms end_ms elapsed_ms
    start_ms=$(python3 -c "import time; print(int(time.time()*1000))")
    run_hook_with_input "prompt/unified-dispatcher" "$input" 5 >/dev/null
    end_ms=$(python3 -c "import time; print(int(time.time()*1000))")
    elapsed_ms=$((end_ms - start_ms))
    if [[ "$elapsed_ms" -lt 500 ]]; then
        log_pass "oversized prompt completes in ${elapsed_ms}ms (< 500ms)"
    else
        log_fail "oversized prompt completes in ${elapsed_ms}ms (< 500ms)" "Took ${elapsed_ms}ms â€” guard may not be working"
    fi
}
test_oversized_prompt_latency

# ============================================================================
# Edge case tests (Issue #620 PR improvements)
# ============================================================================

echo ""
echo -e "  ${CYAN}Edge Cases: additional boundary tests${NC}"
echo ""

# Test 22: Mixed base64+text should block (base64 block >1KB embedded in text)
test_mixed_base64_text() {
    local b64_block
    b64_block=$(generate_base64_block 2000)
    local mixed_prompt="implement auth with ${b64_block} using JWT"
    local input
    input=$(jq -n --arg p "$mixed_prompt" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "mixed base64+text (2KB base64 embedded) returns silent success"
    else
        log_fail "mixed base64+text (2KB base64 embedded) returns silent success" "Got: $output"
    fi
}
test_mixed_base64_text

# Test 23: Exactly 50,000 chars â€” boundary test (> not >=, should process)
test_exact_boundary() {
    local boundary_text
    boundary_text=$(generate_string 50000)
    local input
    input=$(jq -n --arg p "$boundary_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input" 10)
    # Exactly 50K should NOT be blocked (guard is > not >=)
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "exactly 50,000 chars processes normally (boundary: > not >=)"
    else
        log_fail "exactly 50,000 chars processes normally (boundary: > not >=)" "Got: $output"
    fi
}
test_exact_boundary

# Test 24: Unicode/emoji-heavy prompt should NOT trigger binary detection
test_unicode_emoji() {
    # Build a prompt with lots of 4-byte UTF-8 emoji â€” should be treated as text
    local emoji_prompt
    emoji_prompt=$(python3 -c "print('Check this out ' + 'ğŸ‰ğŸš€ğŸ’¡ğŸ”¥âœ¨' * 100 + ' and implement it')" 2>/dev/null || echo "")
    if [[ -z "$emoji_prompt" ]]; then
        log_pass "unicode/emoji prompt (skipped â€” python3 unavailable)"
        return
    fi
    local input
    input=$(jq -n --arg p "$emoji_prompt" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    # Emoji is valid text â€” should NOT be blocked
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "unicode/emoji-heavy prompt is not blocked"
    else
        log_fail "unicode/emoji-heavy prompt is not blocked" "Got: $output"
    fi
}
test_unicode_emoji

# Test 25: Malformed data URI (no slash) should NOT trigger data URI check
test_malformed_data_uri() {
    local b64_block
    b64_block=$(generate_base64_block 200)
    local malformed="data:imagepng;base64,${b64_block}"
    local input
    input=$(jq -n --arg p "$malformed" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    # Malformed data URI (no slash) should NOT match ^data:image/
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "malformed data URI (no slash) is not blocked by data URI check"
    else
        log_fail "malformed data URI (no slash) is not blocked by data URI check" "Got: $output"
    fi
}
test_malformed_data_uri

# Test 26: Base64 at position 5001+ is NOT detected (validates .slice(0,5000) boundary)
test_base64_beyond_slice() {
    local prefix
    prefix=$(generate_string 5100 "x")
    local b64_tail
    b64_tail=$(generate_base64_block 2000)
    local prompt_text="${prefix}${b64_tail}"
    local input
    input=$(jq -n --arg p "$prompt_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input" 10)
    # Base64 starts at position 5100, beyond the .slice(0, 5000) â€” should NOT be detected
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "base64 beyond .slice(0,5000) boundary is not detected"
    else
        log_fail "base64 beyond .slice(0,5000) boundary is not detected" "Got: $output"
    fi
}
test_base64_beyond_slice

# ============================================================================
# Shared lib verification
# ============================================================================

echo ""
echo -e "  ${CYAN}Shared lib: prompt-guards.ts${NC}"
echo ""

# Test 27: prompt-guards.ts exists and exports both guard functions
test_shared_lib_exists() {
    local lib_path="$PROJECT_ROOT/src/hooks/src/lib/prompt-guards.ts"
    if [[ -f "$lib_path" ]] && grep -q "export function isImageOrBinaryPrompt" "$lib_path" && grep -q "export const MAX_PROMPT_LENGTH" "$lib_path"; then
        log_pass "prompt-guards.ts exports isImageOrBinaryPrompt + MAX_PROMPT_LENGTH"
    else
        log_fail "prompt-guards.ts exports isImageOrBinaryPrompt + MAX_PROMPT_LENGTH" "File or exports not found"
    fi
}
test_shared_lib_exists

# Test 28: unified-dispatcher imports from shared lib (no local definition)
test_dispatcher_uses_shared_lib() {
    local file="$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"
    if grep -q "from '../lib/prompt-guards" "$file" && ! grep -q "function isImageOrBinaryPrompt" "$file"; then
        log_pass "unified-dispatcher imports from prompt-guards (no local dupe)"
    else
        log_fail "unified-dispatcher imports from prompt-guards (no local dupe)" "Still has local definition"
    fi
}
test_dispatcher_uses_shared_lib

# Test 29: capture-user-intent imports from shared lib (no local definition)
test_intent_uses_shared_lib() {
    local file="$PROJECT_ROOT/src/hooks/src/prompt/capture-user-intent.ts"
    if grep -q "from '../lib/prompt-guards" "$file" && ! grep -q "function isImageOrBinaryPrompt" "$file"; then
        log_pass "capture-user-intent imports from prompt-guards (no local dupe)"
    else
        log_fail "capture-user-intent imports from prompt-guards (no local dupe)" "Still has local definition"
    fi
}
test_intent_uses_shared_lib

# ============================================================================
# SUMMARY
# ============================================================================

echo ""
echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
echo -e "  Total: $((TESTS_PASSED + TESTS_FAILED))  |  Passed: ${GREEN}${TESTS_PASSED}${NC}  |  Failed: ${RED}${TESTS_FAILED}${NC}"
echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"

if [[ $TESTS_FAILED -gt 0 ]]; then
    echo -e "  ${RED}FAIL${NC}: Image paste guard tests failed"
    exit 1
else
    echo -e "  ${GREEN}ALL TESTS PASSED!${NC}"
    exit 0
fi
