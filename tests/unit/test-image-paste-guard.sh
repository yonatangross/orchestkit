#!/bin/bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-15

# ============================================================================
# Image Paste Guard Tests
# Issue #620: Image paste kills context window
# ============================================================================
# Behavioral tests for the 3-layer defense against oversized/binary prompts:
#   Layer 1: run-hook.mjs MAX_STDIN_BYTES (512KB stdin cap)
#   Layer 2: unified-dispatcher MAX_PROMPT_LENGTH + isImageOrBinaryPrompt()
#   Layer 3: capture-user-intent MAX_PROMPT_LENGTH + isImageOrBinaryPrompt()
#
# Tests verify that hooks:
#   1. Return silent success for oversized prompts
#   2. Return silent success for base64 image data
#   3. Return silent success for data URI prompts
#   4. Still work normally for regular text prompts
#   5. Handle edge cases (just under limit, just over limit)
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

RUN_HOOK="$PROJECT_ROOT/src/hooks/bin/run-hook.mjs"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0

log_pass() {
    echo -e "  ${GREEN}○${NC} $1... ${GREEN}PASS${NC}"
    TESTS_PASSED=$((TESTS_PASSED + 1))
}

log_fail() {
    echo -e "  ${RED}✗${NC} $1... ${RED}FAIL${NC}"
    echo -e "    ${RED}$2${NC}"
    TESTS_FAILED=$((TESTS_FAILED + 1))
}

# Run a hook with given JSON input and return stdout
run_hook_with_input() {
    local hook_name="$1"
    local json_input="$2"
    local timeout_sec="${3:-5}"

    echo "$json_input" | timeout "${timeout_sec}" node "$RUN_HOOK" "$hook_name" 2>/dev/null || true
}

# Check if output indicates silent success (continue=true, suppressOutput=true)
is_silent_success() {
    local output="$1"
    if [[ -z "$output" ]]; then
        return 1
    fi
    local cont suppress
    cont=$(echo "$output" | jq -r '.continue' 2>/dev/null)
    suppress=$(echo "$output" | jq -r '.suppressOutput' 2>/dev/null)
    [[ "$cont" == "true" && "$suppress" == "true" ]]
}

# Check if output has additionalContext (hook actually processed the prompt)
has_additional_context() {
    local output="$1"
    local ctx
    ctx=$(echo "$output" | jq -r '.hookSpecificOutput.additionalContext // empty' 2>/dev/null)
    [[ -n "$ctx" ]]
}

# Generate a string of N characters
generate_string() {
    local length="$1"
    local char="${2:-a}"
    printf '%0.s'"$char" $(seq 1 "$length")
}

# Generate fake base64 content (continuous A-Za-z0-9+/= chars)
generate_base64_block() {
    local length="$1"
    # Use a repeating base64-like pattern
    local pattern="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    local result=""
    while [[ ${#result} -lt "$length" ]]; do
        result="${result}${pattern}"
    done
    echo "${result:0:$length}"
}

echo ""
echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"
echo -e "${CYAN}  Image Paste Guard Tests (Issue #620)${NC}"
echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"

# Check prerequisites
if [[ ! -f "$RUN_HOOK" ]]; then
    echo -e "${RED}SKIP: run-hook.mjs not found at $RUN_HOOK${NC}"
    exit 0
fi

if ! command -v timeout >/dev/null 2>&1 && ! command -v gtimeout >/dev/null 2>&1; then
    # macOS without coreutils — redefine timeout as direct exec
    timeout() { shift; "$@"; }
fi

# Redefine timeout to use gtimeout on macOS if available
if ! command -v timeout >/dev/null 2>&1 && command -v gtimeout >/dev/null 2>&1; then
    timeout() { gtimeout "$@"; }
fi

# ============================================================================
# Layer 2: unified-dispatcher prompt guard tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 2: unified-dispatcher prompt guards${NC}"
echo ""

# Test 1: Normal text prompt processes normally
test_normal_prompt() {
    local input='{"prompt":"implement a new login feature using JWT","tool_name":"","session_id":"test","tool_input":{}}'
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "normal text prompt processes without error"
    else
        log_fail "normal text prompt processes without error" "Got: $output"
    fi
}
test_normal_prompt

# Test 2: Oversized prompt (>50K chars) returns silent success
test_oversized_prompt() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input" 10)
    if is_silent_success "$output"; then
        log_pass "oversized prompt (60K chars) returns silent success"
    else
        log_fail "oversized prompt (60K chars) returns silent success" "Got: $output"
    fi
}
test_oversized_prompt

# Test 3: Base64 image data returns silent success
test_base64_prompt() {
    local b64_data
    b64_data=$(generate_base64_block 2000)
    local input
    input=$(jq -n --arg p "$b64_data" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "base64 image data (2KB) returns silent success"
    else
        log_fail "base64 image data (2KB) returns silent success" "Got: $output"
    fi
}
test_base64_prompt

# Test 4: Data URI prompt returns silent success
test_data_uri_prompt() {
    local b64_block
    b64_block=$(generate_base64_block 2000)
    local data_uri="data:image/png;base64,${b64_block}"
    local input
    input=$(jq -n --arg p "$data_uri" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "data:image/png URI returns silent success"
    else
        log_fail "data:image/png URI returns silent success" "Got: $output"
    fi
}
test_data_uri_prompt

# Test 5: Short base64 (under 500 chars) is NOT blocked (could be normal text)
test_short_base64_not_blocked() {
    local short_b64
    short_b64=$(generate_base64_block 200)
    local input
    input=$(jq -n --arg p "$short_b64" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    # Should NOT be blocked — short base64 could be normal text
    if [[ -n "$output" ]] && echo "$output" | jq -e '.continue' >/dev/null 2>&1; then
        log_pass "short base64 (200 chars) is not blocked"
    else
        log_fail "short base64 (200 chars) is not blocked" "Got: $output"
    fi
}
test_short_base64_not_blocked

# Test 6: Prompt with non-printable chars (binary data) returns silent success
test_binary_prompt() {
    # Create a prompt that's >30% non-printable (simulate binary)
    # Use a mix of printable and non-printable chars
    local binary_prompt
    binary_prompt=$(python3 -c "
import sys, json
# 70% non-printable (null bytes), 30% printable
data = '\\x00' * 700 + 'a' * 300 + '\\x00' * 500
print(data)
" 2>/dev/null || echo "")
    if [[ -z "$binary_prompt" ]]; then
        log_pass "binary prompt detection (skipped - python3 unavailable)"
        return
    fi
    local input
    input=$(jq -n --arg p "$binary_prompt" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/unified-dispatcher" "$input")
    if is_silent_success "$output"; then
        log_pass "binary (non-printable) prompt returns silent success"
    else
        log_fail "binary (non-printable) prompt returns silent success" "Got: $output"
    fi
}
test_binary_prompt

# ============================================================================
# Layer 3: capture-user-intent prompt guard tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 3: capture-user-intent prompt guards${NC}"
echo ""

# Test 7: Normal prompt works (capture-user-intent is silent, so always suppressOutput)
test_intent_normal() {
    local input='{"prompt":"lets use PostgreSQL because it is the most loved database","tool_name":"","session_id":"test","tool_input":{}}'
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent processes normal prompt silently"
    else
        log_fail "capture-user-intent processes normal prompt silently" "Got: $output"
    fi
}
test_intent_normal

# Test 8: Oversized prompt skipped
test_intent_oversized() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input" 10)
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips oversized prompt (60K)"
    else
        log_fail "capture-user-intent skips oversized prompt (60K)" "Got: $output"
    fi
}
test_intent_oversized

# Test 9: Base64 data skipped
test_intent_base64() {
    local b64_data
    b64_data=$(generate_base64_block 2000)
    local input
    input=$(jq -n --arg p "$b64_data" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips base64 data"
    else
        log_fail "capture-user-intent skips base64 data" "Got: $output"
    fi
}
test_intent_base64

# Test 10: Data URI skipped
test_intent_data_uri() {
    local b64_block
    b64_block=$(generate_base64_block 2000)
    local data_uri="data:image/png;base64,${b64_block}"
    local input
    input=$(jq -n --arg p "$data_uri" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local output
    output=$(run_hook_with_input "prompt/capture-user-intent" "$input")
    if is_silent_success "$output"; then
        log_pass "capture-user-intent skips data URI"
    else
        log_fail "capture-user-intent skips data URI" "Got: $output"
    fi
}
test_intent_data_uri

# ============================================================================
# Layer 1: run-hook.mjs stdin cap tests
# ============================================================================

echo ""
echo -e "  ${CYAN}Layer 1: run-hook.mjs stdin size cap${NC}"
echo ""

# Test 11: Verify MAX_STDIN_BYTES constant exists in run-hook.mjs
test_stdin_cap_exists() {
    if grep -q "MAX_STDIN_BYTES" "$RUN_HOOK"; then
        log_pass "MAX_STDIN_BYTES constant defined in run-hook.mjs"
    else
        log_fail "MAX_STDIN_BYTES constant defined in run-hook.mjs" "Constant not found"
    fi
}
test_stdin_cap_exists

# Test 12: Verify stdin cap triggers process.stdin.destroy()
test_stdin_destroy_on_cap() {
    if grep -q "process.stdin.destroy" "$RUN_HOOK"; then
        log_pass "stdin.destroy() called when cap exceeded"
    else
        log_fail "stdin.destroy() called when cap exceeded" "Pattern not found"
    fi
}
test_stdin_destroy_on_cap

# Test 13: Verify Buffer.byteLength check (not just string length)
test_byte_length_check() {
    if grep -q "Buffer.byteLength" "$RUN_HOOK"; then
        log_pass "uses Buffer.byteLength for accurate size check"
    else
        log_fail "uses Buffer.byteLength for accurate size check" "Pattern not found"
    fi
}
test_byte_length_check

# ============================================================================
# Source code guard verification
# ============================================================================

echo ""
echo -e "  ${CYAN}Source code guard verification${NC}"
echo ""

# Test 14: unified-dispatcher has MAX_PROMPT_LENGTH
test_dispatcher_has_max_length() {
    if grep -q "MAX_PROMPT_LENGTH" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "unified-dispatcher defines MAX_PROMPT_LENGTH"
    else
        log_fail "unified-dispatcher defines MAX_PROMPT_LENGTH" "Constant not found"
    fi
}
test_dispatcher_has_max_length

# Test 15: unified-dispatcher has isImageOrBinaryPrompt
test_dispatcher_has_image_detect() {
    if grep -q "isImageOrBinaryPrompt" "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "unified-dispatcher has isImageOrBinaryPrompt()"
    else
        log_fail "unified-dispatcher has isImageOrBinaryPrompt()" "Function not found"
    fi
}
test_dispatcher_has_image_detect

# Test 16: capture-user-intent has MAX_PROMPT_LENGTH
test_intent_has_max_length() {
    if grep -q "MAX_PROMPT_LENGTH" "$PROJECT_ROOT/src/hooks/src/prompt/capture-user-intent.ts"; then
        log_pass "capture-user-intent defines MAX_PROMPT_LENGTH"
    else
        log_fail "capture-user-intent defines MAX_PROMPT_LENGTH" "Constant not found"
    fi
}
test_intent_has_max_length

# Test 17: capture-user-intent has isImageOrBinaryPrompt
test_intent_has_image_detect() {
    if grep -q "isImageOrBinaryPrompt" "$PROJECT_ROOT/src/hooks/src/prompt/capture-user-intent.ts"; then
        log_pass "capture-user-intent has isImageOrBinaryPrompt()"
    else
        log_fail "capture-user-intent has isImageOrBinaryPrompt()" "Function not found"
    fi
}
test_intent_has_image_detect

# Test 18: isImageOrBinaryPrompt checks data URI pattern
test_image_detect_checks_data_uri() {
    if grep -q 'data:image' "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "isImageOrBinaryPrompt checks data:image/ URI"
    else
        log_fail "isImageOrBinaryPrompt checks data:image/ URI" "Pattern not found"
    fi
}
test_image_detect_checks_data_uri

# Test 19: isImageOrBinaryPrompt checks base64 blocks
test_image_detect_checks_base64() {
    if grep -q 'A-Za-z0-9+/=' "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "isImageOrBinaryPrompt checks base64 character blocks"
    else
        log_fail "isImageOrBinaryPrompt checks base64 character blocks" "Pattern not found"
    fi
}
test_image_detect_checks_base64

# Test 20: isImageOrBinaryPrompt checks non-printable ratio
test_image_detect_checks_nontext() {
    if grep -q 'nonText' "$PROJECT_ROOT/src/hooks/src/prompt/unified-dispatcher.ts"; then
        log_pass "isImageOrBinaryPrompt checks non-text content ratio"
    else
        log_fail "isImageOrBinaryPrompt checks non-text content ratio" "Pattern not found"
    fi
}
test_image_detect_checks_nontext

# ============================================================================
# Performance regression test
# ============================================================================

echo ""
echo -e "  ${CYAN}Performance: oversized prompt latency${NC}"
echo ""

# Test 21: Oversized prompt completes in under 2 seconds
test_oversized_prompt_latency() {
    local big_text
    big_text=$(generate_string 60000)
    local input
    input=$(jq -n --arg p "$big_text" '{"prompt":$p,"tool_name":"","session_id":"test","tool_input":{}}')
    local start_ms end_ms elapsed_ms
    start_ms=$(python3 -c "import time; print(int(time.time()*1000))")
    run_hook_with_input "prompt/unified-dispatcher" "$input" 5 >/dev/null
    end_ms=$(python3 -c "import time; print(int(time.time()*1000))")
    elapsed_ms=$((end_ms - start_ms))
    if [[ "$elapsed_ms" -lt 2000 ]]; then
        log_pass "oversized prompt completes in ${elapsed_ms}ms (< 2000ms)"
    else
        log_fail "oversized prompt completes in ${elapsed_ms}ms (< 2000ms)" "Took ${elapsed_ms}ms — guard may not be working"
    fi
}
test_oversized_prompt_latency

# ============================================================================
# SUMMARY
# ============================================================================

echo ""
echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"
echo -e "  Total: $((TESTS_PASSED + TESTS_FAILED))  |  Passed: ${GREEN}${TESTS_PASSED}${NC}  |  Failed: ${RED}${TESTS_FAILED}${NC}"
echo -e "${CYAN}════════════════════════════════════════════════════════════════${NC}"

if [[ $TESTS_FAILED -gt 0 ]]; then
    echo -e "  ${RED}FAIL${NC}: Image paste guard tests failed"
    exit 1
else
    echo -e "  ${GREEN}ALL TESTS PASSED!${NC}"
    exit 0
fi
