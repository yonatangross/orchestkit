#!/bin/bash
# Generated by OrchestKit Claude Plugin
# Created: 2026-02-09

# ============================================================================
# Pre-push hook unit tests
# ============================================================================
# Validates key functions and patterns used in bin/git-hooks/pre-push
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0

log_pass() {
    echo -e "  ${GREEN}✓${NC} $1"
    TESTS_PASSED=$((TESTS_PASSED + 1))
}

log_fail() {
    echo -e "  ${RED}✗${NC} $1"
    TESTS_FAILED=$((TESTS_FAILED + 1))
}

log_section() {
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "  $1"
    echo "═══════════════════════════════════════════════════════════════"
}

# Source just the run_with_timeout function from the pre-push hook.
# We extract it to avoid executing the rest of the hook (which needs
# git context, stdin, etc.).
_setup_run_with_timeout() {
    eval "$(sed -n '/^run_with_timeout()/,/^}/p' "${PROJECT_ROOT}/bin/git-hooks/pre-push")"
}

# Test 1: run_with_timeout preserves exit codes
test_run_with_timeout_exit_codes() {
    log_section "Test 1: run_with_timeout preserves exit codes"

    _setup_run_with_timeout

    # Subtest: exit code 0 (success)
    local rc=0
    run_with_timeout 5 true || rc=$?
    if [[ $rc -eq 0 ]]; then
        log_pass "run_with_timeout 5 true returns 0"
    else
        log_fail "run_with_timeout 5 true returned $rc (expected 0)"
    fi

    # Subtest: exit code 1 (failure)
    rc=0
    run_with_timeout 5 false || rc=$?
    if [[ $rc -eq 1 ]]; then
        log_pass "run_with_timeout 5 false returns 1"
    else
        log_fail "run_with_timeout 5 false returned $rc (expected 1)"
    fi

    # Subtest: arbitrary exit code 42
    rc=0
    run_with_timeout 5 bash -c "exit 42" || rc=$?
    if [[ $rc -eq 42 ]]; then
        log_pass "run_with_timeout 5 bash -c 'exit 42' returns 42"
    else
        log_fail "run_with_timeout 5 bash -c 'exit 42' returned $rc (expected 42)"
    fi
}

# Test 2: CHANGELOG variable capture pattern
test_changelog_variable_capture() {
    log_section "Test 2: CHANGELOG variable capture pattern"

    # Subtest: grep finds CHANGELOG.md in captured output
    local _VAR rc
    _VAR=$(echo -e "file1\nCHANGELOG.md\nfile2" || true)
    rc=0
    echo "$_VAR" | grep -q "CHANGELOG.md" || rc=$?
    if [[ $rc -eq 0 ]]; then
        log_pass "Variable capture + grep finds CHANGELOG.md"
    else
        log_fail "Variable capture + grep failed to find CHANGELOG.md (rc=$rc)"
    fi

    # Subtest: grep correctly fails when CHANGELOG.md is absent
    _VAR=$(echo -e "file1\nfile2" || true)
    rc=0
    echo "$_VAR" | grep -q "CHANGELOG.md" || rc=$?
    if [[ $rc -eq 1 ]]; then
        log_pass "Variable capture + grep correctly returns 1 when CHANGELOG.md absent"
    else
        log_fail "Variable capture + grep returned $rc when CHANGELOG.md absent (expected 1)"
    fi
}

# Test 3: run_with_timeout handles arguments with spaces
test_run_with_timeout_spaces() {
    log_section "Test 3: run_with_timeout handles arguments with spaces"

    _setup_run_with_timeout

    local output rc=0
    output=$(run_with_timeout 5 bash -c "echo 'hello world'" 2>&1) || rc=$?
    if [[ $rc -eq 0 && "$output" == "hello world" ]]; then
        log_pass "run_with_timeout handles arguments with spaces"
    else
        log_fail "run_with_timeout with spaces: rc=$rc, output='$output' (expected rc=0, output='hello world')"
    fi
}

# Main
main() {
    echo "╔═══════════════════════════════════════════════════════════════╗"
    echo "║            Pre-push Hook Unit Tests                          ║"
    echo "╚═══════════════════════════════════════════════════════════════╝"

    test_run_with_timeout_exit_codes
    test_changelog_variable_capture
    test_run_with_timeout_spaces

    # Summary
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "                        TEST SUMMARY"
    echo "═══════════════════════════════════════════════════════════════"
    echo -e "  Passed:  ${GREEN}${TESTS_PASSED}${NC}"
    echo -e "  Failed:  ${RED}${TESTS_FAILED}${NC}"
    echo ""

    if [[ $TESTS_FAILED -gt 0 ]]; then
        echo -e "${RED}FAIL${NC}: Some tests failed"
        exit 1
    else
        echo -e "${GREEN}PASS${NC}: All tests passed"
        exit 0
    fi
}

main "$@"
