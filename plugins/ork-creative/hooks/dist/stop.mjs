// OrchestKit Hooks - stop bundle
// Generated: 2026-02-19T11:35:39.926Z

var Nt=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(n,e)=>(typeof require<"u"?require:n)[e]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});function bo(t){return typeof t.command=="string"}function vo(t){return typeof t.file_path=="string"&&typeof t.content=="string"}function xo(t){return typeof t.file_path=="string"&&typeof t.old_string=="string"&&typeof t.new_string=="string"}function wo(t){return typeof t.file_path=="string"&&t.content===void 0}import{existsSync as Vt,statSync as Fn,renameSync as Nn,mkdirSync as Un,readSync as Wn}from"node:fs";import{appendFileSync as hn,mkdirSync as yn}from"node:fs";import{dirname as _n}from"node:path";var J=[],pt=!1,Ut=!1;function h(t,n){J.push({filePath:t,content:n}),kn()}function lt(){if(pt||J.length===0)return;pt=!0;let t=new Map;for(let n of J){let e=t.get(n.filePath);e?e.push(n.content):t.set(n.filePath,[n.content])}for(let[n,e]of t)try{yn(_n(n),{recursive:!0}),hn(n,e.join(""))}catch{}J.length=0,pt=!1}function kn(){Ut||(Ut=!0,process.on("exit",lt),process.on("SIGTERM",()=>{lt(),process.exit(0)}),process.on("SIGINT",()=>{lt(),process.exit(0)}))}import{execSync as Mn}from"node:child_process";import Wt from"node:os";import $ from"node:path";function dt(){return process.env.HOME||process.env.USERPROFILE||Wt.homedir()}function gt(){return Wt.tmpdir()}function ft(){return process.env.CLAUDE_PROJECT_DIR||"."}function Mt(){return process.env.CLAUDE_PLUGIN_ROOT||process.env.CLAUDE_PROJECT_DIR||"."}function Lt(){return process.env.CLAUDE_PLUGIN_ROOT?$.join(dt(),".claude","logs","ork"):$.join(ft(),".claude","logs")}function Bt(){return process.env.CLAUDE_METRICS_FILE||$.join(gt(),"claude-session-metrics.json")}function Jt(t){return $.join(gt(),`claude-session-${t}`)}function zt(){return $.join(gt(),"claude-active-todos.json")}var Po=$.join,Ao=$.sep;import{execSync as Sn}from"node:child_process";import{createHash as bn}from"node:crypto";import{existsSync as Gt,readFileSync as vn,writeFileSync as xn,mkdirSync as wn}from"node:fs";import{join as mt,basename as $n}from"node:path";var In=20,Rn=15,Dn=/[^a-z0-9-]/g;function Cn(t){let n=t||process.env.CLAUDE_PROJECT_DIR||process.cwd(),e=$n(n);return qt(e,In)}function Tn(t){if(process.env.ORCHESTKIT_SESSION_BRANCH)return process.env.ORCHESTKIT_SESSION_BRANCH;let n=t||process.env.CLAUDE_PROJECT_DIR||process.cwd();try{let e=Sn("git branch --show-current",{cwd:n,encoding:"utf8",timeout:2e3,stdio:["pipe","pipe","pipe"]}).trim(),s=qt(e||"detached",Rn);return process.env.ORCHESTKIT_SESSION_BRANCH=s,s}catch{return"nobranch"}}function Pn(t){let n=t||new Date,e=String(n.getMonth()+1).padStart(2,"0"),s=String(n.getDate()).padStart(2,"0");return`${e}${s}`}function An(t){let n=t||new Date,e=String(n.getHours()).padStart(2,"0"),s=String(n.getMinutes()).padStart(2,"0");return`${e}${s}`}function On(){let t=`${process.pid}-${Date.now()}-${Math.random()}`;return bn("sha256").update(t).digest("hex").slice(0,4)}function qt(t,n){return t.toLowerCase().replace(Dn,"-").replace(/-+/g,"-").replace(/^-|-$/g,"").slice(0,n)}function jn(t,n){let e=Cn(t),s=Tn(t),r=Pn(n),o=An(n),a=On();return`${e}-${s}-${r}-${o}-${a}`}function En(t){let n=t||process.env.CLAUDE_PROJECT_DIR||process.cwd(),e=mt(n,".instance","session-id.json");if(Gt(e))try{let s=JSON.parse(vn(e,"utf8"));if(s.session_id&&s.created_at){let r=Date.now()-new Date(s.created_at).getTime(),o=1440*60*1e3;if(r<o)return s.session_id}}catch{}}function Hn(t,n){let e=n||process.env.CLAUDE_PROJECT_DIR||process.cwd(),s=mt(e,".instance"),r=mt(s,"session-id.json");try{Gt(s)||wn(s,{recursive:!0}),xn(r,JSON.stringify({session_id:t,created_at:new Date().toISOString()},null,2))}catch{}}function Zt(t){if(process.env.CLAUDE_SESSION_ID)return process.env.CLAUDE_SESSION_ID;let n=En(t);if(n)return n;let e=jn(t);return Hn(e,t),e}function b(){return Lt()}function d(){return ft()}function Ln(){return Mt()}function Jo(){return process.env.CLAUDE_ENV_FILE?process.env.CLAUDE_ENV_FILE:`${Ln()}/.claude/.instance_env`}function f(){return Zt()}function zo(t){if(process.env.ORCHESTKIT_BRANCH)return process.env.ORCHESTKIT_BRANCH;try{let n=Mn("git branch --show-current",{cwd:t||d(),encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim();return process.env.ORCHESTKIT_BRANCH=n,n}catch{return"unknown"}}function Bn(){return process.env.ORCHESTKIT_LOG_LEVEL||"warn"}function Go(t){return t.replace(/\r\n/g,`
`)}function Jn(t){let n=["debug","info","warn","error"];return n.indexOf(t)>=n.indexOf(Bn())}function p(){return{continue:!0,suppressOutput:!0}}function qo(){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{permissionDecision:"allow"}}}function T(t){return{continue:!1,stopReason:t,hookSpecificOutput:{permissionDecision:"deny",permissionDecisionReason:t}}}function k(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PostToolUse",additionalContext:t}}}function zn(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"UserPromptSubmit",additionalContext:t}}}function Zo(t,n){let e={continue:!0,suppressOutput:!0};return t&&(e.systemMessage=t),n&&(e.hookSpecificOutput={hookEventName:"UserPromptSubmit",additionalContext:n}),e}function Vo(t,n){let e={continue:!0,hookSpecificOutput:{hookEventName:"PreToolUse",additionalContext:t,permissionDecision:"allow"}};return n?e.systemMessage=n:e.suppressOutput=!0,e}function Ko(t){return{continue:!0,systemMessage:t}}function Xo(t){return{continue:!0,systemMessage:`\u26A0 ${t}`}}function Yo(t){process.stderr.write(`\u26A0 ${t}
`),process.exit(2)}function Qo(t){return{continue:!1,stopReason:t,hookSpecificOutput:{hookEventName:"PreToolUse",permissionDecision:"deny",permissionDecisionReason:t}}}function ti(t){return{continue:!0,suppressOutput:!0,hookSpecificOutput:{hookEventName:"PreToolUse",updatedInput:t}}}var Gn=200*1024,qn=100*1024;function Kt(t,n){if(Vt(t))try{if(Fn(t).size>n){let s=`${t}.old.${Date.now()}`;Nn(t,s)}}catch{}}function Xt(t){Vt(t)||Un(t,{recursive:!0})}function i(t,n,e="debug"){if(!Jn(e))return;let s=b(),r=`${s}/hooks.log`;try{Xt(s),Kt(r,Gn);let o=new Date().toISOString().replace("T"," ").slice(0,19);h(r,`[${o}] [${e.toUpperCase()}] [${t}] ${n}
`)}catch{}}function ei(t,n,e){let s=b(),r=`${s}/permission-feedback.log`;try{Xt(s),Kt(r,qn);let o=new Date().toISOString(),a=e?.tool_name||process.env.HOOK_TOOL_NAME||"unknown",c=e?.session_id||f();h(r,`${o} | ${t} | ${n} | tool=${a} | session=${c}
`)}catch{}}function Zn(t){if(!t)return 0;let s=(t.match(/[{};()=><]/g)||[]).length/t.length>.03?2.8:3.5;return Math.ceil(t.length/s)}function ni(t,n,e,s,r){let o=Zn(t);return s&&s.isOverBudget(e)?(i(n,`Budget exhausted for ${e}, suppressing ${o}t`),p()):(r&&r.trackTokenUsage(n,e,o),zn(t))}function si(){try{let t=[],e=Buffer.allocUnsafe(256),s,r=0;for(;;)try{if(s=Wn(r,e,0,256,null),s===0)break;t.push(Buffer.from(e.subarray(0,s)))}catch{break}let o=Buffer.concat(t).toString("utf8").trim();return o?JSON.parse(o):{tool_name:"",session_id:f(),tool_input:{}}}catch{return{tool_name:"",session_id:f(),tool_input:{}}}}function ri(t,n){let e=n.replace(/^\./,"").split("."),s=t;for(let r of e){if(s==null)return;s=s[r]}return s}function oi(t){return t.replace(/\\\s*[\r\n]+/g," ").replace(/\n/g," ").replace(/\s+/g," ").trim()}function ii(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}import{existsSync as ee,readFileSync as Vn,writeFileSync as Kn,mkdirSync as Xn}from"node:fs";import{createHash as Yn}from"node:crypto";var Yt=500,ht=3,Qt=15,te=3,Qn=.9;function ne(){return`${d()}/.claude/feedback/calibration-data.json`}function ts(){let t=`${d()}/.claude/feedback`;if(!ee(t))try{Xn(t,{recursive:!0})}catch{}}function I(){let t=ne();if(ee(t))try{return JSON.parse(Vn(t,"utf8"))}catch{i("calibration-engine","Failed to load calibration data, using defaults")}return{schemaVersion:"1.0.0",createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),records:[],adjustments:[],stats:{totalDispatches:0,successRate:0,avgConfidence:0,topAgents:[]}}}function yt(t){ts();let n=ne();t.updatedAt=new Date().toISOString();try{Kn(n,JSON.stringify(t,null,2)),i("calibration-engine","Saved calibration data")}catch(e){i("calibration-engine",`Failed to save calibration data: ${e}`)}}function es(t){return Yn("sha256").update(t.toLowerCase().trim()).digest("hex").slice(0,16)}function li(t,n,e,s,r,o,a){let c=I(),u={timestamp:new Date().toISOString(),sessionId:f(),agent:n,promptHash:es(t),matchedKeywords:e,dispatchConfidence:s,outcome:r,durationMs:o,feedback:a};c.records.push(u),c.records.length>Yt&&(c.records=c.records.slice(-Yt)),ns(c,u),ss(c),yt(c),i("calibration-engine",`Recorded outcome: ${n} -> ${r} (conf: ${s})`)}function ns(t,n){let e=n.outcome==="success",s=n.outcome==="failure"||n.outcome==="rejected";if(!e&&!s)return;let r=e?te:-te;for(let o of n.matchedKeywords){let a=t.adjustments.find(c=>c.keyword===o&&c.agent===n.agent);a?(a.adjustment=Math.max(-Qt,Math.min(Qt,a.adjustment+r)),a.sampleCount++,a.lastUpdated=new Date().toISOString()):t.adjustments.push({keyword:o,agent:n.agent,adjustment:r,sampleCount:1,lastUpdated:new Date().toISOString()})}}function se(t){let n=Date.now(),e=1440*60*1e3;for(let s of t.adjustments){let r=n-new Date(s.lastUpdated).getTime();Math.floor(r/e)>7&&(s.adjustment=Math.round(s.adjustment*Qn),Math.abs(s.adjustment)<1&&(s.adjustment=0))}t.adjustments=t.adjustments.filter(s=>s.adjustment!==0)}function ss(t){let n=t.records;if(n.length===0)return;t.stats.totalDispatches=n.length;let e=n.filter(o=>o.outcome==="success").length;t.stats.successRate=e/n.length;let s=n.reduce((o,a)=>o+a.dispatchConfidence,0)/n.length;t.stats.avgConfidence=Math.round(s);let r=new Map;for(let o of n){let a=r.get(o.agent)||{count:0,success:0};a.count++,o.outcome==="success"&&a.success++,r.set(o.agent,a)}t.stats.topAgents=Array.from(r.entries()).map(([o,a])=>({agent:o,count:a.count,successRate:a.success/a.count})).sort((o,a)=>a.count-o.count).slice(0,10)}function di(){return I().adjustments.filter(n=>n.sampleCount>=ht)}function gi(t){let e=I().records.filter(r=>r.agent===t);return e.length<ht?null:e.filter(r=>r.outcome==="success").length/e.length}function fi(){return I().stats}function mi(){return I().records.length>=ht}import{basename as rs}from"node:path";function z(t){i("auto-remember-continuity","Hook triggered");let n=t.project_dir||d(),s=`Before ending this session, consider preserving important context in the knowledge graph:

1. **Session Continuity** - If there's unfinished work or next steps:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "session-${rs(n)||"project"}",
     "entityType": "Session",
     "observations": ["What was done: [...]", "Next steps: [...]"]
   }]}
   \`\`\`

2. **Important Decisions** - If architectural/design decisions were made:
   \`mcp__memory__create_entities\` with:
   \`\`\`json
   {"entities": [{
     "name": "decision-[topic]",
     "entityType": "Decision",
     "observations": ["Decided: [...]", "Rationale: [...]"]
   }]}
   \`\`\`

3. **Patterns Learned** - If something worked well or failed:
   - Use \`/remember --success "pattern that worked"\`
   - Use \`/remember --failed "pattern that caused issues"\`

Skip if this was just a quick question/answer session.`;return i("auto-remember-continuity","Outputting memory prompt for session end"),{continue:!0,suppressOutput:!0}}import{existsSync as re,mkdirSync as os,readFileSync as is,writeFileSync as oe}from"node:fs";function G(t){i("auto-save-context","Stop hook - auto-saving context (Protocol 2.0)");let e=`${t.project_dir||d()}/.claude/context/session`,s=`${e}/state.json`;try{re(e)||os(e,{recursive:!0})}catch{}let r=new Date().toISOString();try{if(re(s)){let o=is(s,"utf-8"),a=JSON.parse(o),c={$schema:a.$schema||"context://session/v1",_meta:a._meta||{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:a.session_id||null,started:a.started||null,last_activity:r,current_task:a.current_task||{description:"No active task",status:"pending"},next_steps:a.next_steps||[],blockers:a.blockers||[]};oe(s,JSON.stringify(c,null,2)),i("auto-save-context","Updated session state timestamp")}else oe(s,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always",compress:"on_threshold",description:"Session state and progress - ALWAYS loaded at END of context"},session_id:null,started:r,last_activity:r,current_task:{description:"No active task",status:"pending"},next_steps:[],blockers:[]},null,2)),i("auto-save-context","Created new session state (Protocol 2.0 compliant)")}catch(o){i("auto-save-context",`Error saving context: ${o}`)}return p()}import{existsSync as kt,mkdirSync as St,readFileSync as bt,writeFileSync as E}from"node:fs";var _t=10;function as(t){let n=`${t}/session/state.json`;if(!kt(n)){i("context-compressor","No session state to archive");return}try{let e=bt(n,"utf-8"),s=JSON.parse(e),r=s.session_id||`session-${new Date().toISOString().replace(/[:.]/g,"-")}`,o=`${t}/archive/sessions`;St(o,{recursive:!0});let a=`${o}/${r}.json`,c={...s,ended:new Date().toISOString(),archived:!0};E(a,JSON.stringify(c,null,2)),i("context-compressor",`Archived session to ${a}`),E(n,JSON.stringify({$schema:"context://session/v1",_meta:{position:"END",token_budget:500,auto_load:"always"},session_id:null,started:null,current_task:null,files_touched:[],decisions_this_session:[],blockers:[],next_steps:[],scratchpad:{notes:[]}},null,2)),i("context-compressor","Reset session state")}catch(e){i("context-compressor",`Error archiving session: ${e}`)}}function cs(t){let n=`${t}/knowledge/decisions/active.json`;if(kt(n))try{let e=bt(n,"utf-8"),s=JSON.parse(e),r=s.decisions||[];if(r.length<=_t)return;let o=`${t}/archive/decisions`;St(o,{recursive:!0});let a=new Date,c=`${o}/${a.getFullYear()}-${String(a.getMonth()+1).padStart(2,"0")}.json`,u=r.slice(0,-_t);E(c,JSON.stringify(u,null,2)),s.decisions=r.slice(-_t),E(n,JSON.stringify(s,null,2)),i("context-compressor",`Archived ${u.length} old decisions`)}catch(e){i("context-compressor",`Error compressing decisions: ${e}`)}}function us(t){let n=`${t}/session/state.json`;if(kt(n))try{let e=bt(n,"utf-8"),s=JSON.parse(e),r={sessionId:s.session_id||"unknown",compactedAt:new Date().toISOString(),keyDecisions:(s.decisions_this_session||[]).slice(-5),filesTouched:(s.files_touched||[]).slice(-20),blockers:s.blockers||[],nextSteps:s.next_steps||[]},o=`${t}/session`;St(o,{recursive:!0}),E(`${o}/compaction-manifest.json`,JSON.stringify(r,null,2)),i("context-compressor",`Wrote compaction manifest for session ${r.sessionId}`)}catch(e){i("context-compressor",`Error writing compaction manifest: ${e}`)}}function q(t){i("context-compressor","Starting end-of-session compression...");let e=`${t.project_dir||d()}/context`;return us(e),as(e),cs(e),i("context-compressor","End-of-session compression complete"),p()}import{existsSync as x,readFileSync as ps,writeFileSync as ls,mkdirSync as ds}from"node:fs";import{execSync as R}from"node:child_process";function gs(t){let n=`${t}/.claude/hooks/logs/.last-test-run`;if(!x(n))return!0;try{let e=R("git diff --name-only HEAD",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]});if(/\.(py|js|ts|go|rs)$/.test(e))return!0}catch{return!0}return i("full-test-suite","No code changes detected, skipping tests"),!1}function fs(t,n){let e=0;if(x(`${t}/pytest.ini`)||x(`${t}/pyproject.toml`)||x(`${t}/tests`)&&x(`${t}/requirements.txt`)){i("full-test-suite","Detected Python project, running pytest...");try{R("pytest --tb=short --timeout=300 -q",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{e=1}}if(x(`${t}/package.json`)){i("full-test-suite","Detected Node.js project...");try{if(JSON.parse(ps(`${t}/package.json`,"utf-8")).scripts?.test){i("full-test-suite","Running npm test...");let r="npm test -- --passWithNoTests --watchAll=false";try{R("which pnpm",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),r="pnpm test --passWithNoTests"}catch{try{R("which yarn",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),r="yarn test --passWithNoTests"}catch{}}R(r,{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}}catch{e=1}}if(x(`${t}/go.mod`)){i("full-test-suite","Detected Go project, running go test...");try{R("go test -v -timeout 5m ./...",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{e=1}}if(x(`${t}/Cargo.toml`)){i("full-test-suite","Detected Rust project, running cargo test...");try{R("cargo test",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]})}catch{e=1}}return e===0}function Z(t){i("full-test-suite","=== Full Test Suite Started ===");let n=t.project_dir||d(),e=`${n}/.claude/hooks/logs`;try{ds(e,{recursive:!0})}catch{}let s=`${e}/full-test-suite.log`;if(!gs(n))return p();if(fs(n,s)){i("full-test-suite","=== All tests passed ===");try{ls(`${e}/.last-test-run`,String(Date.now()))}catch{}}else i("full-test-suite","=== Some tests failed ===");return p()}import{existsSync as ms,readFileSync as hs,unlinkSync as ys,rmdirSync as _s}from"node:fs";import{execSync as H}from"node:child_process";function ks(){try{return H("which gh",{encoding:"utf8",stdio:["pipe","pipe","pipe"]}),H("gh auth status",{encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function Ss(t){try{return H("git remote get-url origin",{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).includes("github")}catch{return!1}}function bs(t,n,e){let s=n.commits||[];if(s.length===0)return"";let r=s.map(a=>`- \`${a.sha}\`: ${a.message}`).join(`
`),o=n.tasks_completed?.length>0?`### Sub-tasks Completed
${n.tasks_completed.map(a=>`- [x] ${a}`).join(`
`)}`:"";return`## Claude Code Progress Update

**Session**: \`${e.slice(0,8)}...\`
**Branch**: \`${n.branch||"unknown"}\`

### Commits (${s.length})
${r}

${o}
---
*Automated by [OrchestKit](https://github.com/yonatangross/orchestkit)*`}function vs(t,n){try{return H(`gh issue comment ${t} --body "${n.replace(/"/g,'\\"')}"`,{encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}),!0}catch{return!1}}function V(t){i("issue-work-summary","Session ending, checking for issue progress to post...");let n=t.project_dir||d(),e=t.session_id||f(),s=e.replace(/[^a-zA-Z0-9_-]/g,""),r=Jt(s),o=`${r}/issue-progress.json`;if(!ms(o))return i("issue-work-summary",`No progress file found at ${o}`),p();if(!ks())return i("issue-work-summary","gh CLI not available or not authenticated, skipping"),p();if(!Ss(n))return i("issue-work-summary","Not a GitHub repository, skipping"),p();let a;try{a=JSON.parse(hs(o,"utf-8"))}catch{return i("issue-work-summary","Failed to read progress file"),p()}let c=a.issues?Object.keys(a.issues):[];if(c.length===0)return i("issue-work-summary","No issues to process"),p();let u=0;for(let l of c){let g=a.issues[l];if((g.commits||[]).length===0){i("issue-work-summary",`No commits for issue #${l}, skipping`);continue}try{H(`gh issue view ${l} --json number`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{i("issue-work-summary",`Issue #${l} not found or not accessible, skipping`);continue}let m=bs(l,g,e);m&&vs(l,m)&&(u++,i("issue-work-summary",`Successfully posted comment to issue #${l}`))}i("issue-work-summary",`Posted progress comments to ${u} issue(s)`);try{ys(o);try{_s(r)}catch{}i("issue-work-summary","Cleaned up progress file")}catch{}return p()}import{existsSync as D,mkdirSync as xs,readFileSync as ws,writeFileSync as F,readdirSync as ie}from"node:fs";import{execSync as w}from"node:child_process";function $s(t,n){if(!D(`${t}/package.json`)||!D(`${t}/package-lock.json`)&&!D(`${t}/yarn.lock`)&&!D(`${t}/pnpm-lock.yaml`))return null;i("security-scan","Running npm audit...");try{w("npm audit --json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]})}catch(e){if(e.stdout){F(`${n}/npm-audit.json`,e.stdout);try{let s=JSON.parse(e.stdout);return{critical:s.metadata?.vulnerabilities?.critical||0,high:s.metadata?.vulnerabilities?.high||0}}catch{}}}return i("security-scan","npm audit complete"),{critical:0,high:0}}function Is(t,n){if(!D(`${t}/requirements.txt`)&&!D(`${t}/pyproject.toml`))return null;try{w("which pip-audit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","pip-audit not installed, skipping"),null}i("security-scan","Running pip-audit...");try{let e=w("pip-audit --format json",{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]});F(`${n}/pip-audit.json`,e);let s=JSON.parse(e);return i("security-scan","pip-audit complete"),Array.isArray(s)?s.length:0}catch{return 0}}function Rs(t,n){try{w("which semgrep",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","semgrep not installed, skipping"),null}i("security-scan","Running semgrep...");try{let e=w("semgrep --config auto --json --quiet",{cwd:t,encoding:"utf8",timeout:3e5,stdio:["pipe","pipe","pipe"]});F(`${n}/semgrep.json`,e);let r=(JSON.parse(e).results||[]).filter(o=>o.extra?.severity==="ERROR").length;return i("security-scan","semgrep complete"),r}catch{return 0}}function Ds(t,n){try{if(!w('find . -name "*.py" -maxdepth 2 | head -1',{cwd:t,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()&&!D(`${t}/backend`))return null}catch{return null}try{w("which bandit",{encoding:"utf8",stdio:["pipe","pipe","pipe"]})}catch{return i("security-scan","bandit not installed, skipping"),null}i("security-scan","Running bandit...");try{return w(`bandit -r . -f json -o ${n}/bandit.json`,{cwd:t,encoding:"utf8",timeout:12e4,stdio:["pipe","pipe","pipe"]}),i("security-scan","bandit complete"),0}catch{return 0}}function Cs(t,n){i("security-scan","Running secret detection...");let e=/(api[_-]?key|secret[_-]?key|password|token)\s*[=:]\s*["'][^"']{8,}/i,s=0,r=[],o=[".py",".js",".ts",".env"];function a(c){try{let u=ie(c,{withFileTypes:!0});for(let l of u){let g=`${c}/${l.name}`;if(l.isDirectory()){["node_modules",".git","dist","build"].includes(l.name)||a(g);continue}if(o.some(_=>l.name.endsWith(_)))try{let _=ws(g,"utf-8");e.test(_)&&(r.push({file:g,type:"potential_secret"}),s++)}catch{}}}catch{}}return a(t),F(`${n}/secrets.json`,JSON.stringify({findings:r,count:s},null,2)),i("security-scan",`Secret detection complete: ${s} potential issues`),s}function Ts(t,n){i("security-scan","Aggregating results...");let e=0,s=0;n.npmAudit&&(e+=n.npmAudit.critical,s+=n.npmAudit.high),n.pipAudit!==null&&(s+=n.pipAudit),n.semgrep!==null&&(s+=n.semgrep);let r=ie(t).filter(a=>a.endsWith(".json")&&!a.includes("aggregated")).map(a=>a.replace(".json","")),o={timestamp:new Date().toISOString(),summary:{critical:e,high:s,medium:0},scans_completed:r};F(`${t}/aggregated-report.json`,JSON.stringify(o,null,2)),i("security-scan","=== Security Scan Complete ==="),i("security-scan",`Critical: ${e}, High: ${s}`),e>0&&console.error(`Security: ${e} critical, ${s} high vulnerabilities found`)}function K(t){i("security-scan","=== Security Scan Started ===");let n=t.project_dir||d(),e=`${n}/.claude/hooks/logs/security`;xs(e,{recursive:!0});let s={npmAudit:null,pipAudit:null,semgrep:null,bandit:null,secrets:0};return s.npmAudit=$s(n,e),s.pipAudit=Is(n,e),s.semgrep=Rs(n,e),s.bandit=Ds(n,e),s.secrets=Cs(n,e),Ts(e,s),p()}import{existsSync as A,mkdirSync as U,readFileSync as O,writeFileSync as Q}from"node:fs";import{existsSync as It,mkdirSync as Ws,readFileSync as ge,writeFileSync as Ms}from"node:fs";import{existsSync as Ps,readFileSync as As,writeFileSync as Wi,mkdirSync as Mi}from"node:fs";import{execSync as ae}from"node:child_process";import{createHash as Os}from"node:crypto";import*as ce from"node:os";var js=".claude/.user_identity.json",Es="orchestkit-user-identity-v1",Hs={share_with_team:!0,share_globally:!1,share_decisions:!0,share_preferences:!0,share_skill_usage:!1,share_prompts:!1,anonymize_globally:!0},y=null,X=null;function Y(t){return Os("sha256").update(t+Es).digest("hex").slice(0,32)}function Fs(){try{return ce.hostname()}catch{return"unknown-machine"}}function ue(t){let n=`${t}/${js}`;if(!Ps(n))return null;try{let e=As(n,"utf8");return JSON.parse(e)}catch(e){return i("user-identity",`Failed to read user config: ${e}`,"warn"),null}}function Ns(t){let n={};try{n.email=ae("git config user.email",{cwd:t,encoding:"utf8",timeout:2e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{}try{n.name=ae("git config user.name",{cwd:t,encoding:"utf8",timeout:2e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{}return n}function Us(){return{username:process.env.USER||process.env.USERNAME||process.env.LOGNAME}}function P(t){if(y)return y;let n=t||d(),e=Fs(),s=ue(n);if(s?.user_id)return y={user_id:s.user_id,display_name:s.display_name||s.user_id,team_id:s.team_id,machine_id:e,source:"config",anonymous_id:Y(s.user_id),email:s.user_id.includes("@")?s.user_id:void 0},i("user-identity",`Resolved from config: ${y.anonymous_id}`,"debug"),y;let r=Ns(n);if(r.email)return y={user_id:r.email,display_name:r.name||r.email.split("@")[0],team_id:s?.team_id,machine_id:e,source:"git",anonymous_id:Y(r.email),email:r.email},i("user-identity",`Resolved from git: ${y.anonymous_id}`,"debug"),y;let o=Us();if(o.username){let c=`${o.username}@${e}`;return y={user_id:c,display_name:o.username,team_id:s?.team_id,machine_id:e,source:"env",anonymous_id:Y(c)},i("user-identity",`Resolved from env: ${y.anonymous_id}`,"debug"),y}let a=Y(e+process.pid);return y={user_id:`anon-${a.slice(0,8)}`,display_name:"Anonymous",team_id:s?.team_id,machine_id:e,source:"anonymous",anonymous_id:a},i("user-identity",`Resolved as anonymous: ${y.anonymous_id}`,"debug"),y}function vt(t){if(X)return X;let n=t||d(),e=ue(n);return X={...Hs,...e?.privacy},X}function pe(t,n){let e=vt();if(n==="team"&&!e.share_with_team||n==="global"&&!e.share_globally)return!1;switch(t){case"decisions":return e.share_decisions;case"preferences":return e.share_preferences;case"skill_usage":return e.share_skill_usage;case"prompts":return e.share_prompts;default:return!1}}function xt(){let t=P();return{session_id:f(),user_id:t.user_id,anonymous_id:t.anonymous_id,team_id:t.team_id,machine_id:t.machine_id,identity_source:t.source,timestamp:new Date().toISOString()}}var Ls=/^[a-zA-Z0-9_-]{1,128}$/;function Bs(t){return Ls.test(t)}function Rt(t,n){let e=t||f(),s=n||d();if(!Bs(e))throw new Error("Invalid session ID format");return`${s}/.claude/memory/sessions/${e}`}function fe(t,n){return`${Rt(t,n)}/events.jsonl`}function me(t,n){let e=Rt(t,n);It(e)||Ws(e,{recursive:!0})}var N=0,le=!1,wt=!1,de=0,Js=5e3;function he(t,n){return`${Rt(t,n)}/counter.json`}function zs(t,n){if(!le){le=!0;try{let e=he(t,n);if(It(e)){let s=JSON.parse(ge(e,"utf8"));typeof s.counter=="number"&&s.counter>0&&(N=s.counter,i("session-tracker",`Loaded event counter: ${N}`,"debug"))}}catch{}}}function Gs(t,n){if(!wt)return;let e=Date.now();if(!(e-de<Js))try{me(t,n);let s=he(t,n);Ms(s,JSON.stringify({counter:N,updated_at:new Date().toISOString()})),wt=!1,de=e}catch{}}function qs(){return zs(),N++,wt=!0,Gs(),`evt-${Date.now()}-${N}`}function Zs(t,n,e={}){try{let s={event_id:qs(),event_type:t,identity:xt(),payload:{name:n,input:$t(e.input),output:$t(e.output),duration_ms:e.duration_ms,success:e.success??!0,context:e.context?_e(e.context,500):void 0,confidence:e.confidence}};me();let r=fe();h(r,JSON.stringify(s)+`
`),i("session-tracker",`Tracked ${t}: ${n}`,"debug")}catch(s){i("session-tracker",`Failed to track event: ${s}`,"warn")}}function ye(){Zs("session_end","session",{success:!0,input:{ended_at:new Date().toISOString()}})}function Dt(t){let n=fe(t);if(!It(n))return[];try{return ge(n,"utf8").trim().split(`
`).filter(Boolean).map(r=>JSON.parse(r))}catch(e){return i("session-tracker",`Failed to load session events: ${e}`,"warn"),[]}}function Ct(t){let n=Dt(t),e=xt(),s={skill_invoked:0,agent_spawned:0,hook_triggered:0,decision_made:0,preference_stated:0,problem_reported:0,solution_found:0,tool_used:0,session_start:0,session_end:0,communication_style_detected:0},r=new Set,o=new Set,a=new Set,c,u;for(let g of n)switch(s[g.event_type]++,g.event_type){case"skill_invoked":r.add(g.payload.name);break;case"agent_spawned":o.add(g.payload.name);break;case"hook_triggered":a.add(g.payload.name);break;case"session_start":c=g.identity.timestamp;break;case"session_end":u=g.identity.timestamp;break}let l=c&&u?new Date(u).getTime()-new Date(c).getTime():void 0;return{session_id:t||e.session_id,user_id:e.user_id,anonymous_id:e.anonymous_id,team_id:e.team_id,start_time:c,end_time:u,duration_ms:l,event_counts:s,skills_used:[...r],agents_spawned:[...o],hooks_triggered:[...a],decisions_made:s.decision_made,problems_reported:s.problem_reported,solutions_found:s.solution_found}}function _e(t,n){return t.length<=n?t:t.slice(0,n-3)+"..."}function $t(t){if(!t)return;let n={},e=["password","secret","token","key","credential","auth"];for(let[s,r]of Object.entries(t)){if(e.some(o=>s.toLowerCase().includes(o))){n[s]="[REDACTED]";continue}if(typeof r=="string"&&r.length>500){n[s]=_e(r,500);continue}if(typeof r=="object"&&r!==null&&!Array.isArray(r)){n[s]=$t(r);continue}n[s]=r}return n}var Vs={Grep:"search",Glob:"search",WebSearch:"web",Read:"file_read",Write:"file_write",Edit:"file_edit",MultiEdit:"file_edit",NotebookEdit:"file_edit",Bash:"execution",Task:"agent",Skill:"skill",WebFetch:"web",AskUserQuestion:"interaction",TaskCreate:"task_mgmt",TaskUpdate:"task_mgmt",TaskList:"task_mgmt",TaskGet:"task_mgmt",TaskOutput:"task_mgmt",TaskStop:"task_mgmt",EnterPlanMode:"interaction",ExitPlanMode:"interaction"};function ke(t){return Vs[t]||"other"}function Ks(t){if(!A(t))return"";try{let e=JSON.parse(O(t,"utf-8")).tools||{};return Object.entries(e).sort(([,r],[,o])=>o-r).slice(0,10).map(([r])=>r).join(",")}catch{return""}}function Xs(t){if(!A(t))return 0;try{let e=JSON.parse(O(t,"utf-8")).tools||{};return Object.values(e).reduce((s,r)=>s+r,0)}catch{return 0}}function Ys(t){return t.includes("Write")&&t.includes("Bash")&&/test|pytest|jest|vitest/i.test(t)?"test-driven-development":t.includes("Read")&&t.includes("Grep")?"code-exploration":t.includes("Edit")&&!t.includes("Write")?"refactoring":t.includes("Write")&&t.includes("Read")?"feature-development":t.includes("Bash")&&/git|gh/i.test(t)?"git-operations":"general"}function Qs(t){return"unknown"}function tr(t){if(A(t))try{return JSON.parse(O(t,"utf-8"))}catch{}return{version:"1.0.0",last_updated:null,sessions_count:0,workflow_types:{"test-driven-development":0,"code-exploration":0,refactoring:0,"feature-development":0,"git-operations":0,general:0},common_tool_sequences:[],dominant_languages:{python:0,typescript:0,javascript:0,go:0,rust:0,unknown:0},average_tools_per_session:0,average_session_duration_seconds:0,tool_frequency:{}}}function er(t,n,e,s,r){let o=tr(t),a=new Date().toISOString();if(o.last_updated=a,o.sessions_count+=1,o.workflow_types[n]=(o.workflow_types[n]||0)+1,o.dominant_languages[e]=(o.dominant_languages[e]||0)+1,o.average_tools_per_session=(o.average_tools_per_session*(o.sessions_count-1)+s)/o.sessions_count,r.split(",").filter(Boolean).length>2){let u=new Set([r,...o.common_tool_sequences]);o.common_tool_sequences=Array.from(u).slice(0,20)}U(t.replace(/\/[^/]+$/,""),{recursive:!0}),Q(t,JSON.stringify(o,null,2))}function nr(t){if(A(t))try{return JSON.parse(O(t,"utf-8"))}catch{}return{version:"1.0",updated:"",patterns:[],categories:{},stats:{total:0,successes:0,failures:0}}}function sr(){let t={};try{let s=Dt().filter(r=>r.event_type==="tool_used");for(let r of s){let o=r.payload.name,a=r.payload.input?.category||ke(o);t[a]||(t[a]={}),t[a][o]=(t[a][o]||0)+1}}catch{}let n={};for(let[e,s]of Object.entries(t)){let r=Object.entries(s).sort(([,o],[,a])=>a-o);r.length>0&&(n[e]=r[0][0])}return{usageByCategory:t,preferences:n}}function rr(t){let{usageByCategory:n,preferences:e}=sr();if(Object.keys(e).length===0){i("session-patterns","No tool usage to aggregate");return}let s=`${t}/.claude/feedback/tool-preferences.json`,r={version:"1.0.0",updated:"",usage_by_category:{},preferences:{},sessions_aggregated:0};if(A(s))try{r=JSON.parse(O(s,"utf-8"))}catch{}for(let[a,c]of Object.entries(n)){r.usage_by_category[a]||(r.usage_by_category[a]={});for(let[u,l]of Object.entries(c))r.usage_by_category[a][u]=(r.usage_by_category[a][u]||0)+l}for(let[a,c]of Object.entries(r.usage_by_category)){let u=Object.entries(c).sort(([,l],[,g])=>g-l);u.length>0&&(r.preferences[a]=u[0][0])}r.updated=new Date().toISOString(),r.sessions_aggregated+=1,U(`${t}/.claude/feedback`,{recursive:!0}),Q(s,JSON.stringify(r,null,2));let o=Object.keys(r.preferences).length;i("session-patterns",`Updated tool preferences: ${o} categories`)}function or(t){let n=`${t}/.claude/feedback/patterns-queue.json`,e=`${t}/.claude/feedback/learned-patterns.json`;if(!A(n)){i("session-patterns","No patterns queue found");return}let s;try{s=JSON.parse(O(n,"utf-8"))}catch{i("session-patterns","Failed to parse patterns queue");return}let r=s.patterns?.length||0;if(r===0){i("session-patterns","Patterns queue is empty");return}i("session-patterns",`Processing ${r} queued patterns...`);let o=nr(e),a=new Date().toISOString(),c=[...o.patterns,...s.patterns],u=new Map;for(let S of c)u.set(S.text,S);let l=Array.from(u.values()),g=l.filter(S=>S.outcome==="success").length,_=l.filter(S=>S.outcome==="failed").length,m={};for(let S of l)m[S.category]=(m[S.category]||0)+1;let v={version:"1.0",updated:a,patterns:l,categories:m,stats:{total:l.length,successes:g,failures:_}};U(e.replace(/\/[^/]+$/,""),{recursive:!0}),Q(e,JSON.stringify(v,null,2)),i("session-patterns","Merged patterns successfully"),Q(n,JSON.stringify({patterns:[]}))}function tt(t){i("session-patterns","Session ending, processing patterns...");let n=t.project_dir||d(),e=Bt(),s=`${n}/.claude/feedback/workflow-patterns.json`;U(`${n}/.claude/feedback`,{recursive:!0}),U(`${n}/.claude/logs`,{recursive:!0});let r=Xs(e);if(r>=5){let o=Ks(e),a=Ys(o),c=Qs(o);er(s,a,c,r,o),i("session-patterns",`Workflow analyzed: type=${a} lang=${c} tools=${r}`)}else i("session-patterns",`Session too short for workflow analysis (tools: ${r})`);return rr(n),or(n),i("session-patterns","Pattern processing complete"),p()}import{existsSync as Ie,readFileSync as Re}from"node:fs";import{existsSync as Se,readFileSync as ir,writeFileSync as ar,mkdirSync as cr}from"node:fs";function be(){let t=f();return`${d()}/.claude/orchestration/task-registry-${t}.json`}function ur(){let t=`${d()}/.claude/orchestration`;if(!Se(t))try{cr(t,{recursive:!0})}catch{}}function ve(){let t=be();if(Se(t))try{return JSON.parse(ir(t,"utf8"))}catch{}return{schemaVersion:"1.0.0",sessionId:f(),tasks:[],pipelines:[],updatedAt:new Date().toISOString()}}function pr(t){ur();let n=be();t.updatedAt=new Date().toISOString();try{ar(n,JSON.stringify(t,null,2))}catch(e){i("task-integration",`Failed to save registry: ${e}`)}}function xe(t,n){return`### Delete Orphaned Task

\`\`\`
TaskUpdate:
  taskId: "${t}"
  status: "deleted"
\`\`\`

**Reason**: ${n}`}function we(){let t=ve(),n=new Set(t.tasks.filter(e=>e.status==="failed").map(e=>e.taskId));return n.size===0?[]:t.tasks.filter(e=>e.status!=="pending"||!e.blockedBy||e.blockedBy.length===0?!1:e.blockedBy.every(s=>n.has(s)))}function $e(t=1440*60*1e3){let n=ve(),e=Date.now()-t;n.tasks=n.tasks.filter(s=>s.status==="pending"||s.status==="in_progress"?!0:new Date(s.createdAt).getTime()>e),n.pipelines=n.pipelines.filter(s=>s.status==="running"?!0:new Date(s.startedAt).getTime()>e),pr(n)}function et(t){i("task-completion-check","Stop hook - checking task completion");let n=[],e=t.project_dir||d(),s=t.session_id||f(),r=`${e}/.claude/orchestration/task-registry-${s}.json`;if(Ie(r))try{let l=(JSON.parse(Re(r,"utf-8")).tasks||[]).filter(g=>g.status==="in_progress");l.length>0&&(i("task-completion-check",`WARNING: ${l.length} orchestration tasks still in progress`),n.push(`${l.length} orchestration task(s) still in progress at session stop`))}catch(u){i("task-completion-check",`Error reading registry: ${u}`)}let o=we(),a="";if(o.length>0){i("task-completion-check",`Found ${o.length} orphaned tasks`),a=`

## Orphaned Tasks

The following tasks are orphaned (all blockers failed) and should be deleted:
`;for(let u of o)a+=`
${xe(u.taskId,"All blocking tasks have failed")}`}let c=zt();if(Ie(c))try{let l=JSON.parse(Re(c,"utf-8")).filter(g=>g.status==="in_progress");l.length>0&&(i("task-completion-check",`WARNING: ${l.length} legacy tasks in progress at stop`),n.push(`${l.length} legacy task(s) still in progress`))}catch(u){i("task-completion-check",`Error reading legacy todos: ${u}`)}if(n.length>0||a){let u=`## Task Completion Warning

${n.map(l=>`- ${l}`).join(`
`)}`;return a&&(u+=a),k(u)}return p()}import{existsSync as Tt,readFileSync as lr,writeFileSync as ga,mkdirSync as fa}from"node:fs";function Ce(){return`${d()}/.claude/orchestration`}function dr(){let t=f();return`${Ce()}/session-${t}.json`}function gr(){return`${d()}/.claude/orchestration/config.json`}var De={enableAutoDispatch:!0,enableSkillInjection:!0,maxSkillInjectionTokens:1200,enableCalibration:!0,enablePipelines:!0,maxRetries:3,retryDelayBaseMs:1e3};function Te(){let t=gr();if(Tt(t))try{let n=lr(t,"utf8");return{...De,...JSON.parse(n)}}catch{}return De}function Pt(){let t=dr();try{if(Tt(t)){let{unlinkSync:n}=Nt("node:fs");n(t),i("orchestration-state","Cleared session state")}}catch{}}function At(){let t=Ce();if(Tt(t))try{let{readdirSync:n,statSync:e,unlinkSync:s}=Nt("node:fs"),r=n(t).filter(o=>o.startsWith("session-")&&o.endsWith(".json")).map(o=>({name:o,path:`${t}/${o}`,mtime:e(`${t}/${o}`).mtime.getTime()})).sort((o,a)=>a.mtime-o.mtime);for(let o of r.slice(5))try{s(o.path),i("orchestration-state",`Cleaned up old state: ${o.name}`)}catch{}}catch{}}var fr=720*60*60*1e3;function mr(t){let n=Date.now()-fr,e=t.records.length;t.records=t.records.filter(r=>new Date(r.timestamp).getTime()>n);let s=t.records.length;e!==s&&i("calibration-persist",`Cleaned up ${e-s} old records`)}function hr(t){let n=t.stats,e=n.topAgents.slice(0,3).map(s=>`${s.agent}(${Math.round(s.successRate*100)}%)`).join(", ");return`Calibration summary: ${n.totalDispatches} dispatches, ${Math.round(n.successRate*100)}% success rate, ${t.adjustments.length} adjustments active. Top agents: ${e||"none"}`}function nt(t){if(!Te().enableCalibration)return Pt(),At(),p();i("calibration-persist","Running end-of-session calibration persistence...");try{let e=I();se(e),mr(e),yt(e);let s=hr(e);i("calibration-persist",s)}catch(e){i("calibration-persist",`Error during calibration persist: ${e}`)}try{Pt(),At(),$e(),i("calibration-persist","Cleaned up session state")}catch(e){i("calibration-persist",`Error during state cleanup: ${e}`)}return p()}import{existsSync as W,readFileSync as Ue,writeFileSync as We,mkdirSync as Me}from"node:fs";import{join as ot,dirname as $r}from"node:path";import{existsSync as Pe,readFileSync as yr,writeFileSync as xa,mkdirSync as _r}from"node:fs";import{join as Ae,dirname as kr,basename as Ia}from"node:path";function Sr(t){return Ae(d(),".claude","memory","flows",`${t}.json`)}function br(){return Ae(d(),".claude","memory","completed-flows.jsonl")}function Oe(t){let n=Sr(t);if(!Pe(n))return null;try{let e=yr(n,"utf-8");return JSON.parse(e)}catch(e){return i("decision-flow-tracker",`Failed to load flow for ${t}: ${e}`,"warn"),null}}function vr(t){let n=br();try{let e=kr(n);Pe(e)||_r(e,{recursive:!0});let s=JSON.stringify(t)+`
`;return h(n,s),!0}catch(e){return i("decision-flow-tracker",`Failed to archive flow: ${e}`,"warn"),!1}}function je(t){if(t.length<3)return"mixed";let n={exploration:0,modification:0,testing:0,building:0,agent:0,execution:0,git:0,other:0};for(let e of t)n[e.category]++;if(n.testing>=2){let e=t.map((r,o)=>r.category==="testing"?o:-1).filter(r=>r>=0),s=t.map((r,o)=>r.category==="modification"?o:-1).filter(r=>r>=0);if(e.length>=2&&s.length>0&&e[0]<s[0])return"test-first"}if(n.exploration>=3&&n.modification>0&&xr(t,"exploration")>=3)return"explore-first";if(n.modification>=2&&n.execution+n.testing>=2&&wr(t,"modification",["execution","testing"])>=2)return"iterate-fast";if(n.agent>=3||n.agent/t.length>.3)return"agent-delegate";if(n.modification>=3&&n.testing===1){let e=t.map((s,r)=>s.category==="testing"?r:-1).filter(s=>s>=0).pop();if(e&&e>t.length-3)return"big-bang"}return"mixed"}function xr(t,n){let e=0,s=0;for(let r of t)r.category===n?(s++,e=Math.max(e,s)):s=0;return e}function wr(t,n,e){let s=0,r=!1;for(let o of t){let a=o.category===n,c=e.includes(o.category);a&&!r?r=!0:c&&r&&(s++,r=!1)}return s}function Ee(t){let n=t.filter(e=>e.result==="success").length;return{total_actions:t.length,reads:t.filter(e=>e.category==="exploration").length,writes:t.filter(e=>e.category==="modification").length,tests:t.filter(e=>e.category==="testing").length,builds:t.filter(e=>e.category==="building").length,agent_spawns:t.filter(e=>e.category==="agent").length,success_rate:t.length>0?n/t.length:0}}function st(t){let n=Oe(t);return n?(n.inferred_pattern=je(n.actions),n.stats=Ee(n.actions),n):null}function He(t){let n=Oe(t);if(!n)return!1;n.inferred_pattern=je(n.actions),n.stats=Ee(n.actions);let e=vr(n);return e&&i("decision-flow-tracker",`Completed flow for ${t}: ${n.actions.length} actions, pattern: ${n.inferred_pattern}`,"info"),e}var Ir={"test-first":"Writes tests before implementation (TDD)","explore-first":"Reads existing code before making changes","iterate-fast":"Makes quick write \u2192 test iterations","big-bang":"Writes multiple files then tests","agent-delegate":"Delegates tasks to specialized agents",mixed:"Varies approach by task"};function Rr(t,n){let e=n.find(r=>r.name===t),s=e?Math.min(1,e.frequency+.1):.1;return{name:t,description:Ir[t],frequency:s,tool_sequences:[]}}var rt=2;var Dr={1:t=>({...t,version:2,tool_preferences:t.tool_preferences||{},tool_usage_by_category:t.tool_usage_by_category||{}})};function Cr(t){let n=t.version||1;for(;n<rt;){let e=Dr[n];if(!e){i("user-profile",`Missing migration for version ${n}`,"warn");break}t=e(t),n=t.version,i("user-profile",`Migrated profile to version ${n}`,"info")}return t}function Tr(){return dt()}function Pr(){return ot(Tr(),".claude","orchestkit")}function Le(t){let n=t.replace(/[^a-zA-Z0-9@._-]/g,"_");return ot(Pr(),"users",n)}function Ot(t){return ot(Le(t),"profile.json")}function Ar(t){let n=t.replace(/[^a-zA-Z0-9@._-]/g,"_");return ot(d(),".claude","memory","users",n,"profile.json")}function Or(t){let n=Ar(t),e=Ot(t);if(W(e))return!1;if(W(n))try{let s=$r(e);W(s)||Me(s,{recursive:!0});let r=Ue(n,"utf8"),o=JSON.parse(r);We(e,JSON.stringify(o,null,2));let a=t.replace(/@.*$/,"@***");return i("user-profile",`Migrated profile for ${a} to cross-project storage`,"info"),!0}catch(s){return i("user-profile",`Failed to migrate profile: ${s}`,"warn"),!1}return!1}function Fe(t){let n=P(),e=new Date().toISOString();return{user_id:t,anonymous_id:n.anonymous_id,display_name:n.display_name,team_id:n.team_id,sessions_count:0,first_seen:e,last_seen:e,version:rt,skill_usage:{},agent_usage:{},tool_usage:{},decisions:[],preferences:[],workflow_patterns:[],aggregated_sessions:[]}}function Be(t){let n=t||P().user_id;Or(n);let e=Ot(n);if(!W(e))return Fe(n);try{let s=Ue(e,"utf8"),r=JSON.parse(s),o=Cr(r);return(r.version||1)<rt&&(jt(o),i("user-profile",`Auto-saved migrated profile (v${rt})`,"info")),o}catch(s){return i("user-profile",`Failed to load profile: ${s}`,"warn"),Fe(n)}}function jt(t){let n=Le(t.user_id),e=Ot(t.user_id);try{return W(n)||Me(n,{recursive:!0}),t.last_seen=new Date().toISOString(),We(e,JSON.stringify(t,null,2)),i("user-profile",`Saved profile for ${t.anonymous_id}`,"debug"),!0}catch(s){return i("user-profile",`Failed to save profile: ${s}`,"error"),!1}}function Ne(t,n,e){let s=new Date().toISOString();if(!t)return{count:1,success_rate:n?1:0,avg_duration_ms:e,first_used:s,last_used:s};let r=t.count+1,a=(Math.round(t.success_rate*t.count)+(n?1:0))/r,c=t.avg_duration_ms;return e!==void 0&&(t.avg_duration_ms!==void 0?c=(t.avg_duration_ms*t.count+e)/r:c=e),{count:r,success_rate:a,avg_duration_ms:c,first_used:t.first_used,last_used:s}}function Je(t,n){if(t.aggregated_sessions.includes(n.session_id))return i("user-profile",`Session ${n.session_id} already aggregated`,"debug"),t;t.sessions_count++,t.aggregated_sessions.push(n.session_id);for(let s of n.skills_used)t.skill_usage[s]=Ne(t.skill_usage[s],!0);for(let s of n.agents_spawned)t.agent_usage[s]=Ne(t.agent_usage[s],!0);try{let s=st(n.session_id);if(s?.inferred_pattern&&s.inferred_pattern!=="mixed"){let r=s.inferred_pattern,o=t.workflow_patterns.findIndex(a=>a.name===r);if(o!==-1){let a=t.workflow_patterns[o];a.frequency=Math.min(1,a.frequency+.1),t.workflow_patterns.splice(o,1),t.workflow_patterns.unshift(a)}else{let a=Rr(r,t.workflow_patterns);t.workflow_patterns.unshift(a)}t.workflow_patterns.length>10&&(t.workflow_patterns=t.workflow_patterns.slice(0,10)),i("user-profile",`Aggregated workflow pattern: ${r}`,"debug")}}catch(s){i("user-profile",`Failed to aggregate workflow pattern: ${s}`,"debug")}let e=100;return t.aggregated_sessions.length>e&&(t.aggregated_sessions=t.aggregated_sessions.slice(-e)),t}function ze(t){let n=t.decisions.map(e=>{let{project:s,...r}=e;return r});return{anonymous_id:t.anonymous_id,decisions:n,preferences:t.preferences}}function Ge(t){try{let n=P();i("session-profile-aggregator",`Aggregating session for ${n.user_id}`,"debug");let e=Ct();if(e.skills_used.length===0&&e.agents_spawned.length===0&&e.decisions_made===0)return i("session-profile-aggregator","No meaningful activity to aggregate","debug"),p();let s=Be(n.user_id),r=Je(s,e);if(!jt(r))return i("session-profile-aggregator","Failed to save profile","warn"),p();if(i("session-profile-aggregator",`Aggregated session: ${e.skills_used.length} skills, ${e.agents_spawned.length} agents, ${e.decisions_made} decisions`,"info"),vt().share_globally&&pe("decisions","global")){let u=ze(r).decisions.filter(l=>l.confidence>=.8&&l.rationale);u.length>0&&i("session-profile-aggregator",`${u.length} decisions eligible for global sharing`,"info")}return p()}catch(n){return i("session-profile-aggregator",`Error aggregating session: ${n}`,"error"),p()}}function it(t){try{return ye(),i("session-end-tracking","Tracked session end","debug"),p()}catch(n){return i("session-end-tracking",`Error: ${n}`,"warn"),p()}}import{existsSync as Ze,readFileSync as jr,writeFileSync as Er,mkdirSync as Hr}from"node:fs";import{join as Fr,dirname as Nr}from"node:path";var M="workflow-preference-learner",Ur=5;function Ve(){return Fr(d(),".claude","memory","workflow-preferences.json")}function Wr(){let t=Ve();if(!Ze(t))return qe();try{let n=jr(t,"utf-8");return JSON.parse(n)}catch{return qe()}}function Mr(t){let n=Ve();try{let e=Nr(n);return Ze(e)||Hr(e,{recursive:!0}),Er(n,JSON.stringify(t,null,2)),!0}catch(e){return i(M,`Failed to save workflow preferences: ${e}`,"warn"),!1}}function qe(){let t=["test-first","explore-first","iterate-fast","big-bang","agent-delegate","mixed"],n={},e={};for(let s of t)n[s]=0,e[s]=[];return{pattern_counts:n,pattern_success_rates:e,total_sessions:0,preferences:[],updated_at:new Date().toISOString()}}function Lr(t){let n=[],e=new Date().toISOString();for(let[s,r]of Object.entries(t.pattern_counts)){if(r===0)continue;let o=t.pattern_success_rates[s]||[],a=o.length>0?o.reduce((c,u)=>c+u,0)/o.length:0;n.push({pattern:s,frequency:t.total_sessions>0?r/t.total_sessions:0,count:r,total_sessions:t.total_sessions,avg_success_rate:a,updated_at:e})}return n.sort((s,r)=>r.frequency-s.frequency),n}function Br(t,n){if(!n.inferred_pattern)return;let e=n.inferred_pattern,s=n.stats.success_rate;t.pattern_counts[e]=(t.pattern_counts[e]||0)+1,t.total_sessions++,t.pattern_success_rates[e]||(t.pattern_success_rates[e]=[]),t.pattern_success_rates[e].push(s),t.pattern_success_rates[e].length>20&&(t.pattern_success_rates[e]=t.pattern_success_rates[e].slice(-20)),t.preferences=Lr(t),t.updated_at=new Date().toISOString()}function at(t){let n=t.session_id||f(),e=st(n);if(!e)return i(M,`No decision flow found for session ${n}`,"debug"),p();if(e.actions.length<Ur)return i(M,`Too few actions (${e.actions.length}) for pattern detection`,"debug"),p();if(He(n),e.inferred_pattern==="mixed")return p();let s=Wr();Br(s,e),Mr(s),i(M,`Session pattern: ${e.inferred_pattern} (${e.actions.length} actions, ${(e.stats.success_rate*100).toFixed(0)}% success)`,"info");let r=s.preferences[0];return r&&r.frequency>.6&&r.count>=5&&i(M,`Strong workflow preference: ${r.pattern} (${(r.frequency*100).toFixed(0)}% of sessions)`,"info"),p()}import{existsSync as ct,mkdirSync as Jr}from"node:fs";import{execSync as zr}from"node:child_process";function Ke(t){let n=d(),e=b(),s=`${e}/coverage-check.log`,r=parseInt(process.env.COVERAGE_THRESHOLD||"80",10);try{Jr(e,{recursive:!0})}catch{}let o=[],a=new Date().toISOString().replace("T"," ").slice(0,19);o.push(`[${a}] Coverage Check`);let c=`${n}/.coverage`,u=`${n}/coverage.xml`;if(ct(c)||ct(u))try{let _=zr("coverage report --fail-under=0",{cwd:n,encoding:"utf8",timeout:3e4,stdio:["pipe","pipe","pipe"]}).split(`
`).find(m=>m.includes("TOTAL"));if(_){let m=_.match(/(\d+)%/);if(m){let v=parseInt(m[1],10);o.push(`Python coverage: ${v}%`),v<r?o.push(`WARNING: Coverage ${v}% is below threshold ${r}%`):o.push("Coverage meets threshold")}}}catch{}let l=`${n}/coverage`;if(ct(l)){let g=`${l}/coverage-summary.json`;ct(g)&&(o.push(""),o.push("JavaScript/TypeScript coverage report found"),o.push("Check coverage/lcov-report/index.html for details"))}try{h(s,o.join(`
`)+`
`)}catch{}return p()}import{existsSync as C,mkdirSync as Gr,readdirSync as qr}from"node:fs";function Xe(t){let n=b(),e=d(),s=`${n}/evidence-collector.log`;try{Gr(n,{recursive:!0})}catch{}let r=new Date().toISOString().replace("T"," ").slice(0,19),o=[];o.push(`[${r}] Evidence Collection`),o.push("Recent command results:");let a=process.env.CC_LAST_EXIT_CODE;a&&o.push(`  Last exit code: ${a}`),(C(`${e}/pytest.xml`)||C(`${e}/junit.xml`))&&o.push("  Test results: Found (XML format)");let c=`${e}/test-results`;if(C(c)){o.push("  Test results directory: Found");try{let u=qr(c).slice(0,5);for(let l of u)o.push(`    ${l}`)}catch{}}(C(`${e}/.coverage`)||C(`${e}/coverage`))&&o.push("  Coverage data: Found"),(C(`${e}/lint-results.json`)||C(`${e}/eslint-report.json`))&&o.push("  Lint results: Found"),o.push("Evidence verification complete.");try{h(s,o.join(`
`)+`
`)}catch{}return p()}import{existsSync as Zr,readFileSync as Vr}from"node:fs";var Kr=["coverage/coverage-summary.json","coverage/coverage-final.json",".vitest/coverage/coverage-summary.json","coverage.json",".coverage.json","htmlcov/status.json"];function Xr(t,n){try{let e=JSON.parse(n);return t.includes("coverage-summary.json")?e?.total?.lines?.pct??e?.total?.statements?.pct??null:t.includes("coverage.json")?e?.totals?.percent_covered??null:e?.total?.pct!==void 0?e.total.pct:null}catch{return null}}function Ye(t){let n=d(),e=parseInt(process.env.COVERAGE_THRESHOLD||"80",10),s="",r="";for(let c of Kr){let u=`${n}/${c}`;if(Zr(u)){s=u;try{r=Vr(u,"utf8")}catch{continue}break}}if(!s||!r)return p();let o=Xr(s,r);if(o===null)return p();if(Math.floor(o)<e){let c=`BLOCKED: Coverage ${o}% is below threshold ${e}%

Coverage report: ${s}

Actions required:
  1. Identify uncovered code paths
  2. Add tests for critical business logic
  3. Re-run tests with coverage:

     TypeScript: npm test -- --coverage
     Python:     pytest --cov=app --cov-report=term-missing

  4. Ensure coverage >= ${e}% before proceeding

Tip: Focus on testing:
  - Business logic (services, utils)
  - Edge cases and error handling
  - Critical user flows`;return T(c)}return p()}import{existsSync as L,readFileSync as Yr}from"node:fs";import{basename as ut,dirname as j}from"node:path";function Qr(t){return/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(t)||/test_.*\.py$/.test(t)||/_test\.py$/.test(t)}function to(t){if(/\.(ts|tsx|js|jsx)$/.test(t)){let n=t.replace(/\.[^.]+$/,""),e=t.split(".").pop()||"ts",s=[`${n}.test.${e}`,`${n}.spec.${e}`,`${n}.test.ts`,`${n}.test.tsx`];for(let u of s)if(L(u))return u;let r=j(t),a=ut(t).replace(/\.[^.]+$/,""),c=[`${r}/__tests__/${a}.test.${e}`,`${r}/__tests__/${a}.spec.${e}`];for(let u of c)if(L(u))return u}else if(t.endsWith(".py")){let n=j(t),s=`test_${ut(t)}`;if(L(`${n}/${s}`))return`${n}/${s}`;let r=j(n);if(L(`${r}/tests/${s}`))return`${r}/tests/${s}`;if(L(`${n}/tests/${s}`))return`${n}/tests/${s}`}return null}function eo(t,n){let e=[];if(/\.(ts|tsx|js|jsx)$/.test(n)){let s=t.match(/export (function|class|const|async function)\s+([A-Za-z_][A-Za-z0-9_]*)/g);if(s)for(let r of s){let o=r.split(/\s+/).pop();o&&e.push(o)}}else if(n.endsWith(".py")){let s=t.split(`
`);for(let r of s){let o=r.match(/^(def|class)\s+([A-Za-z][A-Za-z0-9_]*)/);o&&o[2]&&e.push(o[2])}}return[...new Set(e)]}function Qe(t){let n=t.tool_input?.file_path||"",e=t.tool_input?.content||t.tool_result||"";if(!n||!e)return p();if(Qr(n))return p();if(!/\.(ts|tsx|js|jsx|py)$/.test(n))return p();let s=[],r=[],o=to(n),a=eo(e,n);if(a.length>0)if(o)try{let c=Yr(o,"utf8"),u=[];for(let l of a)new RegExp(`\\b${l.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`).test(c)||u.push(l);if(u.length>0){r.push("TEST COVERAGE: New units without tests"),r.push(`  Implementation: ${n}`),r.push(`  Test file: ${o}`),r.push(""),r.push(`  Untested units (${u.length}/${a.length}):`);for(let l of u.slice(0,5))r.push(`    - ${l}`);r.push(""),r.push("  Add tests before committing")}}catch{}else{if(s.push("TEST COVERAGE: No test file found for implementation"),s.push(`  Implementation: ${n}`),s.push("  Expected test file:"),/\.(ts|tsx|js|jsx)$/.test(n)){let c=n.replace(/\.[^.]+$/,""),u=n.split(".").pop()||"ts",l=j(n),g=ut(n);s.push(`    - ${c}.test.${u}`),s.push(`    - ${l}/__tests__/${g}`)}else if(n.endsWith(".py")){let c=ut(n),u=j(n);s.push(`    - ${u}/test_${c}`),s.push(`    - ${j(u)}/tests/test_${c}`)}s.push(""),s.push(`  Found ${a.length} testable units:`);for(let c of a.slice(0,5))s.push(`    - ${c}`)}if(s.length>0)return T(`Missing test coverage for new code: ${s[0]}`);if(r.length>0){let c=r.join(`
`);return k(`Test coverage warnings detected:

${c}`)}return p()}import{basename as no}from"node:path";function tn(t){let n=t.tool_input?.file_path||"",e=t.tool_input?.content||t.tool_result||"";if(!n||!e)return p();if(!/\/routers\/.*\.py$/.test(n))return p();let s=no(n);if(/^(deps|dependencies|__init__)\.py$/.test(s))return p();let r=[];if(/=\s*[A-Z][a-zA-Z]*Service\s*\(\s*\)/.test(e)){let o=e.match(/[A-Z][a-zA-Z]*Service\s*\(\s*\)/);r.push("INSTANTIATION: Direct service instantiation not allowed"),r.push(`  Found: ${o?.[0]||"Service()"}`),r.push("  "),r.push("  Use dependency injection:"),r.push("    service: MyService = Depends(get_my_service)")}if(/=\s*[A-Z][a-zA-Z]*(Repository|Repo)\s*\(\s*\)/.test(e)){let o=e.match(/[A-Z][a-zA-Z]*(Repository|Repo)\s*\(\s*\)/);r.push("INSTANTIATION: Direct repository instantiation not allowed"),r.push(`  Found: ${o?.[0]||"Repository()"}`),r.push("  "),r.push("  Use dependency injection:"),r.push("    repo: MyRepository = Depends(get_my_repository)")}if(/^[a-z_]+\s*=\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)\s*\(/m.test(e)&&(r.push("GLOBAL: Global service/repository instance not allowed"),r.push("  "),r.push("  Global instances cause:"),r.push("    - Shared state between requests"),r.push("    - Difficult testing"),r.push("    - Connection pool issues"),r.push("  "),r.push("  Use Depends() for request-scoped instances")),/:\s*(Async)?Session[^=]*\)/.test(e)&&(/:\s*(Async)?Session\s*=\s*Depends/.test(e)||(r.push("DI: Database session must use Depends()"),r.push("  "),r.push("  BAD:  async def get_users(db: AsyncSession):"),r.push("  GOOD: async def get_users(db: AsyncSession = Depends(get_db)):"))),/@router\.(get|post|put|patch|delete)/.test(e)&&/:\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)[^=)]*\)/.test(e)&&(/:\s*[A-Z][a-zA-Z]*(Service|Repository|Repo)\s*=\s*Depends/.test(e)||(r.push("DI: Service/Repository parameters must use Depends()"),r.push("  "),r.push("  BAD:  async def create_user(user_service: UserService):"),r.push("  GOOD: async def create_user(user_service: UserService = Depends(get_user_service)):"))),/async def/.test(e)){/db\.query\(/.test(e)&&(/await.*db\.query\(/.test(e)||(r.push("ASYNC: Sync database call in async function"),r.push("  Found: db.query() (sync pattern)"),r.push("  "),r.push("  Use async SQLAlchemy 2.0 patterns:"),r.push("    result = await db.execute(select(User))"),r.push("    users = result.scalars().all()")));let o=/db\.(add|delete|commit|flush|rollback|refresh)\(/;if(o.test(e)&&/AsyncSession/.test(e)){let a=e.split(`
`);for(let c of a)if(o.test(c)&&!c.includes("await")){r.push("ASYNC: Missing await for async database operation"),r.push("  "),r.push("  With AsyncSession, use await:"),r.push("    await db.commit()"),r.push("    await db.refresh(user)");break}}}if(r.length>0){i("di-pattern-enforcer",`BLOCKED: DI violation in ${n}`);let o=`Dependency injection violation in ${n}. See stderr for details.`;return k(o)}return p()}import{readFileSync as ro,readdirSync as oo}from"node:fs";import{execSync as so}from"node:child_process";function en(t){let n=t||d();try{return so("git rev-parse --show-toplevel",{cwd:n,encoding:"utf8",timeout:5e3,stdio:["pipe","pipe","pipe"]}).trim()}catch{return n}}function io(t,n){let e=[];if(/\.(ts|tsx|js|jsx)$/.test(n)){let s=t.match(/(function|class|const|export function|export class)\s+[A-Za-z_][A-Za-z0-9_]*/g);s&&e.push(...s)}else if(n.endsWith(".py")){let s=t.split(`
`);for(let r of s){let o=r.match(/^(def|class)\s+[A-Za-z_][A-Za-z0-9_]*/);o&&e.push(o[0])}}return[...new Set(e)]}function ao(t,n){let e=[],s=["node_modules",".venv","venv","__pycache__","dist","build",".next",".git"];function r(o){try{let a=oo(o,{withFileTypes:!0});for(let c of a){let u=`${o}/${c.name}`;c.isDirectory()?s.includes(c.name)||r(u):c.isFile()&&n.test(c.name)&&e.push(u)}}catch{}}return r(t),e}function co(t){let n=[],e=t.split(`
`),s="",r=0,o=0;for(let a=0;a<e.length;a++){let c=e[a].trim();c&&c===s?(r++,r>=3&&n.push(`Line ${o}: ${s.substring(0,50)}`)):(s=c,r=1,o=a+1)}return n}function uo(t,n){let e=[],s=[];if(/\.(ts|tsx|js|jsx)$/.test(n)){/new Date.*toLocaleDateString/.test(t)&&(e.push("UTILITY: Direct date formatting detected"),e.push("  Use centralized date utilities: import { formatDate } from '@/lib/dates'"));let r=(t.match(/fetch\s*\(\s*['"]/g)||[]).length;r>2&&(s.push(`UTILITY: Multiple fetch calls detected (${r})`),s.push("  Consider using centralized API client or custom hook"));let o=(t.match(/if\s*\([^)]*\.test\([^)]*\)/g)||[]).length;o>3&&(s.push(`UTILITY: Multiple inline validations detected (${o})`),s.push("  Use Zod schemas: const schema = z.object({...})"))}if(n.endsWith(".py")){let r=(t.match(/json\.loads/g)||[]).length;r>3&&(s.push(`UTILITY: Multiple json.loads detected (${r})`),s.push("  Consider centralized JSON handling with error recovery"));let o=(t.match(/os\.getenv|os\.environ/g)||[]).length;o>5&&(s.push(`UTILITY: Multiple environment variable accesses (${o})`),s.push("  Use Settings/Config class with Pydantic validation"))}return{errors:e,warnings:s}}function nn(t){let n=t.tool_input?.file_path||"",e=t.tool_input?.content||t.tool_result||"";if(!n||!e)return p();if(!/\.(ts|tsx|js|jsx|py)$/.test(n))return p();let s=[],r=[],o=io(e,n);if(o.length>0){let u=en()||d(),l=ao(u,/\.(ts|tsx|js|jsx|py)$/);for(let g of o){let _=g.split(/\s+/).pop()||"";if(_){for(let m of l)if(m!==n)try{let v=ro(m,"utf8");if(new RegExp(`\\b${_.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\b`).test(v)&&v.includes(g)){let mn=m.replace(u+"/","");r.push(`DUPLICATE: '${_}' already exists in:`),r.push(`  - ${mn}`),r.push("  Consider:"),r.push("    1. Reusing existing implementation"),r.push("    2. Extracting to shared utility"),r.push("    3. Using different name if intentionally different");break}}catch{}}}}let a=co(e);if(a.length>0){r.push("COPY-PASTE: Repeated code blocks detected:");for(let u of a.slice(0,5))r.push(`  ${u}`);r.push("  Refactor repeated logic into functions")}let c=uo(e,n);if(s.push(...c.errors),r.push(...c.warnings),s.length>0){let u=`Duplicate code violation in ${n}. See stderr for details.`;return k(u)}if(r.length>0){let u=`Potential code duplication detected in ${n}. Review warnings on stderr.`;return k(u)}return p()}import{existsSync as Et,readFileSync as sn,readdirSync as po}from"node:fs";function rn(t){let n=d(),e=[];e.push("::group::LLM Evaluation Summary");let s=`${n}/eval_results.json`;if(Et(s)){e.push("Evaluation results found:");try{let a=sn(s,"utf8"),c=JSON.parse(a);if(typeof c=="object"&&c!==null){for(let[u,l]of Object.entries(c))if(typeof l=="number"){let g=Number.isInteger(l)?l.toString():l.toFixed(2);e.push(`  ${u}: ${g}`)}}}catch{try{let c=sn(s,"utf8").split(`
`).slice(0,20);e.push(...c)}catch{e.push("  (Unable to read file)")}}}let r=`${n}/.deepeval`;if(Et(r)){e.push(""),e.push("DeepEval results directory found");try{let a=po(r).slice(0,5);for(let c of a)e.push(`  ${c}`)}catch{}}let o=`${n}/ragas_results.json`;Et(o)&&(e.push(""),e.push("RAGAS evaluation results found")),e.push(""),e.push("Evaluation complete - review metrics above"),e.push("::endgroup::");for(let a of e)process.stderr.write(a+`
`);return p()}import{existsSync as lo,readFileSync as go}from"node:fs";import{execSync as fo}from"node:child_process";import{basename as mo}from"node:path";function on(t){let n=t.tool_input?.file_path||process.env.CC_TOOL_FILE_PATH||"";if(!n)return p();if(!n.includes("alembic/versions")||!n.endsWith(".py"))return p();if(!lo(n))return p();process.stderr.write(`::group::Migration Validation: ${mo(n)}
`);let e=[],s;try{s=go(n,"utf8")}catch{return e.push("Cannot read migration file"),k(`Migration validation failed for ${n}`)}s.includes("def upgrade")||e.push("Missing upgrade() function in migration"),s.includes("def downgrade")||e.push("Missing downgrade() function in migration"),/^revision = /m.test(s)||e.push("Missing revision ID in migration");try{fo(`python3 -m py_compile "${n}"`,{encoding:"utf8",timeout:1e4,stdio:["pipe","pipe","pipe"]})}catch{e.push("Python syntax error in migration")}if(e.length>0){process.stderr.write(`::error::Migration validation failed
`);for(let o of e)process.stderr.write(`  - ${o}
`);process.stderr.write(`::endgroup::
`),i("migration-validator",`BLOCKED: ${e[0]}`);let r=`Migration validation failed for ${n}. See stderr for details.`;return k(r)}return process.stderr.write(`Migration file is valid
`),process.stderr.write(`::endgroup::
`),p()}import{mkdirSync as ho}from"node:fs";function an(t){let n=b(),e=`${n}/review-summary.log`;try{ho(n,{recursive:!0})}catch{}let r=`[${new Date().toISOString().replace("T"," ").slice(0,19)}] Code Review Summary
Review checklist:
  [ ] All blocking issues addressed
  [ ] Non-blocking suggestions noted
  [ ] Tests pass
  [ ] No security concerns
  [ ] Documentation updated if needed

Conventional comment prefixes used:
  - blocking: Must fix before merge
  - suggestion: Consider this improvement
  - nitpick: Minor style issue
  - question: Needs clarification
  - praise: Good work!
`;try{h(e,r+`
`)}catch{}return p()}import{mkdirSync as yo}from"node:fs";function cn(t){let n=b(),e=`${n}/security-summary.log`;try{yo(n,{recursive:!0})}catch{}let r=`[${new Date().toISOString().replace("T"," ").slice(0,19)}] Security Scan Complete
Review findings for:
  - Critical/High vulnerabilities (fix immediately)
  - Dependency CVEs (update packages)
  - Hardcoded secrets (move to env vars)
  - OWASP Top 10 violations

Next steps:
  1. Triage findings by severity
  2. Create issues for critical/high
  3. Update dependencies with CVEs
`;try{h(e,r+`
`)}catch{}return p()}function _o(t){return!!(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(t)||/(^|\/)test_[^/]*\.py$/.test(t)||/_test\.py$/.test(t))}function un(t){let n=t.tool_input?.file_path||"",e=t.tool_input?.content||t.tool_result||"";if(!n||!e)return p();if(!_o(n))return p();let s=[];if(/\.(ts|tsx|js|jsx)$/.test(n)){let r=e.match(/(test|it)\(['"][^'"]{1,10}['"]/g);r&&r.some(u=>/test[0-9]|works|^test$/i.test(u))&&(s.push("Test names too short or generic. Use descriptive names:"),s.push("  BAD:  test('test1'), test('works')"),s.push("  GOOD: test('should return user when ID exists')")),/^let [a-zA-Z_][a-zA-Z0-9_]* =/m.test(e)&&(/beforeEach\s*\(\s*(async\s*)?\(\s*\)\s*=>/.test(e)||(s.push("Shared mutable state detected without beforeEach reset:"),s.push("  Add beforeEach(() => { /* reset state */ }) to ensure test isolation")));let o=(e.match(/expect\(/g)||[]).length,a=(e.match(/(test|it)\s*\(/g)||[]).length||1,c=Math.floor(o/a);c>5&&(s.push(`High assertion count (avg ${c} per test):`),s.push("  Consider splitting into focused tests with 1-3 assertions each"),s.push("  Or add AAA comments (// Arrange, // Act, // Assert)")),/console\.(log|warn|error)\(/.test(e)&&(s.push("console.log found in test file:"),s.push("  Remove debugging statements before committing"),s.push("  Use proper assertions instead")),/(test|it|describe)\.only\(/.test(e)&&(s.push(".only() found - this skips other tests:"),s.push("  Remove .only() before committing")),/(test|it|describe)\.skip\(/.test(e)&&(/TODO|FIXME|skip.*because|temporarily/i.test(e)||(s.push(".skip() found without explanation:"),s.push("  Add a comment explaining why the test is skipped"),s.push("  Example: test.skip('reason: waiting for API fix')")))}return n.endsWith(".py")&&(/def test[A-Z]/.test(e)&&(s.push("Test names must use snake_case, not camelCase:"),s.push("  BAD:  def testUserCreation()"),s.push("  GOOD: def test_user_creation()")),/def (setUp|tearDown|setUpClass|tearDownClass)\s*\(/.test(e)&&(s.push("Use pytest fixtures instead of unittest setUp/tearDown:"),s.push("  BAD:  def setUp(self): ..."),s.push("  GOOD: @pytest.fixture\\n        def setup_data(): ...")),/class Test.*:/.test(e)&&(/^\s+[a-z_]+ = \[\]/m.test(e)||/^\s+[a-z_]+ = \{\}/m.test(e))&&(s.push("Class-level mutable defaults can cause test pollution:"),s.push("  BAD:  class TestUser:\\n            items = []"),s.push("  GOOD: Use @pytest.fixture to create fresh instances")),/^\s+print\(/m.test(e)&&(s.push("print() found in test file:"),s.push("  Remove debugging statements before committing"),s.push("  Use proper assertions or pytest's capfd fixture")),(/@pytest\.mark\.skip\s*$/.test(e)||/@pytest\.mark\.skip\(\s*\)/.test(e))&&(s.push("@pytest.mark.skip without reason:"),s.push("  Add reason: @pytest.mark.skip(reason='waiting for fix')")),/async def test_/.test(e)&&(/@pytest\.mark\.asyncio/.test(e)||(s.push("Async test found without @pytest.mark.asyncio:"),s.push("  Add: @pytest.mark.asyncio"),s.push("  Or set asyncio_mode = auto in pytest.ini")))),s.length>0?(i("test-pattern-validator",`BLOCKED: ${s[0]}`),T(`Test pattern violations detected in ${n}`)):p()}import{existsSync as pn}from"node:fs";import{execSync as B}from"node:child_process";import{basename as Ht,dirname as Ft}from"node:path";function ko(t){let n=t;for(;n&&n!=="/"&&n.length>0;){if(pn(`${n}/package.json`))return n;let e=Ft(n);if(e===n)break;n=e}return null}function ln(t){let n=t.tool_input?.file_path||process.env.CC_TOOL_FILE_PATH||"";if(!n)return p();if(/test.*\.py$/.test(n)||/_test\.py$/.test(n)){process.stderr.write(`::group::Auto-running Python test: ${Ht(n)}
`);let e=Ft(n);try{if(pn(`${e}/pyproject.toml`))try{B("command -v poetry",{stdio:["pipe","pipe","pipe"]});let r=B(`poetry run pytest "${n}" -v --tb=short`,{cwd:e,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(r.join(`
`)+`
`)}catch{}try{B("command -v pytest",{stdio:["pipe","pipe","pipe"]});let r=B(`pytest "${n}" -v --tb=short`,{cwd:e,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(r.join(`
`)+`
`)}catch{process.stderr.write(`pytest not found - skipping auto-run
`)}}catch(s){s instanceof Error&&process.stderr.write(`Test execution error: ${s.message}
`)}process.stderr.write(`::endgroup::
`)}if(/\.(test|spec)\.(ts|tsx|js|jsx)$/.test(n)){process.stderr.write(`::group::Auto-running TypeScript test: ${Ht(n)}
`);let e=ko(Ft(n));if(e)try{let s=Ht(n).replace(/\.[^.]+$/,"").replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),o=B(`npm test -- --testPathPattern="${s}"`,{cwd:e,encoding:"utf8",timeout:6e4,stdio:["pipe","pipe","pipe"]}).split(`
`).slice(-30);process.stderr.write(o.join(`
`)+`
`)}catch(s){s instanceof Error&&process.stderr.write(`Test execution error: ${s.message}
`)}process.stderr.write(`::endgroup::
`)}return p()}var dn=[{name:"auto-save-context",fn:G},{name:"session-patterns",fn:tt},{name:"issue-work-summary",fn:V},{name:"calibration-persist",fn:nt},{name:"session-profile-aggregator",fn:Ge},{name:"session-end-tracking",fn:it},{name:"workflow-preference-learner",fn:at},{name:"task-completion-check",fn:et},{name:"context-compressor",fn:q},{name:"auto-remember-continuity",fn:z},{name:"security-scan-aggregator",fn:K},{name:"coverage-check",fn:Ke},{name:"evidence-collector",fn:Xe},{name:"coverage-threshold-gate",fn:Ye},{name:"cross-instance-test-validator",fn:Qe},{name:"di-pattern-enforcer",fn:tn},{name:"duplicate-code-detector",fn:nn},{name:"eval-metrics-collector",fn:rn},{name:"migration-validator",fn:on},{name:"review-summary-generator",fn:an},{name:"security-summary",fn:cn},{name:"test-pattern-validator",fn:un},{name:"test-runner",fn:ln},{name:"full-test-suite",fn:Z}];async function gn(t){if(t.stop_hook_active)return i("stop-dispatcher","Skipping: stop_hook_active=true (re-entry prevention)"),p();let e=(await Promise.allSettled(dn.map(async s=>{try{let r=s.fn(t);return r instanceof Promise&&await r,{hook:s.name,status:"success"}}catch(r){let o=r instanceof Error?r.message:String(r);return i("stop-dispatcher",`${s.name} failed: ${o}`),{hook:s.name,status:"error",message:o}}}))).filter(s=>s.status==="rejected"||s.status==="fulfilled"&&s.value.status==="error");return e.length>0&&i("stop-dispatcher",`${e.length}/${dn.length} hooks had errors`),p()}var fn={"stop/auto-remember-continuity":z,"stop/auto-save-context":G,"stop/context-compressor":q,"stop/full-test-suite":Z,"stop/issue-work-summary":V,"stop/security-scan-aggregator":K,"stop/session-patterns":tt,"stop/task-completion-check":et,"stop/calibration-persist":nt,"stop/unified-dispatcher":gn,"stop/workflow-preference-learner":at,"stop/session-end-tracking":it};function Eu(t){return fn[t]}function Hu(){return Object.keys(fn)}export{se as applyDecay,ii as escapeRegex,Zn as estimateTokenCount,di as getAdjustments,gi as getAgentSuccessRate,zo as getCachedBranch,fi as getCalibrationStats,Jo as getEnvFile,ri as getField,Eu as getHook,b as getLogDir,Bn as getLogLevel,Ln as getPluginRoot,d as getProjectDir,f as getSessionId,mi as hasMinimalCalibrationData,es as hashPrompt,fn as hooks,bo as isBashInput,xo as isEditInput,wo as isReadInput,vo as isWriteInput,Hu as listHooks,I as loadCalibrationData,i as logHook,ei as logPermissionFeedback,oi as normalizeCommand,Go as normalizeLineEndings,Vo as outputAllowWithContext,T as outputBlock,Qo as outputDeny,Ko as outputError,zn as outputPromptContext,ni as outputPromptContextBudgeted,qo as outputSilentAllow,p as outputSilentSuccess,Yo as outputStderrWarning,Xo as outputWarning,k as outputWithContext,Zo as outputWithNotification,ti as outputWithUpdatedInput,si as readHookInput,li as recordOutcome,yt as saveCalibrationData,Jn as shouldLog};
//# sourceMappingURL=stop.mjs.map
