// Generated by OrchestKit Claude Plugin
// Created: 2026-02-05

/**
 * Model Cost Advisor - SubagentStart Hook
 * Opus 4.6 Upgrade: Analyzes task complexity and recommends optimal model.
 *
 * Uses skill `complexity` field and task description keywords to detect
 * when an expensive model (opus) is being used for simple tasks,
 * or when a cheap model (haiku) is used for complex tasks.
 *
 * Addresses: Issue #331
 * Version: 1.0.0
 */

import { appendFileSync, mkdirSync, existsSync, readFileSync } from 'node:fs';
import { join, dirname } from 'node:path';
import type { HookInput, HookResult } from '../types.js';
import { outputSilentSuccess, outputWarning, logHook, getProjectDir, getPluginRoot } from '../lib/common.js';

// Agent model assignments from agent definitions
const OPUS_AGENTS = new Set([
  'backend-system-architect', 'infrastructure-architect', 'workflow-architect',
  'event-driven-architect', 'python-performance-engineer', 'ai-safety-auditor',
]);

const SONNET_AGENTS = new Set([
  'demo-producer',
]);

// Keywords signaling high complexity (should use opus)
const HIGH_COMPLEXITY_SIGNALS = [
  /security|vulnerab|audit|penetration/i,
  /architect|design.*system|distributed/i,
  /migration.*schema|database.*design/i,
  /performance.*optim|profil|bottleneck/i,
  /langgraph|workflow.*orchestrat/i,
];

// Keywords signaling low complexity (safe for haiku)
const LOW_COMPLEXITY_SIGNALS = [
  /list|count|check|verify|read|search/i,
  /simple|straightforward|quick/i,
  /format|lint|style|typo|rename/i,
  /status|progress|summary/i,
];

interface ModelAdvice {
  recommended: string;
  current: string;
  reason: string;
  savingsPercent: number;
}

/**
 * Read complexity from agent's skill frontmatter fields.
 * Returns the highest complexity among the agent's skills.
 */
function getAgentSkillComplexity(agentType: string): 'low' | 'medium' | 'high' | null {
  const pluginRoot = getPluginRoot();
  if (!pluginRoot) return null;

  const agentFile = join(pluginRoot, 'agents', `${agentType}.md`);
  if (!existsSync(agentFile)) return null;

  try {
    const content = readFileSync(agentFile, 'utf8');
    const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!fmMatch) return null;

    // Extract skills list from agent frontmatter
    const skillsMatch = fmMatch[1].match(/^skills:\s*\n((?:\s+-\s+.+\n)*)/m);
    if (!skillsMatch) return null;

    const skills = skillsMatch[1].match(/^\s+-\s+(.+)$/gm)?.map(s => s.trim().replace(/^-\s+/, '')) || [];
    if (skills.length === 0) return null;

    // Sample up to 5 skills to check complexity (performance: don't read all 30+)
    const complexityOrder = { low: 0, medium: 1, high: 2 };
    let maxComplexity: 'low' | 'medium' | 'high' = 'low';

    const sampled = skills.slice(0, 5);
    for (const skill of sampled) {
      const skillFile = join(pluginRoot, 'skills', skill, 'SKILL.md');
      if (!existsSync(skillFile)) continue;

      const skillContent = readFileSync(skillFile, 'utf8');
      const skillFm = skillContent.match(/^---\n([\s\S]*?)\n---/);
      if (!skillFm) continue;

      const cMatch = skillFm[1].match(/^complexity:\s*(low|medium|high)$/m);
      if (cMatch) {
        const c = cMatch[1] as 'low' | 'medium' | 'high';
        if (complexityOrder[c] > complexityOrder[maxComplexity]) {
          maxComplexity = c;
        }
      }
    }

    return maxComplexity;
  } catch {
    return null;
  }
}

/**
 * Detect task complexity from description, agent type, and skill frontmatter.
 * Priority: skill frontmatter > keyword heuristics > agent type defaults.
 */
function analyzeComplexity(agentType: string, description: string): 'low' | 'medium' | 'high' {
  // 1. Check skill frontmatter complexity (most accurate)
  const skillComplexity = getAgentSkillComplexity(agentType);
  if (skillComplexity === 'high') return 'high';

  // 2. Check high-complexity keyword signals
  const highMatches = HIGH_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;
  if (highMatches >= 2 || OPUS_AGENTS.has(agentType)) return 'high';

  // 3. Check low-complexity keyword signals
  const lowMatches = LOW_COMPLEXITY_SIGNALS.filter(p => p.test(description)).length;
  if (lowMatches >= 2) return 'low';

  // 4. Fall back to skill complexity if available
  if (skillComplexity) return skillComplexity;

  return 'medium';
}

/**
 * Determine current model for agent
 */
function getCurrentModel(agentType: string): string {
  if (OPUS_AGENTS.has(agentType)) return 'opus';
  if (SONNET_AGENTS.has(agentType)) return 'sonnet';
  // 'inherit' agents use the parent's model
  return process.env.CLAUDE_MODEL || 'sonnet';
}

/**
 * Get model recommendation
 */
function getModelAdvice(agentType: string, description: string): ModelAdvice | null {
  const complexity = analyzeComplexity(agentType, description);
  const current = getCurrentModel(agentType);

  // High complexity task on cheap model → recommend upgrade
  if (complexity === 'high' && current === 'haiku') {
    return {
      recommended: 'sonnet',
      current,
      reason: 'High-complexity task detected — haiku may produce lower quality results',
      savingsPercent: 0,
    };
  }

  // Low complexity task on expensive model → recommend downgrade
  if (complexity === 'low' && current === 'opus') {
    return {
      recommended: 'sonnet',
      current,
      reason: 'Simple task detected — sonnet handles this equally well at lower cost',
      savingsPercent: 40,
    };
  }

  // Medium complexity on opus → suggest sonnet for cost savings
  if (complexity === 'medium' && current === 'opus' && !OPUS_AGENTS.has(agentType)) {
    return {
      recommended: 'sonnet',
      current,
      reason: 'Medium-complexity task — sonnet is sufficient, Opus adds cost without benefit',
      savingsPercent: 30,
    };
  }

  return null; // No recommendation needed
}

/**
 * Log model usage for analytics
 */
function logModelUsage(agentType: string, model: string, complexity: string, advice: ModelAdvice | null): void {
  const logFile = join(getProjectDir(), '.claude', 'logs', 'model-usage.jsonl');
  try {
    mkdirSync(dirname(logFile), { recursive: true });
    const entry = {
      timestamp: new Date().toISOString(),
      agent: agentType,
      model,
      complexity,
      recommendation: advice?.recommended || null,
      potentialSavings: advice?.savingsPercent || 0,
    };
    appendFileSync(logFile, JSON.stringify(entry) + '\n');
  } catch {
    // Non-critical, ignore
  }
}

/**
 * Model cost advisor hook — runs at SubagentStart
 */
export function modelCostAdvisor(input: HookInput): HookResult {
  const toolInput = input.tool_input || {};
  const agentType = (toolInput.subagent_type as string) || '';
  const description = (toolInput.description as string) || '';

  if (!agentType) {
    return outputSilentSuccess();
  }

  const complexity = analyzeComplexity(agentType, description);
  const currentModel = getCurrentModel(agentType);
  const advice = getModelAdvice(agentType, description);

  // Log usage for analytics
  logModelUsage(agentType, currentModel, complexity, advice);

  if (!advice) {
    logHook('model-cost-advisor', `${agentType}: ${currentModel} is appropriate for ${complexity} task`);
    return outputSilentSuccess();
  }

  logHook('model-cost-advisor',
    `${agentType}: Recommend ${advice.recommended} instead of ${advice.current} (${advice.reason})`,
    'info'
  );

  // Only show warning for significant cost savings (>= 30%)
  if (advice.savingsPercent >= 30) {
    return outputWarning(
      `Model cost optimization: ${agentType} using ${advice.current} for ${complexity}-complexity task. ` +
      `${advice.reason}. Potential savings: ~${advice.savingsPercent}%. ` +
      `Consider using model: "${advice.recommended}" for this agent.`
    );
  }

  return outputSilentSuccess();
}
